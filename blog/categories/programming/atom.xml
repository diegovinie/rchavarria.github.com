<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2014-10-17T00:10:44+02:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mejora contínua y análisis estático de código]]></title>
    <link href="http://rchavarria.github.io/blog/2014/05/05/mejora-continua-y-analisis-estatico-de-codigo/"/>
    <updated>2014-05-05T20:00:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2014/05/05/mejora-continua-y-analisis-estatico-de-codigo</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2014/phpcs-small.png" width="350" height="140" title="Evolución del análisis estático de código" ></p>

<p>En una de las últimas retrospectivas de mi equipo de desarrollo, estuvimos
hablando sobre la mejora contínua, y qué podríamos hacer sobre ella. Afortunadamente
usamos <em>Jenkins</em> como servidor de integración contínua y hace ya tiempo configuré
un proyecto en dicha herramienta para realizar análisis estático de código frecuentemente.</p>

<p>Pero hasta ahora no habíamos tomado ninguna decisión sobre qué hacer con ella. Y
en esta retro surgió la oportunidad.</p>

<!-- more -->


<h2>La herramienta</h2>

<p>Como herramienta de análisis estático de código usamos
<a href="https://github.com/squizlabs/PHP_CodeSniffer">PHP_CodeSniffer</a>. La razón
principal es que es una herramienta adecuada al lenguaje que queremos analizar, y
existe un proyecto que integra esta herramienta entre otras con Jenkins
(<a href="http://phpqatools.org">PHP QA Tools</a>).</p>

<p>Una vez instalada y configurada, activamos todas las reglas de estilo disponibles
en la herramienta. Estas reglas incluyen comprobaciones para nombrado de funciones,
nombrado de ficheros, uso de constantes en PHP como <code>true</code> o <code>false</code>, o ciertas
reglas de espaciado: después del nombre de función, alineación del operador de
asignación. Multitud de ellas.</p>

<blockquote><p>Si no puedes medirlo, no puedes mejorarlo</p></blockquote>

<h2>Violaciones del estándar de código</h2>

<p><img class="center" src="/images/2014/phpcs-large.png" title="Descenso del número de errores" ></p>

<p>En el momento de la conversación sobre la mejora contínua nos encontrábamos en
el máximo que se aprecia en el gráfico, unas 8000 violaciones de reglas de
estilo.</p>

<p>Y nos pusimos manos a la obra. Después de un pequeño análisis por nuestra parte,
y unos pocos diálogos (la palabra discusiones tiene un pequeño significado de
lucha que no encaja en esta situación), conseguimos bajar ese número a menos de
30. Por lo tanto, está claro que hemos conseguido alguna <strong>mejora</strong>.</p>

<h2>Qué mejoras obtuvimos</h2>

<p>En el pequeños análisis realizado por nosotros, descubrimos que algunas reglas de
estilo que teníamos activadas resultaban contradictorias. Mientras que una
obligaba a abrir llaves en la misma línea que la definición de la función:</p>

<pre><code>public function doSomething() {
</code></pre>

<p>existía otra regla que obligaba a abrir llaves en una línea nueva:</p>

<pre><code>public function doSomething()
{
</code></pre>

<p>Por lo tanto, una de las dos había que desactivarla, ¿pero cuál?. He aquí la
verdadera mejora. La mejora no es utilizar una regla u otra, sino alcanzar un
consenso dentro del equipo y decidir qué estilo queremos seguir a la hora de
escribir código.</p>

<p>Algunas otras reglas nos permitieron detectar qué clases necesitaban ser
refactorizadas. Por ejemplo, si un método tiene una <em>complejidad ciclomática</em>
elevada o si un método está escrito con demasiados niveles de anidamiento.</p>

<p>Otras reglas simplemente nos enfrentaron a la toma de ciertas decisiones:</p>

<ul>
<li>Cómo queremos organizar nuestros ficheros</li>
<li>Cómo queremos dar el nombre a nuestros métodos</li>
<li>Cómo queremos indentar nuestro código</li>
</ul>


<h2>Conclusión</h2>

<p>No me importa volver a repetirlo, la verdadera mejora no surge de seguir una
regla u otra a la hora de escribir código. La verdadera mejora surge de las
conversaciones, diálogos y <em>discusiones</em> entre los miembros del equipo.</p>

<p>¿Y dónde está la parte de <em>contínua</em>? Se encuentra en el servidor de integración
contínua. Nuestro código es analizado contínuamente, y en el caso de que haya
un aumento significativo de violaciones de reglas de estilo en nuestro código,
seremos avisados y podremos tomar la decisión sobre si retomamos el control
o lo dejamos para más adelante.</p>

<h2>Referencias</h2>

<ul>
<li><a href="https://es.wikipedia.org/wiki/Proceso_de_mejora_continua">Mejora contínua</a></li>
<li><a href="https://es.wikipedia.org/wiki/Integraci%C3%B3n_continua">Integración contínua</a></li>
<li><a href="https://en.wikipedia.org/wiki/Static_code_analysis">Análisis estático de código</a>
(inglés)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crear una applicación cliente para un servicio web]]></title>
    <link href="http://rchavarria.github.io/blog/2013/09/26/crear-cliente-servicio-web/"/>
    <updated>2013-09-26T07:41:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2013/09/26/crear-cliente-servicio-web</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
    Find a lightweight English version of this post directly in the <a href="https://github.com/rchavarria/javaee-6-demos/tree/master/ws-jaxws-client">source code repository</a>.
</div>


<p>En esta demo crearemos un cliente para el servicio web desarrollado en la demo
anterior. Para ello, utilizaremos una herramienta proporcionada por Java para
generar unas clases a partir del fichero WSDL de descripción del servicio web, y
usaremos dichas clases para invocar el servicio. Así de fácil.</p>

<p>Se puede ver el código fuente de la demostración en el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/ws-jaxws-client"><code>ws-jaxws-client</code></a>
del repositorio de las demos en github.</p>

<!-- more -->


<h2>Demo</h2>

<p>Esta demo pertenece a una serie de
<a href="/blog/2013/09/03/demos-tecnologias-javaee">tutoriales de demostración de tecnologías J2EE</a> y
en esta en particular crearemos en cliente que invocará a los métodos expuestos por el servicio
web desarrollado en la demo anterior. Estos métodos son:</p>

<ol>
<li>Añadir usuario: añadiremos un nombre de usuario al servicio.</li>
<li>Obtener usuario: mediante un identificador, obtendremos un nombre de usuario.</li>
</ol>


<p>Con lo cual, añadiremos y consultaremos usuarios.</p>

<h2>Pasos a seguir</h2>

<h3>Arrancar el servicio web</h3>

<p>Lo primero que debemos hacer es arrancar nuestro servicio web. Es necesario para que
el fichero WSDL, que describe el servicio, esté disponible y actualizado. También
es posible usar un fichero ya existente, por ejemplo, en el caso de que queramos
desarrollar un cliente para un servicio web de terceros. En definitiva, el elemento
realmente importante en un servicio web, es el fichero WSDL, que es quien define
de manera inequívoca el servicio en sí.</p>

<p>Para esta demo, arrancaremos el servicio web desarrollado en la
<a href="/blog/2013/09/19/crear-servicio-web-jaxws">demo anterior</a>. Básicamente, los comandos
para arrancarlo, partiendo del directorio raíz del código fuente de todas las demos:</p>

<p><code>
cd ws-jaxws-cxf
mvn jetty:run
</code></p>

<p>De esta forma tendremos el fichero WSDL disponible en <code>http://localhost:8080/Users?wsdl</code>.</p>

<h3>Generar las clases necesarias con <code>wsimport</code></h3>

<p>Java proporciona una herramienta, <code>wsimport</code>, que genera las clases necesarias
para poder consumir fácilmente un servicio web a partir de un fichero WSDL.</p>

<p>La sintaxis del comando es:</p>

<p><code>
wsimport [options] &lt;WSDL_URI&gt;
</code></p>

<p>Así, en nuestro caso, un ejemplo sería:</p>

<p><code>   
wsimport http://localhost:8080/Users?wsdl
</code></p>

<p>Este comando genera las clases, las compila y borra el código fuente. Esto no es
muy práctico a la hora de aprender, así que usaremos algunas opciones para
obtener el código fuente de las clases generadas.</p>

<ul>
<li><code>-d src/main/java</code>: indica el directorio donde queremos generar las clases.</li>
<li><code>-keep</code>: mantiene los ficheros <code>.java</code> generados.</li>
<li><code>-Xnocompile</code>: no compila los fuentes generados, ya se encargará nuestra
herramienta de ello, no os preocupéis.</li>
</ul>


<p>El comando completo quedaría:</p>

<p><code>
wsimport -d src/main/java -keep -Xnocompile http://localhost:8080/Users?wsdl
</code></p>

<p>Las clases generadas que más nos importan, son:</p>

<ul>
<li><code>UsersManagementService</code>: esta clase representa el servicio web en sí.</li>
<li><code>UsersManagement</code>: esta clase contiene los mismos métodos que el servicio web
definido por el fichero WSDL, y actúa como un proxy a la hora de invocar a nuestro
servicio. A esta clase se le denomina <code>port</code> (puerto), y es quien nos permite llamar
a los <em>métodos</em> web.</li>
</ul>


<h3>Crear un test de JUnit para invocar el servicio web</h3>

<p><img class="left" src="/images/2013/web-service-test.png" title="Ejecución de la demo como un test" ></p>

<p>Usaremos un sencillo test de JUnit para invocar a nuestro servicio. Se puede utilizar
una clase normal de Java, con un método <code>main</code>, pero haciéndolo con un test, podemos
integrar su ejecución en el ciclo de vida del proyecto gestionado por <code>maven</code> y
ejecutarlo muy fácilmente con <code>mvn test</code>.</p>

<p>Antes de nada, es necesario añadir la dependencia de JUnit a nuestro proyecto:</p>

<p>``` xml
<dependency></p>

<pre><code>&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;version&gt;4.8.1&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>Crearemos el test en el paquete <code>es.rchavarria.ws.client</code>. En el método <code>setUp</code>
de nuestro test (el que se ejecutará antes que cualquier test) crearemos una
instancia del servicio, y a través de él, obtendremos una instancia de nuestra
clase <em>port</em>. Esta clase será quien nos permita invocar al servicio web.</p>

<p>``` java
//...
public class JaxWsClientTest {</p>

<pre><code>private UsersManagement port;

@Before
public void setUp() {
    UsersManagementService service = new UsersManagementService();
    port = service.getUsersManagementPort();
}
</code></pre>

<p>//...      <br/>
}
```</p>

<h3>Invocando el servicio web</h3>

<p>Ahora ya disponemos de la clase <em>port</em>, así que ya somos capaces de invocar los
métodos expuestos por el servicio: <code>addUser</code> y <code>getUser</code>. A por ellos!!</p>

<p>``` java
@Test
public void test() {</p>

<pre><code>assertEquals(1, port.addUser("The boss"));
assertEquals(2, port.addUser("The king"));
assertEquals(3, port.addUser("The queen"));

assertEquals("The boss", port.getUser(1));
assertEquals("The queen", port.getUser(3));
assertEquals("The king", port.getUser(2));
</code></pre>

<p>}
```</p>

<h2>Ejecución</h2>

<p>Esta demo se puede ejecutar como un test de JUnit, y estaría integrado en la ejecución
de <code>maven</code>, así que simplemente ejecuta el comando <code>mvn test</code> para ver los resultados.</p>

<p>He añadido también un plugin, surefire report, por lo que ejecutnado el comando
<code>mvn site</code>, la herramienta generará (entre otras cosas), un informe con los resultados
de la ejecución de nuestros tests. Ejecuta el comando y abre el fichero HTML que
encontrarás en esta ruta dentro del directorio raiz del proyecto <code>target/site/index.html</code>.</p>

<h2>Enlaces para ampliar información</h2>

<ul>
<li><a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnayl.html">Building web services with JAX-WS</a></li>
<li><a href="http://docs.oracle.com/javaee/6/tutorial/doc/giepu.html">Building RESTful Web Services with JAX-RS</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crear un servicio web JAX-WS]]></title>
    <link href="http://rchavarria.github.io/blog/2013/09/19/crear-servicio-web-jaxws/"/>
    <updated>2013-09-19T08:49:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2013/09/19/crear-servicio-web-jaxws</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
    Find a lightweight English version of this post directly in the <a href="https://github.com/rchavarria/javaee-6-demos/tree/master/ws-jaxws-cxf">source code repository</a>.
</div>


<p>En esta demo crearemos un servicio web. Básicamente existen dos tipos de servicios
web: SOAP, basados en el intercambio de mensajes XML; y servicios web basados en
una interfaces REST, RESTful web services.</p>

<p>Aquí crearemos un servicio web SOAP, el cual establece que los mensajes XML pueden ser
transportados por diversos protocolos, aquí lo haremos sobre HTTP, ya que es lo más
común y sencillo. Ya que usaremos HTTP como protocolo de transporte, nuestro servicio web estará
gestionado por un servlet.</p>

<p>Se puede ver el código fuente de la demostración en el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/ws-jaxws-cxf"><code>ws-jaxws-cxf</code></a>
del repositorio de las demos en github.</p>

<!-- more -->


<h2>Demo</h2>

<p><img class="right" src="/images/2013/web-services-by-psd.jpg" width="320" height="213" title="Foto por el usuario de flickr psd" ></p>

<p>En esta demo no veremos nada funcionando, ya que vamos a crear un servicio web
pero no vamos a crear un cliente que lo consuma (eso para la siguiente). La forma
de comprobar que hemos creado un servicio web correcto será la visualización del
fichero WSDL generado por el servicio, el cual es el contrato entre el proveedor
del servicio (lo creado en esta demo) y el consumidor del mismo (el cliente que
crearemos más adelante).</p>

<p>La funcionalidad que nos ofrecerá el servicio se apoyarán en dos métodos:</p>

<ol>
<li>Añadir usuario: añadiremos un nombre de usuario al servicio.</li>
<li>Obtener usuario: mediante un identificiador, obtendremos un nombre de usuario.</li>
</ol>


<p>Para ejecutar la demo, simplemente hay que descargase el código fuente y ejecutar
<code>mvn jetty:run</code> desde el directorio raiz de la demo. Visitar la página de login
<a href="http://localhost:8080/Users?wsdl">http://localhost:8080/Users?wsdl</a> y veremos
el fichero WSDL con la definición del servicio.</p>

<h2>Pasos a seguir</h2>

<h3>Elegir un framework que implemente JAX-WS</h3>

<p>Según la <a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnayl.html">documentación de Oracle</a>,
crear un servicio web parece realmente
sencillo y para toda la familia. Lo que no explican es que están dependiendo
de la implementación de los servicios web incluída en <em>su</em> contenedor Java EE,
Glassfish. No tengo nada en contra, pero me gusta tener cierta independencia,
por lo que vamos a elegir otro framework que implemente la especificación
JAX-WS.</p>

<p>He elegido <a href="http://cxf.apache.org">Apache CXF</a>, aunque hay otras implementaciones
disponibles, como <a href="http://projects.spring.io/spring-ws/">Spring WS</a>
(quizá en un futuro, veamos su uso).</p>

<h3>Dependencias del proyecto maven</h3>

<p>Como todas las demos, utilizaremos <code>maven</code> como gestor del ciclo de vida del
proyecto, y las dependencias son una parte muy importante de la vida del proyecto.</p>

<p>La aplicación depende de:</p>

<ul>
<li><code>javax.servlet-api</code>: el API de Java EE para servlets, ya que será un servlet
quien gestione las peticiones HTTP. Nuestro servicio web se basará en este servlet.</li>
<li><code>cxf-rt-frontend-jaxws</code>: la implementación de CXF de la especificación JAX-WS.</li>
<li><code>cxf-rt-transports-http</code>: HTTP será el protocolo de transporte.</li>
<li><code>spring-web</code>: CXF usa Spring internamente para su funcionamiento.</li>
</ul>


<h3>Crear el interfaz del servicio</h3>

<p>Nuestro servicio web servirá para almacenar nombres de usuarios, y se podrán
recuperar estos nombres a través de un identificador que devolverá el servicio
al añadirlos.</p>

<p>Por lo tanto, vemos que necesitaremos dos métodos:</p>

<ul>
<li><code>addUser</code>: para añadir un usuario al sistema.</li>
<li><code>getUser</code>: para recuperar un nombre de usuario.</li>
</ul>


<p>Nuestro interfaz de servicio sería algo así:</p>

<p>``` java
import javax.jws.WebService;
import javax.jws.WebParam;</p>

<p>@WebService
public interface UsersManagement {</p>

<pre><code>public String getUser(@WebParam(name="userId") int userId);
public int addUser(@WebParam(name="name") String name);
</code></pre>

<p>}
```</p>

<h3>Crear la implementación del servicio</h3>

<p>Ya tenemos la definición del servicio, ahora debemos implementarlo. Esta
implementación deberá estar anotada también con <code>@WebService</code>, y deberemos
proporcionar valores a algunos parámetros de la anotación. El más importante
es <code>endpointInterface</code>, que debe apuntar a la definición del servicio.</p>

<p>La implementación tendrá un aspecto similar a éste:</p>

<p>``` java
import javax.jws.WebService;</p>

<p>@WebService(endpointInterface = "es.rchavarria.ws.UsersManagement",</p>

<pre><code>        serviceName = "Users")
</code></pre>

<p>public class UsersManagementImpl implements UsersManagement {</p>

<pre><code> // ... implementación de los métodos
</code></pre>

<p>}
```</p>

<p>Invito a bucear en el código para ver la implementación de los métodos,
aunque no es muy interesante de ver, todo sea dicho.</p>

<h3>Establecer un servlet que gestione las peticiones HTTP</h3>

<p>El siguiente paso es establecer un servlet que gestione las peticiones HTTP.
Apache CXF nos proporciona dicho servlet, por lo que deberemos configurar
nuestro contenedor Java EE para que lo arranque. El servlet gestionará todas
las peticiones, con lo que estableceremos el patrón URL a <code>/*</code>.</p>

<p>Es muy importante que el patrón URL del servlet sea capaz de gestionar la URL
donde se despliegue el servicio web, en caso contrario, las peticiones no
llegarán al servicio web. Por ejemplo, si el patrón URL del servlet es
<code>/services/*</code> y nuestro servicio web se despliega en <code>/web-services/*</code>,
las peticiones a nuestro servicio no serán gestionadas por el servlet.</p>

<p>Para establecer el servlet, creamos un fichero descriptor de la aplicación web,
<code>web.xml</code>:</p>

<p>``` xml
<servlet></p>

<pre><code>&lt;servlet-name&gt;the-cxf-servlet&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;
&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
</code></pre>

<p></servlet></p>

<p><servlet-mapping></p>

<pre><code>&lt;servlet-name&gt;the-cxf-servlet&lt;/servlet-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
</code></pre>

<p></servlet-mapping>
```</p>

<h3>Configurar el servlet de CXF</h3>

<p>El servlet de CXF arrancará con el servidor, pero no sabe qué servicios web puede
invocar. Debemos configurarlo. CXF proporciona un mecanismo para ello, a través
de un fichero XML.</p>

<p>Podríamos utilizar un fichero por defecto, y guardarlo en <code>WEB-INF/cxf-servlet</code>,
o podemos configurarlo manualmente. Lo haremos de forma manual, e indicaremos al
servlet donde está su fichero de configuración. Se lo indicaremos a través de un
parámetro de inicialización de servlet, por lo que modificaremos nuestro <code>web.xml</code>:</p>

<p>``` xml</p>

<!-- ... -->


<p><servlet></p>

<pre><code>&lt;servlet-name&gt;the-cxf-servlet&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;

&lt;init-param&gt;
    &lt;param-name&gt;config-location&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/services.xml&lt;/param-value&gt;   
&lt;/init-param&gt;        

&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
</code></pre>

<p></servlet></p>

<!-- ... -->


<p>```</p>

<p>También debemos añadir el fichero de configuración del servlet CXF, el cual hemos
llamado <code>WEB-INF/services.xml</code>:</p>

<p>``` xml
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jaxws="http://cxf.apache.org/jaxws"
  xmlns:soap="http://cxf.apache.org/bindings/soap"
  xsi:schemaLocation="
</code></pre>

<p>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://cxf.apache.org/bindings/soap http://cxf.apache.org/schemas/configuration/soap.xsd
http://cxf.apache.org/jaxws
http://cxf.apache.org/schemas/jaxws.xsd"></p>

<p>  &lt;jaxws:server id="aServer" serviceClass="es.rchavarria.ws.UsersManagement" address="/Users"></p>

<pre><code>&lt;jaxws:serviceBean&gt;
    &lt;bean class="es.rchavarria.ws.UsersManagementImpl" /&gt;
&lt;/jaxws:serviceBean&gt;
</code></pre>

<p>  &lt;/jaxws:server>
</beans>
```</p>

<p>Esto es un fichero de configuración de Spring, y es que CXF usa Spring internamente. Se
añade un nuevo namespace, <code>jaxws</code>, proporcionado por CXF y que viene con etiquetas XML
para configurar un servidor que responda a las peticiones dirigidas a nuestro servicio web.</p>

<h3>Listos</h3>

<p>La demo ya está lista para ser ejecutada. Si la ejecutamos con el comando <code>mvn jetty:run</code>
podremos visitar <a href="http://localhost:8080/Users?wsdl">http://localhost:8080/Users?wsdl</a>
y veremos el fichero WSDL que define el servicio web.</p>

<p>En la próxima demo, crearemos un cliente a partir de este fichero WSDL, y comprobaremos
cómo funciona.</p>

<h2>Código fuente</h2>

<p>Para echar un ojo al código fuente, visitar el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/ws-jaxws-cxf"><code>ws-jaxws-cxf</code></a>.</p>

<h2>Enlaces para ampliar información</h2>

<ul>
<li><a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnayl.html">Construir servicios web con JAX-WS</a></li>
<li><a href="http://docs.oracle.com/javaee/6/tutorial/doc/giepu.html">Construir servicios web REST con JAX-RS</a></li>
<li><a href="http://cxf.apache.org/docs/index.html">Guía de uso de Apache CXF</a></li>
</ul>


<p><em>Imagen obtenida de <a href="http://www.flickr.com/photos/psd">psd</a></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Servlet redirecciona a una JSP]]></title>
    <link href="http://rchavarria.github.io/blog/2013/09/17/servlet-redirecciona-jsp/"/>
    <updated>2013-09-17T13:27:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2013/09/17/servlet-redirecciona-jsp</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
    Find a lightweight English version of this post directly in the <a href="https://github.com/rchavarria/javaee-6-demos/tree/master/request-parameters-jsp">source code repository</a>.
</div>


<p>Este post es una pequeña extensión del anterior, un servlet que leía los parámetros
de una petición HTTP. La demo anterior presentaba los parámetros leídos de una
forma muy tosca y básica. En esta demo, la información se va a presentar al usuario
de una forma más trabajada. Además, orientándonos hacia una arquitectura MVC,
separaremos las tareas de lectura de los parámetros y presentación de los datos.</p>

<p>Se puede ver el código fuente de la demostración en el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/request-parameters-jsp"><code>request-parameters-jsp</code></a>
del repositorio de las demos en github.</p>

<!-- more -->


<h2>Demo</h2>

<p>La demostración va a ser muy sencilla: crearemos en servlet, lo configuraremos
para que responda cuando un usuario envíe los campos de un formulario de login,
y haremos que redireccione a una página JSP, esta página se encargará de renderizar
los datos que viajarán como atributos de la petición.</p>

<p>Para ejecutar la demo, simplemente hay que descargase el código fuente y ejecutar
<code>mvn jetty:run</code> desde el directorio raiz de la demo. Visitar la página de login
<a href="http://localhost:8080/login.html">http://localhost:8080/login.html</a>, introducir
unos valores cualquiera y enviar los datos del formulario. Como resultado, veremos
el renderizado de la página JSP en el navegador.</p>

<p><img class="center" src="/images/2013/request-parameters-jsp.png" title="Respuesta del servlet" ></p>

<h2>Dependencias</h2>

<p>Como viene siendo habitual, para la demostración usaremos
<a href="http://maven.apache.org/">Apache Maven</a> para la gestión de dependencias.
En nuestro fichero <code>pom.xml</code> incluiremos la única dependencia del proyecto,
<code>javax-servlet-api</code> y listo.</p>

<h2>El servlet</h2>

<p>Nuestro servlet se trata de un servlet HTTP, luego heredará de <code>javax.servlet.http.HttpServlet</code>.
Lo configuraremos mediante anotaciones, con <code>@WebServlet</code>. Primero leerá los parámetros
enviados en la petición HTTP, igual que vimos en la anterior demo, y lo almacenará como un
atributo del objeto <code>request</code>, para que pueda ser leído por nuestra página JSP.</p>

<p><code>java
//...
List&lt;Parameter&gt; params = buildParamList(request);
request.setAttribute("params", params);
//...
</code></p>

<p>Luego, redireccionará la petición a nuestra página JSP. Se ha decidido hacer un
<code>forward</code> de la petición en lugar de hacer una redirección completa,
ya que la redirección provocaría una nueva petición HTTP y perderíamos los parámetros
de la petición original, y esto es algo que no deseamos.</p>

<p><code>java
//...
request.getRequestDispatcher("/params.jsp").forward(request, response);
//...
</code></p>

<h2>La página JSP</h2>

<p>Finalmente, la página JSP se encarga de presentar la información. De esta forma tenemos
construida nuestra demo siguiendo un patrón MVC (aunque es muy sencillo en este caso, ya
que solo contamos con un servlet y una página JSP), donde la página JSP juega el papel
de <em>vista</em>.</p>

<p>El código que nos interesa dentro del JSP es el que se encarga de iterar el
atributo que estableció el servlet, al que hemos llamado <code>params</code>.</p>

<p>``` html
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %></p>

<ul>
    <c:forEach var="p" items="${params}">
        <li>${p.key}: ${p.value}</li>
    </c:forEach>
</ul>


<p>```</p>

<h2>Código fuente</h2>

<p>Para echar un ojo al código fuente, visitar el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/request-parameters-jsp"><code>request-parameters-jsp</code></a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leer parámetros desde un servlet]]></title>
    <link href="http://rchavarria.github.io/blog/2013/09/13/servlet-lee-parametros/"/>
    <updated>2013-09-13T12:39:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2013/09/13/servlet-lee-parametros</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
    Find a lightweight English version of this post directly in the <a href="https://github.com/rchavarria/javaee-6-demos/tree/master/request-parameters">source code repository</a>.
</div>


<p>En este post veremos cómo un servlet puede leer los parámetros que vienen
encapsulados en la petición HTTP que realiza un usuario a nuestra aplicación web.
La configuración de dicho servlet la haremos mediante anotaciones para tener un
proyecto más sencillo.</p>

<p>Se puede ver el código fuente de la demostración en el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/request-parameters"><code>request-parameters</code></a>
del repositorio de las demos en github.</p>

<!-- more -->


<h2>Demo</h2>

<p>La demostración va a ser muy sencilla: crearemos en servlet, lo configuraremos
para que responda cuando un usuario envíe los campos de un formulario de login,
y haremos que responda con una página HTML que incluye una lista con los valores
de los campos de dicho formulario.</p>

<p>Para ejecutar la demo, simplemente hay que descargase el código fuente y ejecutar
<code>mvn jetty:run</code> desde el directorio raiz de la demo. Visitar la página de login
<a href="http://localhost:8080/login.html">http://localhost:8080/login.html</a>, introducir
unos valores cualquiera y enviar los datos del formulario. Veremos el resultado
que devuelve el servlet al leer los parámetros de la petición HTTP que hemos
enviado al servidor.</p>

<p><img class="center" src="/images/2013/request-parameters.png" title="Respuesta del servlet" ></p>

<h2>Dependencias</h2>

<p>Para esta demostración usaremos <a href="http://maven.apache.org/">Apache Maven</a> para
la gestión de dependencias. Esto nos facilitará enormemente nuestra labor de
programación. Si echamos un vistazo al fichero <code>pom.xml</code> de la demo, podremos
ver que solamente existe una dependencia externa, <code>javax-servlet-api</code>, que es
la que nos permitirá crear nuestro servlet.</p>

<h2>Página de login</h2>

<p><img class="right" src="/images/2013/login-form.png" title="Respuesta del servlet" ></p>

<p>La entrada a nuestra demo será la página de login, la cual contiene un formulario
muy simple, con dos campos principales: email del usuario y contraseña.</p>

<p>En el código HTML de la página, se ha establecido la acción del formulario a
<code>RequestParametersServlet</code>. Ésta va a ser la URL a la que nuestro servlet deberá responder.</p>

<p>``` html
<form action="RequestParametersServlet"></p>

<pre><code>&lt;input type="text" name="email" placeholder="Email address" autofocus /&gt;
&lt;input type="password" name="password" placeholder="Password" /&gt;

&lt;button type="submit"&gt;Log me in&lt;/button&gt;
</code></pre>

<p></form>
```</p>

<h2>El servlet</h2>

<p>Nuestro servlet se trata de un servlet HTTP, luego heredará de <code>javax.servlet.http.HttpServlet</code>.
Lo configuraremos mediante anotaciones, con <code>@WebServlet</code>. Y retornará un sencillo
código HTML que mostrará al usuario el valor de los parámetros enviados desde el
formulario de login.</p>

<p>La definión del servlet quedaría así:</p>

<p>``` java
@WebServlet(urlPatterns = {"/RequestParametersServlet"})
public class RequestParametersServletDemo extends HttpServlet {</p>

<pre><code>//...
</code></pre>

<p>}
```</p>

<p>Mientras que el código que lee los parámetros de la petición HTTP estaría agrupado en un
método con esta pinta:</p>

<p>``` java
private String outputParametersList(HttpServletRequest request) {</p>

<pre><code>Enumeration&lt;String&gt; names = request.getParameterNames();
if(!names.hasMoreElements()) return "";

StringBuilder sb = new StringBuilder();

sb.append("&lt;ul&gt;");
while(names.hasMoreElements()) {
    String name = names.nextElement();
    String value = request.getParameter(name);

    sb.append("&lt;li&gt;");
    sb.append(name + ": " + value);
    sb.append("&lt;/li&gt;");
}
sb.append("&lt;/ul&gt;");

return sb.toString();
</code></pre>

<p>}
```</p>

<p>Para echar un ojo al código fuente, visitar el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/request-parameters"><code>request-parameters</code></a>.</p>

<h2>Enlaces relacionados</h2>

<ul>
<li><a href="http://theopentutorials.com/examples/java-ee/servlet/get-all-parameters-in-html-form-using-getparameternames">The open tutorials</a>: cómo leer todos los campos de un formulario en un servlet.</li>
<li><a href="https://baurdotnet.wordpress.com/2011/01/31/getting-a-request-parameter-in-a-servlet">Leer un parámetro en un servlet</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
