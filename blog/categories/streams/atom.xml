<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: streams | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/streams/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2016-06-30T22:36:42+02:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dart Streams]]></title>
    <link href="http://rchavarria.github.io/blog/2015/03/28/dart-streams/"/>
    <updated>2015-03-28T01:39:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/03/28/dart-streams</id>
    <content type="html"><![CDATA[<p>Siendo Dart un lenguaje muy influenciado por JavaScript, no podría dejar de lado
conceptos como la <strong>programación asíncrona</strong>. Existen varios métodos para manejar
la asincronía, y uno de ellos son los <strong>Streams</strong>. Si estás muy interesado en
el método te recomiendo una charla de <a href="http://r.va.gg">Rod Vagg</a>, <a href="https://www.youtube.com/watch?v=oeKkwZhKgP0">Embrace the asynchronous</a>.</p>

<p>Los <em>Streams</em> en Dart forman una interfaz única para cualquier cosa que necesite
enviar repetidamente una serie de datos de forma asíncrona, ya sean eventos HTML
(como escuchar clicks del usuario), o eventos de entrada/salida en una aplicación
de servidor.</p>

<p>Operaciones sobre <em>Streams</em>:</p>

<ul>
<li>Consumir: los datos son sacados de un <code>Stream</code> a uno o varios <code>StreamSubscriber</code></li>
<li>Producir: los datos son introducidos en un <code>Stream</code> desde un <code>StreamController</code></li>
</ul>


<!-- more -->


<h2>Consumiendo un <code>Stream</code></h2>

<p>En lugar de introducir datos al Stream a través de un <code>StreamController</code>,
que podría ser algo largo de contar, vamos a utilizar el constructor
<code>Stream.fromIterable()</code>, el cual nos permite construir un <code>Stream</code> a partir de
una lista de objetos, por ejemplo.</p>

<p>Típicamente, se usa el método <code>listen()</code> para subscribirse a un <code>Stream</code>. Este método
es llamado cada vez que se recibe un dato:</p>

<p>```
var data = [1, 2, 3, 4, 5];
var stream = new Stream.fromIterable(data);</p>

<p>// subscribe to the streams events
stream.listen((value) {
  print("Received: $value");
});
```</p>

<p><code>Stream</code> también tiene otros métodos: <code>first</code>, <code>last</code>, <code>length</code> y <code>isEmpty</code>. Todos
ellos devuelven un <code>Future</code>, como los que estudiamos en <a href="/blog/2015/01/29/operaciones-asincronas-en-dart-con-futures/">Futures con Dart</a>, el cual
se completará con el valor apropiado dentro del <code>Stream</code>:</p>

<p>```
streamProperties() {
  var stream;</p>

<p>  stream = new Stream.fromIterable([1, 2, 3, 4, 5]);
  stream.first.then((value) => print("stream.first: $value"));  // 1</p>

<p>  stream = new Stream.fromIterable([1, 2, 3, 4, 5]);
  stream.last.then((value) => print("stream.last: $value"));  // 5</p>

<p>  stream = new Stream.fromIterable([1, 2, 3, 4, 5]);
  stream.isEmpty.then((value) => print("stream.isEmpty: $value")); // false</p>

<p>  stream = new Stream.fromIterable([1, 2, 3, 4, 5]);
  stream.length.then((value) => print("stream.length: $value")); // 5
}
```</p>

<p>También se pueden tener varios listeners, pero para eso hay que convertir el <code>Stream</code>
en un stream de broadcast con <code>asBroadcastStream()</code>. Podremos comprobar de qué tipo
es un stream con la propiedad <code>isBroadcast</code>.</p>

<p>```
var data = [1, 2, 3, 4, 5];
var stream = new Stream.fromIterable(data);
var broadcastStream = stream.asBroadcastStream();</p>

<p>broadcastStream.listen((value) => print("stream.listen: $value"));
broadcastStream.first.then((value) => print("stream.first: $value"));
//...
```</p>

<h2>Subconjuntos de datos de un <code>Stream</code></h2>

<p>Los <code>Stream</code>s tienen algunos métodos de utilidad que permiten seleccionar un subconjunto
de los datos que vendrán en él. Cada uno de estos métodos devuelve un
<code>Stream</code> al que podemos registrar un listener. Para una lista completa de estos métodos
se puede consultar la documentación oficial: <a href="http://api.dartlang.org/dart_async/Stream.html">API Streams</a>.</p>

<p><code>where</code>: selecciona aquellos datos que cumplen una condición:</p>

<p>```
broadcastStream</p>

<pre><code>.where((value) =&gt; value % 2 == 0) 
.listen((value) =&gt; print("where: $value"));
</code></pre>

<p>```</p>

<p><code>take</code>: toma solo los <code>n</code> primeros elementos:</p>

<p>```
broadcastStream</p>

<pre><code>.take(3) 
.listen((value) =&gt; print("take: $value"));
</code></pre>

<p>```</p>

<p><code>skip</code>: se salta los <code>n</code> primeros elementos:</p>

<p>```
broadcastStream</p>

<pre><code>.skip(3)
.listen((value) =&gt; print("skip: $value"));
</code></pre>

<p>```</p>

<p><code>takeWhile</code>: va tomando datos mientras la condición sea verdadera:</p>

<p>```
broadcastStream</p>

<pre><code>.takeWhile((value) =&gt; value &lt; 3) 
.listen((value) =&gt; print("takeWhile: $value"));
</code></pre>

<p>```</p>

<p><code>skipWhile</code>: va saltando datos mientras la condición sea verdadera:</p>

<p>```
broadcastStream</p>

<pre><code>.skipWhile((value) =&gt; value &lt; 3)
.listen((value) =&gt; print("skipWhile: $value"));
</code></pre>

<p>```</p>

<h2>Transformando streams</h2>

<p>El método <code>Stream.transform()</code> admite un parámetro de tipo <code>StreamTransformer</code>.
Es posible crear uno con el método <code>fromHandlers()</code>, el cual admite un
método como parámetro. Este método se llamará con 2 parámetros: cada uno de
los valores del <code>Stream</code> original, y un <code>StreamSink</code> al cual podremos añadir
el valor transformado. La salida de <code>transform()</code> es un nuevo <code>Stream</code> cuyos
valores han sido transformados por el <code>StreamTransformer</code>.</p>

<p>Todo esto se ve mucho más claro con un poco de código:</p>

<p>```
var transformer = new StreamTransformer.fromHandlers(handleData: (value, sink) {
  // create two new values from the original value
  sink.add("Message: $value");
  sink.add("Body: $value");
});</p>

<p>// transform the stream and listen to its output
stream.transform(transformer).listen((value) => print("listen: $value"));
```</p>

<p>Un ejemplo de la vida real podría ser la lectura de un fichero o de una
petición HTTP, transformando los datos recibidos a <code>String</code> con el decodificador
<code>UTF8.decoder()</code> del paquete <code>dart:convert</code>.</p>

<p>```
File file = new File("some_file.txt");
file.openRead()</p>

<pre><code>.transform(UTF8.decoder) // use a UTF8.decoder
.listen((String data) =&gt; print(data));
</code></pre>

<p>```</p>

<h2>Validando los valores de un <code>Stream</code></h2>

<p>Otros métodos útiles podrían ser <code>any()</code>, <code>every()</code> y <code>contains()</code>, los cuales
devuelven todos <code>Future&lt;boolean&gt;</code>, es decir, un <code>Future</code> que se completa con un
valor de <code>true</code> o <code>false</code>.</p>

<p>Estos métodos servirían para realizar ciertas comprobaciones sobre los datos
recibidos por el <code>Stream</code>. Siguiendo con el ejemplo que crea un <code>Stream</code> a partir
de un array con los valores del 1 al 5:</p>

<p>```
broadcastStream</p>

<pre><code>.any((value) =&gt; value &lt; 5)
.then((result) =&gt; print("Any less than 5?: $result")); // true
</code></pre>

<p>broadcastStream</p>

<pre><code>.every((value) =&gt; value &lt; 5)
.then((result) =&gt; print("All less than 5?: $result")); // false
</code></pre>

<p>broadcastStream</p>

<pre><code>.contains(4)
.then((result) =&gt; print("Contains 4?: $result")); // true
</code></pre>

<p>```</p>

<h2>Gestión de errores con <code>StreamSubscription</code></h2>

<p>Existen dos alternativas para la gestión de errores en los streams. Usando el
objeto <code>StreamSubscription</code> que retorna <code>listen()</code> o pasando los manejadores de
eventos al propio método <code>listen()</code>.</p>

<p>Usando <code>StreamSubscription</code> devuelto por <code>listen()</code>:</p>

<p><code>
var subscription = stream.listen(null);
subscription.onData((value) =&gt; print("listen: $value"));
subscription.onError((err) =&gt; print("error: $err"));
subscription.onDone(() =&gt; print("done"));
</code></p>

<p>Pásandolos como parámetros:</p>

<p>```
var subscription = stream.listen(</p>

<pre><code>(value) =&gt; print("listen: $value"),
onError: (err) =&gt; print("error: $err"),
onDone: () =&gt; print("done")
);
</code></pre>

<p>```</p>

<h2>Eliminando la suscripción a un <code>Stream</code></h2>

<p>Con el método anterior de obtener un objeto <code>StreamSubscription</code>, podemos
utilizar dicha referencia para cancelar la suscripción con el método <code>cancel()</code>.</p>

<p><code>
var subscription = stream.listen(null);
subscription.onData((value) {
  print("listen: $value");
  if (value == 2) subscription.cancel();
});
</code></p>

<h2>Referencias:</h2>

<ul>
<li><a href="https://www.youtube.com/watch?v=oeKkwZhKgP0">Embrace the asynchronous</a></li>
<li><a href="/blog/2015/01/29/operaciones-asincronas-en-dart-con-futures/">Futures con Dart</a>, en este propio blog</li>
<li><a href="http://api.dartlang.org/dart_async/Stream.html">API Streams</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
