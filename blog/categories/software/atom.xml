<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: software | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/software/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2017-12-13T22:06:56+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The nature of software developent]]></title>
    <link href="http://rchavarria.github.io/blog/2017/03/05/the-nature-of-software-developent/"/>
    <updated>2017-03-05T16:06:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/03/05/the-nature-of-software-developent</id>
    <content type="html"><![CDATA[<h5>de Ron Jeffries</h5>

<p><img class="left" src="https://imagery.pragprog.com/products/363/rjnsd.jpg?1409862136" width="260" height="392" title="The nature of software development" ></p>

<h2>Por qué lo he leído</h2>

<p>Como casi todos los libros, por recomendación. Ví que lo recomendaba
<a href="https://carlosbuenosvinos.com/">Carlos Buenosvinos</a>, y no pude resistirme. Además, el autor es una leyenda
viva del desarrollo del software y del manifiesto Agile, así que tenía que ser
un libro de aúpa.</p>

<p>¿Un libro que trata sobre la <strong>naturaleza</strong> de la profesión a la que te
dedicas? A leerlo casi, casi, sin pensarlo.</p>

<!-- more -->


<h2>Qué esperaba y qué encontré</h2>

<p>Esperaba un libro largo, pesado. Tipo como una biblia o enciclopedia. Un
compendio de mejores prácticas, de leyes no escritas, los 101 mandamientos del
desarrollo del sofware.</p>

<p>De eso nada. <a href="https://pragprog.com/book/rjnsd/the-nature-of-software-development">The nature of sofware development</a> es un libro que se lee con una
facilidad pasmosa. Es increíble como <a href="http://ronjeffries.com/">Ron Jeffries</a> simplifica hasta los
conceptos más complejos de explicar. Hace que el proceso de desarrollo que él
explica parezca el único que debe existir, el natural, al que se debería tender
si dejáramos que las fuerzas actuaran solas (tipo naturaleza, no sé si se me
entiende la metáfora).</p>

<p>Es un libro relativamente corto, con muchas (y muy buenas) ilustraciones.
Dividido en capìtulos digeribles muy fácilmente. Un lenguaje llano, sencillo,
pero preciso.</p>

<h2>Conclusiones</h2>

<p>Por supuesto que es un libro donde se describe muchas mejores prácticas. A mí
me parece que describe el ideal de cómo se debería desarrollar un proyecto
software. Casi tan bueno, que me parece un sueño.</p>

<p>Es un libro que recomendaría leer a todo aquel que su trabajo esté relacionado
con cualquier fase en el desarrollo del software: diseño, programador, dueño de
producto,...</p>

<h2>Qué he aprendido</h2>

<blockquote><p>Las cosas van mejor si cada funcionalidad, también llamada <em>historia</em>, sólo
tardamos <strong>dos o tres</strong> días en implementarla.</p></blockquote>

<p>Coincido totalmente con esa visión. La sufro cada día. Si algo dentro del
equipo nos lleva más de 2/3 días, comenzamos a perder el foco, empiezan a
aparecer pequeñas tareas (pues ya que...) que nos hacen desviarnos del objetivo
inicial. Y al final, se hace muy difícil dar una historia por zanjada. Si
dividimos el trabajo en pequeñas historias entregables y que podamos
materializar en menos de 3 días, todo va mejor la mayor parte del tiempo.</p>

<blockquote><p>Para obtener la mejor calidad, un progreso continuado y una gran
predictabilidad, los tests y las refactorizaciones son la mejor forma
conocida de trabajar.</p></blockquote>

<!-- split -->


<blockquote><p>Necesitamos un progreso constante, regular e ininterrumpido. Para mantener un
progreso ininterrumpido, necesitamos un diseño claro y limpio todo el tiempo.
Y para conseguirlo, necesitamos refactorizar nuestro código.</p></blockquote>

<p>Dos grandes pilares del desarrollo: <strong>tests</strong> y <strong>refactorizaciones</strong></p>

<h2>Frases que quiero recordar</h2>

<blockquote><p>Valor es lo que uno quiere</p></blockquote>

<!-- split -->


<blockquote><p>Un experto excelentemente remunerado no debería ser remunerado solamente
porque es un experto. Debería ser excelentemente remunerado por ayudar a
otras personas a que se conviertan en expertos.</p></blockquote>

<!-- split -->


<blockquote><p>El estilo de <em>funcionalidad a funcionalidad</em> incluye un ciclo completo de
desarrollo en cada iteración: requisitos, diseño, codificación y testeo.</p></blockquote>

<!-- split -->


<blockquote><p>Podemos construir todo el diseño primero, o podemos construir cada
funcionalidad completamente de una en una, cada una con su base. Lo que no
podemos hacer es construir toda la base al principio, así como tampoco
podemos construir todas las funcionalidades al principio. Es de lejos mucho
más seguro construir una versión simple pero funcional de cada funcionalidad
primero.</p></blockquote>

<!-- split -->


<blockquote><p>Trabajamos incrementalmente. Necesitamos un buen diseño relativamente pronto,
pero solo necesitamos un <strong>pequeño</strong> buen diseño.</p></blockquote>

<!-- split -->


<blockquote><p>Toma cada posible idea como una posible forma de comenzar a hacer cosas
durante un tiempo. Luego, haz tuyo el proceso, y construye tus propias ideas.
¡Pero mantenlo simple!</p></blockquote>

<!-- split -->


<blockquote><p>Nuestro trabajo no es ceñirnos al plan, es ir corrigiendo el curso para
obtener el mejor resultado, no llegar a algún punto fijo.</p></blockquote>

<!-- split -->


<blockquote><p>Lo hacemos mejor no cuando predecimos cuándo habremos terminado, si no cuando
elegimos cuándo está terminado (pero es que debemos mantenernos siempre en un
estado de <em>terminado</em> de forma constante)</p></blockquote>

<!-- split -->


<blockquote><p>La palabra refactorizar se refiere al proceso simple y regular de mantener el
código limpio. Cuando la carretera se convierte en un camino intrincado, lo
enderezamos refactorizando el código.</p></blockquote>

<h2>Referencias</h2>

<ul>
<li><a href="https://vimeo.com/79106557">The fundamental theorem of Agile Software Development</a>, de J.B.Rainsberger</li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/the-nature-of-software-development-by-ron-jeffries.markdown">Notas sobre The nature of Software development</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[microtip] git: ramas locales y remotas]]></title>
    <link href="http://rchavarria.github.io/blog/2012/11/19/microtip-git-ramas-locales-y-remotas/"/>
    <updated>2012-11-19T11:19:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2012/11/19/microtip-git-ramas-locales-y-remotas</id>
    <content type="html"><![CDATA[<p><a href="http://es.wikipedia.org/wiki/Git"><strong>git</strong></a> es un sistema de control de version distribuido (<a href="http://en.wikipedia.org/wiki/Distributed_version_control_system">DVCS</a> por sus siglas en inglés), y una de sus características que lo hacen más atractivo es su gran rapidez para trabajar con ramas (<em>branches</em>).</p>




<p>En este pequeño post, que he llamado <strong>microtip</strong>, veremos cómo crear una rama, movernos entre ramas, realizar sencillos <em>merge</em> entre ramas y cómo hacer que estos cambios se vean reflejados en un repositorio remoto para poder compartirlo con nuestros compañeros de proyecto.</p>




<!-- more -->




<p>Para comenzar a trabajar en una rama nueva, podemos hacerlo de dos formas:
<ol>
    <li>Crear la rama y movernos a ella</li>
```
git branch nueva_rama
git checkout nueva_rama
```
    <li>Movernos a una rama y crearla en caso de que no exista</li>
```
git checkout -b nueva_rama
```
</ol>
</p>




<p>Ok, ya estamos trabajando en la nueva rama. Ahora podemos añadir ficheros, hacer commit de cambios que hayamos hecho, ...</p>


<p><code>
git add nuevo_fichero.txt
git commit -m &amp;quot;mensaje para el commit&amp;quot;
</code></p>

<p>Una vez tenemos los cambios deseados en nuestra rama, podemos dejarlo así, de forma que será una rama privada, solamente nosotros tendremos acceso a ella, o podremos hacerla pública a través de algún repositorio remoto para que sea accesible por nuestros compañeros:</p>


<p><code>
git push origin new_branch
</code></p>

<p style="font-size:75%;text-align:right;">Nota: este comando supone que <em>origin</em> es un remote válido para git.</p>




<p>Si queremos pasar estos cambios otra rama, por ejemplo, master: primero nos moveremos a esa rama y luego traemos los cambios a esta rama:</p>


<p><code>
git checkout master
git merge development master
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Proyecto maven para javascript]]></title>
    <link href="http://rchavarria.github.io/blog/2012/09/26/proyecto-maven-para-javascript/"/>
    <updated>2012-09-26T09:26:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2012/09/26/proyecto-maven-para-javascript</id>
    <content type="html"><![CDATA[<p>Estoy aprendiendo JavaScript. Creo que es uno de los lenguajes con más futuro, y no sólo por la web (que da de comer a mucha gente), sino por herramientas como <a href="http://phonegap.com/">PhoneGap</a> (que te permite crear aplicaciones para iOS, Android, ...), y también por la llegada del nuevo Windows 8, ya que se pueden desarrollar aplicaciones en JavaScript que acceden al hardware de la máquina donde esté instalado Windows 8.</p>

<p>Empecé aprendiéndolo gracias a <a href="http://www.codecademy.com/">Codecademy</a>, que comenzó el año con unos cursos o clases online, y me llamó mucho la atención la posibilidad de poder ir practicando JavaScript sin tener que instalar nada. Y además, cada semana la herramienta me recordaría que tenía una nueva lección, así no dejaría de practicar.</p>

<!-- more -->


<p>Pero hace poco tropecé con un pequeño problema, y es que quería aportar una solución escrita en JavaScript al desafío de <a href="http://www.solveet.com/exercises/Compresion-RLE/35">Compresión en RLE</a> en <a href="http://www.solveet.com/">Solveet </a>(una plataforma donde la gente publica desafíos de programación y otra gente publica sus propias soluciones, muy recomendable y divertido). El problema era que no tenía instalado nada en mi ordenador que me permitiera hacer <a href="http://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas">TDD </a>(lo prefiero para resolver los desafíos, así practico doble: el desafío y la práctica TDD).</p>

<p>Una herramienta que me encanta para gestionar el ciclo de vida de mis proyectos es <a href="maven.apache.org">maven</a>, así que me decidí a buscar algo que me permitiera escribir JavaScript y luego ejecutarlo con comandos de maven.</p>

<p>Y tuve la suerte de encontrar un post de <a href="http://blog.akquinet.de/">akquinet </a>donde explica <a href="http://blog.akquinet.de/2011/02/11/mavenizing-javascript-projects/">cómo crear un proyecto maven para JavaScript</a>. La verdad es que es realmente sencillo porque akquinet se ha currado un archetype para maven que te crea un esqueleto de proyecto para que escribas directamente JavaScript. Simplemente con este comando para ejecutar maven:</p>

<p>[sourcecode language="bash"]
mvn archetype:generate \
  -DarchetypeArtifactId=javascript-quickstart \
  -DarchetypeGroupId=de.akquinet.javascript.archetypes \
  -DarchetypeVersion=1.0.0 \
  -DgroupId=<enter your groupId> \
  -DartifactId=<enter your artifactId>
[/sourcecode]</p>

<p>Con el proyecto creado a partir del archetype de akquinet podrás:</p>

<ul>
    <li>Ejecutar tus tests JavaScript con <a href="http://pivotal.github.com/jasmine/">Jasmine</a></li>
    <li>Comprimir los ficheros .js y .css de tu proyecto</li>
    <li>Generar la documentación con <a href="www.jslint.com/">Jslint</a> y <a href="http://code.google.com/p/jsdoc-toolkit/">Jsdoc</a></li>
</ul>


<p>Además, al ser un proyecto maven, es muy fácil que lo integres en un servidor de <a href="http://es.wikipedia.org/wiki/Integraci%C3%B3n_continua">Integración Contínua</a> como <a href="http://hudson.dev.java.net/">Hudson</a>.</p>

<p>Si quieres, puedes ver la solución que aporté en Solveet. El desafío es muy sencillo, y hay muy poco código JavaScript: <a href="http://www.solveet.com/exercises/Compresion-RLE/35/solution-846">Compresión RLE en JavaScript</a>, el <a href="https://github.com/rchavarria/solveet-problems/tree/master/rle-compression-javascript">código completo con los tests</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming pearls]]></title>
    <link href="http://rchavarria.github.io/blog/2012/05/25/programming-pearls/"/>
    <updated>2012-05-25T05:25:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2012/05/25/programming-pearls</id>
    <content type="html"><![CDATA[<h4>Programmig pearls</h4>




<h5>de Jon Bentley</h5>




<h2>Por qué lo he leído</h2>


<p><img class="right" src="http://ecx.images-amazon.com/images/I/41ETT7KQRRL.<em>SL500_AA300</em>.jpg" width="300" height="300" title="Programming pearls" ></p>

<p>Cuando leí <a href="http://rchavarria.wordpress.com/2011/03/24/apprenticeship-patterns/" title="Apprenticeship patterns">Apprenticeship patterns</a>, me gustó mucho su filosofía, sus consejos para ser un mejor profesional en cuanto a desarrollar software se refiere. Unos de los consejos es: <a href="http://ofps.oreilly.com/titles/9780596518387/construct_your_curriculum.html#study_the_classics" title="Study the classics">estudia a los clásicos</a>. Así que cuando supe de la existencia de este libro, me propuse leerlo, porque me dió la impresión de que era uno de <em>los clásicos</em>.</p>

<!-- more -->




<h2>Qué esperaba</h2>


<p>Me esperaba una recopilación de errores de programación de esos que nunca pasan de moda. De los errores que los
desarrolladores menos experimentados, por no escuchar los consejos de profesionales más expertos, cometen. Nos ha pasado a todos, como si fuéramos niños que, por no hacer caso a sus padres, cometen los mismos errores que ellos.</p>

<h2>Qué encontré</h2>


<p>Qué equivocado estaba, pero no importa.
En lugar de eso, encontré una colección, pero no de errores típicos, si no de problemas típicos. Y también encontré soluciones a ellos, y optimizaciones.
Por lo "antiguo" del texto, estos problemas pueden parecer pasados de moda. Pero nada de eso. Son problemas algorítmicos, que se estudian en la universidad. Y están repletos de matemáticas.</p>

<h2>Conclusiones</h2>


<p>Al principio del libro no estaba muy convencido de haber acertado, pero poco a poco comprendí la esencia del mismo.
Los problemas descritos son básicos en el desarrollo de software. No son problemas de una herramienta o un lenguaje de programación. Por eso mismo, por mucho tiempo que pase, este libro seguirá estando vigente de una u otra forma, y por eso mismo, después de leerlo sigo pensando que acerté, que quería leer un clásico y lo he leido.</p>

<h2>Pasajes que quiero recordar de este libro</h2>


<blockquote>Los buenos programadores son algo vagos: ante un problema, se sientan y esperan a tener una buena idea antes de correr a implementar lo primero que se les viene a la cabeza.
</blockquote>


<blockquote>Cuando un programador intenta convencer a otro de que el código es correcto, la mejor herramienta es un test.</blockquote>


<blockquote>Mantener el código simple, es generalmente un aspecto clave en la corrección del código.</blockquote>


<blockquote>Algunas técnicas de diseño de algoritmos: guardar el estado para evitar recomputación, preprocesar información en estructuras de datos, divide y vencerás, escaneado, acumular resultados, conocer el límite inferior.</blockquote>


<blockquote>El principio más importante sobre optimización es que no debería hacerse muy a menudo.</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactorizacion: inserta un m&eacute;todo ajeno]]></title>
    <link href="http://rchavarria.github.io/blog/2012/02/14/refactorizacion-inserta-un-metodo-ajeno/"/>
    <updated>2012-02-14T02:14:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2012/02/14/refactorizacion-inserta-un-metodo-ajeno</id>
    <content type="html"><![CDATA[<p>En este post voy a describir una de las muchas refactorizaciones que describe Martin Fowler en su libro <a href="http://martinfowler.com/refactoring/">Refactoring: improving the design of existing code</a> (<a href="http://rchavarria.github.io/blog/2012/01/25/refactoring-improving-the-design-of-existing-code/">mis impresiones sobre el libro</a>). He escogido la refactorización de <a href="http://martinfowler.com/refactoring/catalog/introduceForeignMethod.html">insertar método ajeno</a> por ser una de las que, aun siendo sencilla, no había sido consciente de utilizarla hasta leer el libro.</p>

<!-- more -->




<h3>Descripción</h3>


<p>La refactorización consiste en crear un método en una clase (clase cliente) cuando en realidad ese método debería pertenecer a otra clase (clase servidor). De ahí el nombre de método ajeno (traducción libre de foreign method)</p>

<h3>Por qué es necesaria</h3>


<p>Esta refactorización aparece ante la necesidad de crear un método en la clase servidor, pero es imposible cambiar el código fuente de la misma.</p>

<h3>Cómo llevar a cabo la refactorización</h3>


<p>Lo primero es crear un método en la clase cliente que haga lo que necesitamos que haga la clase servidora. El primer parámetro de este método será un objeto de la clase servidora. En caso de necesitar algún parámetro más, éstos serían los parámetros en caso de que el método existiera en la clase servidora.</p>

<p>El objetivo de crear un nuevo método es el de poder reutilizar el código y evitar duplicidades. De esta forma podremos retutilizar el código del nuevo método, y en el caso de que en un futuro podamos cambiar el código fuente de la clase servidora, ese cambio será menos doloroso.</p>

<p>Martin Fowler aconseja comentar el método como <code>método ajeno</code>, para poder encontrar métodos candiatos a mover a sus clases correspondientes. En mi opinión, no creo que esto ayude demasiado a la hora de mantener el código, pero tampoco lo veo perjudicial. Así que aquí, que cada cual siga sus preferencias.</p>

<h3>Código de ejemplo</h3>


<p>Partimos del siguiente código de ejemplo, es un ejemplo muy sencillo pero espero que ilustre el caso lo suficientemente bien como para comprender la refactorización:</p>

<p>```
// ...
Date nextDay = new Date(previousDay.getYear(),</p>

<pre><code>                    previousDay.getMonth(), 
                    previousDay.getDate() + 1);
</code></pre>

<p>```</p>

<p>Como vemos, nuestro código necesita varios datos de la clase servidora (Date, objeto previousDay). Si la clase Date tuviera un método nextDay, o similar, nuestro código quedaría realmente simple. Pero no lo tiene, y lo pero de todo es que tampoco tenemos la posibilidad de modificar Date para incorporarle ese método.</p>

<p>Está bien, creemos pues nuestro método ajeno:</p>

<p>```
Date nextDay = nextDay(previousDay);
// ...
// foreign method
private Date nextDay(Date aDay) {</p>

<pre><code>return new Date(aDay.getYear(), 
                aDay.getMonth(), 
                aDay.getDate() + 1);
</code></pre>

<p>}
```</p>

<p>Sí, el código es prácticamente el mismo, pero ahora tenemos un método, la principal forma de reutilizar código. En el caso de poder modificar la clase Date, sería trivial mover este método a esa clase. De hecho, <a href="http://martinfowler.com/refactoring/catalog/moveMethod.html">mover método</a>, es una de las primeras refactorizaciones (y más básicas) explicadas por Martin Fowler en <a href="http://martinfowler.com/refactoring/">Refactoring</a>.</p>
]]></content>
  </entry>
  
</feed>
