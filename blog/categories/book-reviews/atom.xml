<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: book reviews | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/book-reviews/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2018-02-18T10:39:45+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Practical Object-Oriented Design in Ruby]]></title>
    <link href="http://rchavarria.github.io/blog/2018/01/17/practical-object-oriented-design-in-ruby/"/>
    <updated>2018-01-17T22:03:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2018/01/17/practical-object-oriented-design-in-ruby</id>
    <content type="html"><![CDATA[<h5>de Sandi Metz</h5>

<p><img class="left" src="/images/2018/poodr.jpg" width="250" height="323"></p>

<h3>Por qué lo he leído</h3>

<p>Éste es un libro que lo recomienda mucha gente cuando se habla de <em>programación
orientada a objetos</em>, es muy mencionado en conversaciones por twitter y el
mundo online. Pero la guinda del pastel vino cuando ví que lo recomendaba
<a href="https://twitter.com/carlosble">Carlos Blé</a> en su blog. Entonces supe que era una lectura obligada.</p>

<!-- more -->


<h3>De qué trata el libro</h3>

<p>Va sobre programación orientada a objetos. Normalmente, al hablar de POO, no se
avanza mucho más allá de herencia y polimorfismo. Sandi va muchos pasos más
allá. Explica la POO desde un punto de vista un poco diferente, donde los
objetos no son el centro del paradigma, si no los mensajes que se intercambian
entre ellos.</p>

<p>Por supuesto, el libro también habla de herencia, de cuándo usarla y cuándo no.
Habla de composición, comparándola con la herencia. Y habla de otras formas de
reutilizar o compartir el código.</p>

<p>Por último, habla sobre cómo gestionar los tests de nuestra aplicación
manteniendo unos costes de desarrollo bajo control.</p>

<h3>Conclusiones y valoración</h3>

<p>Es curioso que para describir el paradigma de la programación orientada a
objetos no se centre en objetos, si no en los mensajes que deben pasarse entre
ellos. Es un cambio de punto de vista, y me gustaría poder interiorizarlo
fácilmente, pero no me resulta así. Es un esfuerzo que debo hacer y que seguro
que merecerá la pena.</p>

<p>Aunque centrado en Ruby, describe otras formas de reutilizar código aparte de
la herencia y la composición. Les llama módulos, o roles. En otros lenguajes
existen conceptos similares, como los <em>traits</em> en PHP o los <em>mixins</em> en
JavaScript. No creo que se puedan aplicar a todos los lenguajes de
programación, pero si a la mayoría de los lenguajes dinámicos.</p>

<p>En cuanto a la valoración, coincido con muchísima gente: este libro puede ser
un antes y un después en la comprensión de la Programación Orientada a
Objectos, sobre todo por el punto de vista tan diferente a la hora de
entenderla. Envío de mensajes, envío de mensajes, envío de mensajes,...</p>

<h3>Qué he aprendido</h3>

<p>Impresionante ver cómo refactoriza una herencia a una composición de objetos:
engloba una colección de objetos en una nueva clase, crea una factoría que crea
cada una de las partes, simplifica las partes como dadas de configuación. De
esta forma, añadir un nuevo tipo no requiere una nueva clase, solamente nueva
configuración</p>

<p>Diseñar basado en mensajes crea aplicaciones más flexibles que diseñar pensando
en objetos. En lugar de preguntarte: tengo un objeto ¿qué debería hacer?,
deberías preguntarte tengo un mensaje, ¿a quién se lo envío? No hay que
centrarse en los objetos de dominio, si no en los mensajes que se pasan entre
ellos.</p>

<p>Eligiendo relaciones (herencia, roles/<em>duck typing</em>, composición)</p>

<ol>
<li>Herencia para relaciones <em>es-un</em> (is-a). Especialmente si la jerarquía es
estrecha y tiene pocos niveles</li>
<li>Role/duck type para relaciones <em>se-comporta-como</em> (behaves-like-a). Donde
varios objetos no relacionados se quieren comportar del mismo modo</li>
<li>Composición para relaciones <em>tiene-un</em> (has-a). Un objeto tiene varias
partes pero es más que la suma de ellas, si no sería una colección y ya está</li>
</ol>


<p>Para obtener el máximo valor de los tests, hay que tener el mínimo de ellos.
Para ello, hay que testear cada cosa una sola vez, y en el lugar apropiado.</p>

<ol>
<li>Mensajes entrantes tipo <em>query</em> hay que testear el <strong>estado</strong> que devuelven</li>
<li>Mensajes salientes tipo <em>command</em>, hay que testear que son llamados, cuantas
veces y con qué parámetros</li>
<li>Mensajes salientes tipo <em>query</em>, no se testean (ya los testearán los tests
de otro objeto)</li>
</ol>


<h3>Frases que me gustaría recordar</h3>

<blockquote><p>Siempre existe una tension entre mejorarlo ahora o mejorarlo después. Un buen
diseñador sabe minimizar los costes tomando decisiones valorando lo que sabe
ahora y lo que sabrá en el futuro, porque nunca sabrás menos de lo que sabes
hoy</p></blockquote>

<!-- more -->


<blockquote><p>Gestiona la dirección de las dependencias: depende de cosas que cambien menos
frecuentemente que tú. Para conocer las dependencias más interesantes nos
fijamos en 3 aspectos: probabilidad del cambio, nivel de abstracción y número
de dependencias (sobretodo de la 1ª y 3ª)</p></blockquote>

<!-- more -->


<blockquote><p>Las cosas que una clase conoce conforman su <strong>contexto</strong>, lo cual tiene un
efecto directo en lo fácil o difícil que es reusar (y por tanto testear) esa
clase</p></blockquote>

<!-- more -->


<blockquote><p>Para que una herencia funcione, debe de haber una relación de
generalización-especialización, donde la especialización sea todo lo general
y algo más</p></blockquote>

<!-- more -->


<blockquote><p>La regla general de refactorizar a una herencia es colocar el código de tal
forma que haya que promocionar abstracciones a las superclases, en lugar de
<em>rebajar</em> concrecciones a las subclases</p></blockquote>

<!-- more -->


<blockquote><p>Si hay código que pregunta por el tipo de un objeto para enviar un mensaje u
otro, estamos necesitando <em>duck typing</em>, una abstracción. Cuando además del
interfaz (<em>duck type</em>) necesitamos compartir comportamiento, necesitamos un
<em>role</em> (módulo, trait, mixing,...)</p></blockquote>

<!-- more -->


<blockquote><p>La composición es otra forma de organizar el código donde cada parte es más
independiente, pero no tenemos delegacion automática de mensajes, si no que
hay que hacerlo de forma explícita</p></blockquote>

<!-- more -->


<blockquote><p>Código creado con composición es <em>transparente</em> (T de <em>true</em>), suelen ser
clases pequeñas con una única responsabilidad y suele ser fácil entenderlas.
Son <em>usables</em> (U de <em>true</em>) porque son pequeños y enfocados. Son <em>razonables</em>
(R de true) porque se pueden extender sin modificar</p></blockquote>

<h3>Recursos relacionados</h3>

<ul>
<li>El resto de <a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/practical-object-oriented-design-ruby-by-sandi-metz.markdown">notas sobre POODR</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[99 bottles of OOP]]></title>
    <link href="http://rchavarria.github.io/blog/2017/10/19/99-bottles-oop/"/>
    <updated>2017-10-19T22:06:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/10/19/99-bottles-oop</id>
    <content type="html"><![CDATA[<h5>de Sandi Metz y Katrina Owen</h5>

<p><img class="left" src="/images/2017/99-bottles-of-oop.jpg" width="250" height="323"></p>

<h2>Por qué lo he leído</h2>

<p>No conozco personalmete a ninguna de las 2 autoras, pero soy un fan de Sandi y
colaboro en un proyecto open source de Katrina, ¿cómo no iba a leer
<a href="https://www.sandimetz.com/99bottles">99 bottles of OOP</a>?</p>

<p>Ya había leído con anterioridad el libro de Sandi, <a href="http://www.poodr.com/">Programming OODR</a> y me
gustó muchísimo, así que este libro prometía. También había visto alguna charla
de Katrina sobre refactorizaciones, y me asombraron muchísimo, por su claridad
y por su calidad.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>Considero que ambas autoras son un referente en el mundo del desarrollo de
software, por lo que esperaba que el libro me enseñara nuevos temas o ideas
sobre los que aprender y profundizar.</p>

<p>Según había escuchado en algunas entrevistas a las autoras, el libro basa sus
<em>enseñanzas</em> en un caso real, solucionando un problema sencillo, ideal para
realizar en katas, por lo que esperaba que todos los conceptos serían fáciles
(o al menos más fáciles) de entender ya que estarían ilustrados con código real
y ejecutable (mira, como si fueran tests).</p>

<h2>Qué encontre</h2>

<p>Encontré la historia de una refactorización. Sandi y Katrina exponen primero
varias formas de resolver un problema, en principio sencillo, y después van
desgranando una de ellas. Poco a poco, cambio a cambio, refactorización a
refactorización, van cambiando el código hacia una solución muy pulida.</p>

<p>Es impresionante ver cómo van justificando cada cambio. Es como leer tus
propios pensamientos, pero un paso más allá. Muchos de los cambios que proponen
parecen de perogrullo, pero muy pocas veces me he parado a pensar por qué me
parecen así. Es como si racionalizaran el instinto del programador.</p>

<h2>Conclusiones</h2>

<p>Es impresionante cómo va describiendo la refactorización línea a línea. Elimina
multitud de code smells, muchas veces de línea en línea, apoyándose en tests.
Es una gozada ver cómo va quedando el código</p>

<p>(...) es un acto de bondad hacia el lector de tu código. El código que revela
su intención está construido en base a la acumulación de actos así de
intencionados. Programa intencionadamente (escribe un <code>case</code> en lugar de un
<code>if</code> para indicar que las condiciones están relacionadas). <strong>Es una pasada como
el libro racionaliza estas decisiones y las explica</strong></p>

<p>Resulta interesante cómo nombra las cosas, conceptos, clases, variables,...
Nombrado es una de las cosas más difíciles en Computer Science.</p>

<h2>Qué he aprendido</h2>

<p>Una forma de ser mejor identificando olores en el código es practicar
describiendo las características del código, tomando nota de las cosas que te
llaman la atención: incluye cualquier patrón que veas, y cosas que te gustan,
odias o que simplemente no entiendes.</p>

<p>Si el código no está abierto a modificaciones y no sabes por dónde empezar...
empieza eliminando olores en el código. No sabes cómo hacer que el código esté
abierto a modificaciones, así que empiezas a eliminar olores, con la esperanz
de encontrarlo por el camino</p>

<p>Los programadores habilidosos hacen lo correcto cuando intuyen la verdad.
Cuando no la intuyen, se embarcan en experimentos cuidadosos, precisos,
reproducibles y reversibles.</p>

<p>Los atajos demasiado inteligentes son una falsa economía. Invierte en código
que diga la verdad. Simplemente escríbelo. Di no a los atajos, di no a las
chapuzas y ñapas.</p>

<p>Unos consejos que podrían resumir el libro completo serían: busca la
simplicidad, no crees abstracciones demasiado pronto, enfócate en los olores
del código, anda en pasos pequeños, sigue las <em>Flocking rules</em>, refactoriza
siempre en verde, arregla los problemas sencillos primero, trabaja
horizontalmente (cambios horizontales, nunca verticales), buscar puntos de
estabilidad, sé disciplinado, no persigas las cosas brillantes/famosas/de moda</p>

<h2>Frases que me gustaría recordar</h2>

<blockquote><p>Escribir código es el proceso de encontrar el camino hasta el siguiente punto
estable, no el punto final en sí mismo. No es el resultado final, si no el
camino.</p></blockquote>

<!-- more -->


<blockquote><p>El código como el método <code>pluralize</code> (que devuelve <code>bottle</code> o <code>bottles</code>
dependiendo de un número) se escribe cuando los programadores se llevan el
principio DRY al extremo. Cuando te encuentres en una situación como esta,
hazte las siguientes preguntas. Estas mismas preguntas también te ayudarán a
saber si tu código es bueno o costoso.</p></blockquote>

<ol>
<li>El cambio que voy a hacer, ¿hace el código más difícil de entender? Cuando
las abstraciones son las correctas, el código es fácil de entender.</li>
<li>¿Cuál es el coste futuro de no hacer nada ahora? Si no hacer nada no
incrementa los costes, retrasa los cambios.</li>
<li>¿Cuando llegará ese momento?, o ¿cuánto tardaré en obtener más información?
Tolera pacientemente la duplicación si haciéndolo te ayuda a descubrir la
abstracción correcta.</li>
</ol>


<!-- more -->


<blockquote><p>Kent Beck describe diferentes formas de hacer que tus tests pasen. 3 de sus
<em>Green Bar Patterns</em> son:</p></blockquote>

<ol>
<li>Fake It ("Til You Make It"): este estilo de TDD puede parecer extraño y
tedioso, pero con práctica puede llegar a ser natural y rápido</li>
<li>Obvious Implementation: cuidado con ir directamente a la solucion obvia, te
puede llevar por el camino equivocado. Desarrollar el hábito de escribir
solamente el código suficiente para hacer que el test pase te fuerza a escribir
mejores tests.</li>
<li>Triangulate: dirigir las abstracciones conservativamente con los tests. La
triangulación requiere escribir varios test de una sola vez, lo que
significa que tendrás varios test fallando simultáneamente. La idea es escribir
el código necesario para hacer que todos esos tests pasen de forma simultánea.</li>
</ol>


<!-- more -->


<blockquote><p>Hacer que el código existente esté abierto a nuevos requisitos requiere
normalmente de identificar y nombrar abstracciones. Las <em>Flocking Rules</em> se
centran en hacer que las diferencias parezcan similitudes, y por eso son una
herramienta muy útil para descubrir abstracciones. Las Flocking Rules
seleccionan las cosas más parecidas, encuentran la menor diferencia entre ellas
y hacen el cambio más simple para eliminar esa diferencia (evalúa el código,
evalúa y ejecuta, evalúa y usa el código, evalúa, y finalmente borra el código
no usado)</p></blockquote>

<!-- more -->


<blockquote><p>Cuando estés sufriendo por encontrar un buen nombre pero sólo tienes unas
cuantas ocurrencias para guiarte, puede ser de ayuda imaginarte otras cosas que
podrían encajar en la misma catergoría, y luego construir una tabla con los
conceptos.</p></blockquote>

<!-- more -->


<blockquote><p>El Principio de Sustitución de Liskov también aplica a los tipos dinámicos (o
<em>duck types</em>). Las violaciones de Liskov fuerzan a los que envían mensajes a
tener conocimiento sobre varios tipos devueltos, y tratar con ellos de forma
distinta o convertirlos en algo consistente.</p></blockquote>

<!-- more -->


<blockquote><p>No todos los condicionales son malos en la Programación Orientada a Objectos,
hay un lugar para ellos. Algún objeto, en algún lugar, debe elegir qué objetos
crear para las composiciones, y eso normalmente involucra condicionales.</p></blockquote>

<!-- more -->


<blockquote><p>Tener un <strong>data clump</strong> significa normalmente que estás necesitando un
concepto. Cuando esta acumulación se envía como un conjunto de parámetros, el
método que recibe el <em>clump</em> se puede ver inundado con facilidad con lógica
para gestionarlo. Alguna de esta lógica inevitablemente acabará duplicándose en
distintos lugares. Si dos cosas aparecen siempre juntas, es una señal de que
esa pareja representa un concepto más profundo y que necesitamos darle un
nombre.</p></blockquote>

<!-- more -->


<blockquote><p>Los programadores añaden líneas en blanco para acentuar cambios en la temática.
La presencia de múltiples temas sugiere la existencia de múltiples
responsabilidades, lo que hace el código más difícil de entender y leer,
mientras que hace más fácil causar daños cuando haya que hacer algún cambio.</p></blockquote>

<!-- more -->


<blockquote><p>El truco para avanzar usando cambios de una sola línea es alterar temporalmente
la factoría para tolerar varios tipos de entrada. A veces, a la hora de cambiar
condicionnales con polimorfismo, hay momentos en los que algún código debe
soportar varios tipos, hasta que todo el código está adaptado. Especialemente,
si vamos haciendo cambios de una sóla línea</p></blockquote>

<!-- more -->


<blockquote><p>Corregir violaciones de Liskov es importante, porque en lenguajes orientados a
objetos (sobretodo los tipados dinámicamente), se basan en la confianza
explícita en los contratos implícitos entre los objetos. Se trabaja muy bien
con objetos de confianza, porque siempre se comportan como se espera de ellos.
Los objetos que a veces fallan en responder a un mensaje que les envías, o que
ocasionalmente devuelven algo que no esperas, son un dolor, y requieren que los
objetos que les llamen deban conocer demasiadas cosas.</p></blockquote>

<h2>Recursos relacionados</h2>

<ul>
<li>El libro en sí: <a href="https://www.sandimetz.com/99bottles">99 bottles of OOP</a></li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/99-bottles-by-sandi-katrina.notes.markdown">Notas sobre 99 bottles of OOP</a></li>
<li>Nuevo libro, <a href="foo/bar/bar/foo.html">Refactoring to patterns</a>, de Joshua Kerievsky, donde habla de
<em>Gradual Cutover Refactoring</em></li>
<li>Las autoras: <a href="https://www.sandimetz.com/">Sandi Metz</a> y <a href="http://www.kytrinyx.com/">Katrina Owen</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ready player one]]></title>
    <link href="http://rchavarria.github.io/blog/2017/03/26/ready-player-one/"/>
    <updated>2017-03-26T20:52:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/03/26/ready-player-one</id>
    <content type="html"><![CDATA[<h5>de Ernest Cline</h5>

<h2>Por qué lo he leído</h2>

<p><img class="left" src="/images/2017/ready-player-one.jpg"></p>

<p>La primera vez que leí una recomendación sobre el libro fue en <a href="http://www.microsiervos.com/archivo/libros/ready-player-one.html">Microsiervos</a>.
Comentaban que era un libro de ciencia ficción relacionado con los videojuegos
con muchísimas referencias a videojuegos de los años 80.</p>

<p>Al principio no estaba seguro si me gustaría o no. Puede que conozca unos
cuantos juegos de los 80, pero por aquellos años yo era aún un niño, así que no
estaba seguro de que fuera a entender todas esas referencias.</p>

<p>Pero más adelante, los de Microsiervos lo volvieron a recomendar, y un poco
después escuché otra recomendación por parte de Kevin Kelly en el
<a href="http://fourhourworkweek.com/2016/06/05/kevin-kelly-ai-virtual-reality-and-the-inevitable">podcast de Tim Ferris</a>. Uno no se puede resistir a tantas recomendaciones.</p>

<!-- more -->


<h2>De qué trata el libro</h2>

<p>La historia que cuenta el libro está ubicada en un tiempo futuro. Un tiempo
donde todo gira alrededor de internet. La vida digital tiene más peso que la
vida <em>analógica</em>. Pero no todo el mundo se puede permitir las mejores
conexiones a internet.</p>

<p>El protagonista es un estudiante que no tiene una vida fácil. Pero le apasionan
los videojuegos.</p>

<p>Un creador de videojuegos ha creado el mejor videojuego de todos los tiempos.
Es un juego de realidad virtual donde cada jugador está representado por un
avatar y la acción se desarrolla en un mundo virtual. Ese mundo tiene multitud
de escenarios, planetas, ciudades y edificios, los avatares se reúnen, chatean
o hacen videoconferencias. Vamos, todo lo que se puede hacer online, se hace a
través del videojuego. El hecho es que el creador del juego muere, pero antes
de morir organiza un concurso dentro del videojuego, y aquel que gane el
concurso obtendrá un premio que le cambiará la vida.</p>

<p>El concurso trata de encontrar tesoros, de buscar pistas, de superar
pruebas,... Todos ellos referenciando a juegos de la juventud del creador de
juegos, que resulta que son juegos reales de los años 80 y 90. Un jugador
importante de este concurso, es nuestro protagonista, que por más suerte que
otra cosa, es quien supera la primera prueba, lo que desencadena una carrera
frenética por conseguir el premio.</p>

<h2>Conclusiones y valoración</h2>

<p>El libro es una pasada. La historia es sencilla, a veces predecible, pero tiene
unos cuantos giros inesperados que te hacen disfrutar. La trama no es
complicada para nada de seguir. Aún así, hace infinitos guiños a la historia de
los videojuegos. Personalmente, no he entendido todos de ellos, pero si has
jugado a algún videojuego en tu vida, seguro que sentirás muchas conexiones.</p>

<p>También resulta muy interesante para alguien muy relacionado con la tecnología,
como yo, pues el autor describe hardware y software que podrían ser realidad
hoy en día, pero quizá no están muy extendidos entre la gente o es una
tecnología un poco verde todavía, pero puede que sean realidad dentro de pocos
años.</p>

<p>Si eres un apasionado de los videojuegos (aunque no hayas conocido los inicios
de ellos) o si eres un apasionado de la tecnología, estoy seguro de que este
libro te encantará y disfrutarás leyéndolo. Y si no te apetece leer, puedes
esperar a la película (prevista para marzo de 2018, según <a href="http://www.imdb.com/title/tt1677720/?ref_=nv_sr_1">IMDB</a>).</p>

<h2>Notas tomadas</h2>

<p>Simplemente, tomé esta nota:</p>

<blockquote><p>(Hablando sobre comecocos) Permitía vencer a un rival controlado por
ordenador. En un juego como ese, un jugador humano con talento siempre podía
ganar a la máquina, porque el software no era capaz de improvisar. O bien
reaccionaba aleatoriamente, o en un número limitado de formas
predeterminadas, basadas en una cifra finita de condiciones programadas con
antelación. Ese era un axioma de los videojuegos, y seguiría siéndolo hasta
que los seres humanos inventen la verdadera inteligencia artificial.</p></blockquote>

<p>¿Estaremos ya cerca de ese <em>final</em>? Espero que no. Los videojuegos perderán su
gracia.</p>

<h2>Referencias</h2>

<ul>
<li><a href="http://www.amazon.es/gp/product/B00UVAREXK/">Ready player one</a> en Amazon</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The nature of software developent]]></title>
    <link href="http://rchavarria.github.io/blog/2017/03/05/the-nature-of-software-developent/"/>
    <updated>2017-03-05T16:06:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/03/05/the-nature-of-software-developent</id>
    <content type="html"><![CDATA[<h5>de Ron Jeffries</h5>

<p><img class="left" src="https://imagery.pragprog.com/products/363/rjnsd.jpg?1409862136" width="260" height="392" title="The nature of software development" ></p>

<h2>Por qué lo he leído</h2>

<p>Como casi todos los libros, por recomendación. Ví que lo recomendaba
<a href="https://carlosbuenosvinos.com/">Carlos Buenosvinos</a>, y no pude resistirme. Además, el autor es una leyenda
viva del desarrollo del software y del manifiesto Agile, así que tenía que ser
un libro de aúpa.</p>

<p>¿Un libro que trata sobre la <strong>naturaleza</strong> de la profesión a la que te
dedicas? A leerlo casi, casi, sin pensarlo.</p>

<!-- more -->


<h2>Qué esperaba y qué encontré</h2>

<p>Esperaba un libro largo, pesado. Tipo como una biblia o enciclopedia. Un
compendio de mejores prácticas, de leyes no escritas, los 101 mandamientos del
desarrollo del sofware.</p>

<p>De eso nada. <a href="https://pragprog.com/book/rjnsd/the-nature-of-software-development">The nature of sofware development</a> es un libro que se lee con una
facilidad pasmosa. Es increíble como <a href="http://ronjeffries.com/">Ron Jeffries</a> simplifica hasta los
conceptos más complejos de explicar. Hace que el proceso de desarrollo que él
explica parezca el único que debe existir, el natural, al que se debería tender
si dejáramos que las fuerzas actuaran solas (tipo naturaleza, no sé si se me
entiende la metáfora).</p>

<p>Es un libro relativamente corto, con muchas (y muy buenas) ilustraciones.
Dividido en capìtulos digeribles muy fácilmente. Un lenguaje llano, sencillo,
pero preciso.</p>

<h2>Conclusiones</h2>

<p>Por supuesto que es un libro donde se describe muchas mejores prácticas. A mí
me parece que describe el ideal de cómo se debería desarrollar un proyecto
software. Casi tan bueno, que me parece un sueño.</p>

<p>Es un libro que recomendaría leer a todo aquel que su trabajo esté relacionado
con cualquier fase en el desarrollo del software: diseño, programador, dueño de
producto,...</p>

<h2>Qué he aprendido</h2>

<blockquote><p>Las cosas van mejor si cada funcionalidad, también llamada <em>historia</em>, sólo
tardamos <strong>dos o tres</strong> días en implementarla.</p></blockquote>

<p>Coincido totalmente con esa visión. La sufro cada día. Si algo dentro del
equipo nos lleva más de 2/3 días, comenzamos a perder el foco, empiezan a
aparecer pequeñas tareas (pues ya que...) que nos hacen desviarnos del objetivo
inicial. Y al final, se hace muy difícil dar una historia por zanjada. Si
dividimos el trabajo en pequeñas historias entregables y que podamos
materializar en menos de 3 días, todo va mejor la mayor parte del tiempo.</p>

<blockquote><p>Para obtener la mejor calidad, un progreso continuado y una gran
predictabilidad, los tests y las refactorizaciones son la mejor forma
conocida de trabajar.</p></blockquote>

<!-- split -->


<blockquote><p>Necesitamos un progreso constante, regular e ininterrumpido. Para mantener un
progreso ininterrumpido, necesitamos un diseño claro y limpio todo el tiempo.
Y para conseguirlo, necesitamos refactorizar nuestro código.</p></blockquote>

<p>Dos grandes pilares del desarrollo: <strong>tests</strong> y <strong>refactorizaciones</strong></p>

<h2>Frases que quiero recordar</h2>

<blockquote><p>Valor es lo que uno quiere</p></blockquote>

<!-- split -->


<blockquote><p>Un experto excelentemente remunerado no debería ser remunerado solamente
porque es un experto. Debería ser excelentemente remunerado por ayudar a
otras personas a que se conviertan en expertos.</p></blockquote>

<!-- split -->


<blockquote><p>El estilo de <em>funcionalidad a funcionalidad</em> incluye un ciclo completo de
desarrollo en cada iteración: requisitos, diseño, codificación y testeo.</p></blockquote>

<!-- split -->


<blockquote><p>Podemos construir todo el diseño primero, o podemos construir cada
funcionalidad completamente de una en una, cada una con su base. Lo que no
podemos hacer es construir toda la base al principio, así como tampoco
podemos construir todas las funcionalidades al principio. Es de lejos mucho
más seguro construir una versión simple pero funcional de cada funcionalidad
primero.</p></blockquote>

<!-- split -->


<blockquote><p>Trabajamos incrementalmente. Necesitamos un buen diseño relativamente pronto,
pero solo necesitamos un <strong>pequeño</strong> buen diseño.</p></blockquote>

<!-- split -->


<blockquote><p>Toma cada posible idea como una posible forma de comenzar a hacer cosas
durante un tiempo. Luego, haz tuyo el proceso, y construye tus propias ideas.
¡Pero mantenlo simple!</p></blockquote>

<!-- split -->


<blockquote><p>Nuestro trabajo no es ceñirnos al plan, es ir corrigiendo el curso para
obtener el mejor resultado, no llegar a algún punto fijo.</p></blockquote>

<!-- split -->


<blockquote><p>Lo hacemos mejor no cuando predecimos cuándo habremos terminado, si no cuando
elegimos cuándo está terminado (pero es que debemos mantenernos siempre en un
estado de <em>terminado</em> de forma constante)</p></blockquote>

<!-- split -->


<blockquote><p>La palabra refactorizar se refiere al proceso simple y regular de mantener el
código limpio. Cuando la carretera se convierte en un camino intrincado, lo
enderezamos refactorizando el código.</p></blockquote>

<h2>Referencias</h2>

<ul>
<li><a href="https://vimeo.com/79106557">The fundamental theorem of Agile Software Development</a>, de J.B.Rainsberger</li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/the-nature-of-software-development-by-ron-jeffries.markdown">Notas sobre The nature of Software development</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Phoenix project]]></title>
    <link href="http://rchavarria.github.io/blog/2017/01/19/the-phoenix-project/"/>
    <updated>2017-01-19T22:23:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/01/19/the-phoenix-project</id>
    <content type="html"><![CDATA[<h5>de Gene Kim</h5>

<p><img class="left" src="/images/2017/phoenix-project.png" width="200" height="246"></p>

<h2>Por qué lo he leído</h2>

<p>Había visto varias referencias al libro por Twitter, blogs y distintos
podcasts. Sabía que el libro era muy similar a <a href="/blog/2013/04/10/la-meta">La meta</a>, de Eliyahu M.
Goldratt, un libro que me gustó bastante.</p>

<p>Así que, tras ver que <a href="http://www.eferro.net/2016/03/some-books-i-recently-read.html">Eduardo Ferro</a> también lo había leído, me decidí a
leerlo yo también.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>No creo que se pudiera esperar tanto como de <a href="/blog/2013/04/10/la-meta">La meta</a>. Ese libro es un recurso
más que recomendable para conocer la <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_las_limitaciones">Teoría de las restricciones</a>. Pero
esperaba algo similar enfocado en el mundo del software.</p>

<p>Esperaba una historia de éxito de una persona o grupo de personas que van
superando problemas, uno tras otro, donde el autor los aproveche para explicar
su punto de vista y dar forma a las teorías que quiere explorar.</p>

<h2>Qué encontre</h2>

<p>Más o menos lo que esperaba. A través de una historia llena de problemas a
solucionar, el autor expone las teorías que quiere difundir. Estas teorías
están relacionadas con el desarrollo de software y más concretamente con el
mundillo DevOps.</p>

<p>En realidad, el autor defiende unas prácticas que son la fundación del
movimiento DevOps, pero para llegar hasta ahí, el protagonista de la historia
comienza con un ascenso que le lleva a ser el director del departamento de TI
de una empresa que no destaca por su gestión de servicios tecnológicos, pero
que solucionando problema tras problema, y con la ayuda de una figura un poco
enigmática (muy al estilo de <em>La meta</em>), va mejorando hasta hacer del
departamento y la empresa un lugar mucho mejor.</p>

<h2>Conclusiones</h2>

<p>Por un lado, el libro me ha gustado. Es un libro sobre el mundo del desarrollo
de software, muy al estilo de <em>La meta</em>, que también me gustó. Y describe el
proceso que sigue una empresa ficticia de ser un desastre, a ser una empresa
envidiable en su sector.</p>

<p>Pero por otro, me ha decepcionado un poco. Esperaba que estuviera más centrado
en el desarrollo, pero está más centrado en la gestión y provisión de servicios
de TI. No es nada malo, pero estoy más interesado en lo primero.</p>

<p>De todas formas, el libro es interesante, sobre todo si quieres conocer cómo
hacer bien las cosas en un departamento de TI. Creo que este libro es una buena
aproximación al mundo DevOps. Pero no deja a los desarrolladores en muy buen
lugar, así que si eres desarrollador, no te tomes todas las cosas que dicen
sobre nosotros muy a pecho.</p>

<h2>Qué he aprendido</h2>

<blockquote><p>La única cosa más peligrosa que un desarrollador, es un desarrollador
conspirando sobre temas de seguridad</p></blockquote>

<!-- space -->


<blockquote><p>Eliyahu M. Goldratt, quien creó la teoría de las restricciones, nos mostró
que cualquier mejora echa en cualquier sitio que no sea el cuello de botella
es una ilusión, es inútil</p></blockquote>

<!-- space -->


<blockquote><p>Los tiempos de espera dependen de la utilización del recurso</p></blockquote>

<!-- space -->


<blockquote><p>La necesidad reducir contínuamente los ciclos de tiempo es parte del <em>Primer
Camino</em>. La necesidad de la amplificación de los bucles de <em>feedback</em> (o
realimentación), idealmente desde el cliente, es parte del <em>Segundo Camino</em>.
El <em>Tercer Camino</em> va de asegurarnos de estar introduciendo tensión
continuamente en el sistema, de forma que estamos contínuamente reforzando
hábitos y mejorando algo</p></blockquote>

<h2>Recursos relacionados</h2>

<ul>
<li><a href="/blog/2013/04/10/la-meta">La meta</a>, de Eliyahu M. Goldratt</li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/phoenix-project-by-gene-kim.markdown">Notas sobre el libro</a></li>
<li>Blog de <a href="http://www.eferro.net/2016/03/some-books-i-recently-read.html">Eduardo Ferro</a></li>
<li><a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_las_limitaciones">Teoría de las restricciones</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
