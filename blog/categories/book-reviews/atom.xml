<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: book reviews | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/book-reviews/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2017-11-29T22:11:45+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[99 bottles of OOP]]></title>
    <link href="http://rchavarria.github.io/blog/2017/10/19/99-bottles-oop/"/>
    <updated>2017-10-19T22:06:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/10/19/99-bottles-oop</id>
    <content type="html"><![CDATA[<h5>de Sandi Metz y Katrina Owen</h5>

<p><img class="left" src="/images/2017/99-bottles-of-oop.jpg" width="250" height="323"></p>

<h2>Por qué lo he leído</h2>

<p>No conozco personalmete a ninguna de las 2 autoras, pero soy un fan de Sandi y
colaboro en un proyecto open source de Katrina, ¿cómo no iba a leer
<a href="https://www.sandimetz.com/99bottles">99 bottles of OOP</a>?</p>

<p>Ya había leído con anterioridad el libro de Sandi, <a href="http://www.poodr.com/">Programming OODR</a> y me
gustó muchísimo, así que este libro prometía. También había visto alguna charla
de Katrina sobre refactorizaciones, y me asombraron muchísimo, por su claridad
y por su calidad.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>Considero que ambas autoras son un referente en el mundo del desarrollo de
software, por lo que esperaba que el libro me enseñara nuevos temas o ideas
sobre los que aprender y profundizar.</p>

<p>Según había escuchado en algunas entrevistas a las autoras, el libro basa sus
<em>enseñanzas</em> en un caso real, solucionando un problema sencillo, ideal para
realizar en katas, por lo que esperaba que todos los conceptos serían fáciles
(o al menos más fáciles) de entender ya que estarían ilustrados con código real
y ejecutable (mira, como si fueran tests).</p>

<h2>Qué encontre</h2>

<p>Encontré la historia de una refactorización. Sandi y Katrina exponen primero
varias formas de resolver un problema, en principio sencillo, y después van
desgranando una de ellas. Poco a poco, cambio a cambio, refactorización a
refactorización, van cambiando el código hacia una solución muy pulida.</p>

<p>Es impresionante ver cómo van justificando cada cambio. Es como leer tus
propios pensamientos, pero un paso más allá. Muchos de los cambios que proponen
parecen de perogrullo, pero muy pocas veces me he parado a pensar por qué me
parecen así. Es como si racionalizaran el instinto del programador.</p>

<h2>Conclusiones</h2>

<p>Es impresionante cómo va describiendo la refactorización línea a línea. Elimina
multitud de code smells, muchas veces de línea en línea, apoyándose en tests.
Es una gozada ver cómo va quedando el código</p>

<p>(...) es un acto de bondad hacia el lector de tu código. El código que revela
su intención está construido en base a la acumulación de actos así de
intencionados. Programa intencionadamente (escribe un <code>case</code> en lugar de un
<code>if</code> para indicar que las condiciones están relacionadas). <strong>Es una pasada como
el libro racionaliza estas decisiones y las explica</strong></p>

<p>Resulta interesante cómo nombra las cosas, conceptos, clases, variables,...
Nombrado es una de las cosas más difíciles en Computer Science.</p>

<h2>Qué he aprendido</h2>

<p>Una forma de ser mejor identificando olores en el código es practicar
describiendo las características del código, tomando nota de las cosas que te
llaman la atención: incluye cualquier patrón que veas, y cosas que te gustan,
odias o que simplemente no entiendes.</p>

<p>Si el código no está abierto a modificaciones y no sabes por dónde empezar...
empieza eliminando olores en el código. No sabes cómo hacer que el código esté
abierto a modificaciones, así que empiezas a eliminar olores, con la esperanz
de encontrarlo por el camino</p>

<p>Los programadores habilidosos hacen lo correcto cuando intuyen la verdad.
Cuando no la intuyen, se embarcan en experimentos cuidadosos, precisos,
reproducibles y reversibles.</p>

<p>Los atajos demasiado inteligentes son una falsa economía. Invierte en código
que diga la verdad. Simplemente escríbelo. Di no a los atajos, di no a las
chapuzas y ñapas.</p>

<p>Unos consejos que podrían resumir el libro completo serían: busca la
simplicidad, no crees abstracciones demasiado pronto, enfócate en los olores
del código, anda en pasos pequeños, sigue las <em>Flocking rules</em>, refactoriza
siempre en verde, arregla los problemas sencillos primero, trabaja
horizontalmente (cambios horizontales, nunca verticales), buscar puntos de
estabilidad, sé disciplinado, no persigas las cosas brillantes/famosas/de moda</p>

<h2>Frases que me gustaría recordar</h2>

<blockquote><p>Escribir código es el proceso de encontrar el camino hasta el siguiente punto
estable, no el punto final en sí mismo. No es el resultado final, si no el
camino.</p></blockquote>

<!-- more -->


<blockquote><p>El código como el método <code>pluralize</code> (que devuelve <code>bottle</code> o <code>bottles</code>
dependiendo de un número) se escribe cuando los programadores se llevan el
principio DRY al extremo. Cuando te encuentres en una situación como esta,
hazte las siguientes preguntas. Estas mismas preguntas también te ayudarán a
saber si tu código es bueno o costoso.</p></blockquote>

<ol>
<li>El cambio que voy a hacer, ¿hace el código más difícil de entender? Cuando
las abstraciones son las correctas, el código es fácil de entender.</li>
<li>¿Cuál es el coste futuro de no hacer nada ahora? Si no hacer nada no
incrementa los costes, retrasa los cambios.</li>
<li>¿Cuando llegará ese momento?, o ¿cuánto tardaré en obtener más información?
Tolera pacientemente la duplicación si haciéndolo te ayuda a descubrir la
abstracción correcta.</li>
</ol>


<!-- more -->


<blockquote><p>Kent Beck describe diferentes formas de hacer que tus tests pasen. 3 de sus
<em>Green Bar Patterns</em> son:</p></blockquote>

<ol>
<li>Fake It ("Til You Make It"): este estilo de TDD puede parecer extraño y
tedioso, pero con práctica puede llegar a ser natural y rápido</li>
<li>Obvious Implementation: cuidado con ir directamente a la solucion obvia, te
puede llevar por el camino equivocado. Desarrollar el hábito de escribir
solamente el código suficiente para hacer que el test pase te fuerza a escribir
mejores tests.</li>
<li>Triangulate: dirigir las abstracciones conservativamente con los tests. La
triangulación requiere escribir varios test de una sola vez, lo que
significa que tendrás varios test fallando simultáneamente. La idea es escribir
el código necesario para hacer que todos esos tests pasen de forma simultánea.</li>
</ol>


<!-- more -->


<blockquote><p>Hacer que el código existente esté abierto a nuevos requisitos requiere
normalmente de identificar y nombrar abstracciones. Las <em>Flocking Rules</em> se
centran en hacer que las diferencias parezcan similitudes, y por eso son una
herramienta muy útil para descubrir abstracciones. Las Flocking Rules
seleccionan las cosas más parecidas, encuentran la menor diferencia entre ellas
y hacen el cambio más simple para eliminar esa diferencia (evalúa el código,
evalúa y ejecuta, evalúa y usa el código, evalúa, y finalmente borra el código
no usado)</p></blockquote>

<!-- more -->


<blockquote><p>Cuando estés sufriendo por encontrar un buen nombre pero sólo tienes unas
cuantas ocurrencias para guiarte, puede ser de ayuda imaginarte otras cosas que
podrían encajar en la misma catergoría, y luego construir una tabla con los
conceptos.</p></blockquote>

<!-- more -->


<blockquote><p>El Principio de Sustitución de Liskov también aplica a los tipos dinámicos (o
<em>duck types</em>). Las violaciones de Liskov fuerzan a los que envían mensajes a
tener conocimiento sobre varios tipos devueltos, y tratar con ellos de forma
distinta o convertirlos en algo consistente.</p></blockquote>

<!-- more -->


<blockquote><p>No todos los condicionales son malos en la Programación Orientada a Objectos,
hay un lugar para ellos. Algún objeto, en algún lugar, debe elegir qué objetos
crear para las composiciones, y eso normalmente involucra condicionales.</p></blockquote>

<!-- more -->


<blockquote><p>Tener un <strong>data clump</strong> significa normalmente que estás necesitando un
concepto. Cuando esta acumulación se envía como un conjunto de parámetros, el
método que recibe el <em>clump</em> se puede ver inundado con facilidad con lógica
para gestionarlo. Alguna de esta lógica inevitablemente acabará duplicándose en
distintos lugares. Si dos cosas aparecen siempre juntas, es una señal de que
esa pareja representa un concepto más profundo y que necesitamos darle un
nombre.</p></blockquote>

<!-- more -->


<blockquote><p>Los programadores añaden líneas en blanco para acentuar cambios en la temática.
La presencia de múltiples temas sugiere la existencia de múltiples
responsabilidades, lo que hace el código más difícil de entender y leer,
mientras que hace más fácil causar daños cuando haya que hacer algún cambio.</p></blockquote>

<!-- more -->


<blockquote><p>El truco para avanzar usando cambios de una sola línea es alterar temporalmente
la factoría para tolerar varios tipos de entrada. A veces, a la hora de cambiar
condicionnales con polimorfismo, hay momentos en los que algún código debe
soportar varios tipos, hasta que todo el código está adaptado. Especialemente,
si vamos haciendo cambios de una sóla línea</p></blockquote>

<!-- more -->


<blockquote><p>Corregir violaciones de Liskov es importante, porque en lenguajes orientados a
objetos (sobretodo los tipados dinámicamente), se basan en la confianza
explícita en los contratos implícitos entre los objetos. Se trabaja muy bien
con objetos de confianza, porque siempre se comportan como se espera de ellos.
Los objetos que a veces fallan en responder a un mensaje que les envías, o que
ocasionalmente devuelven algo que no esperas, son un dolor, y requieren que los
objetos que les llamen deban conocer demasiadas cosas.</p></blockquote>

<h2>Recursos relacionados</h2>

<ul>
<li>El libro en sí: <a href="https://www.sandimetz.com/99bottles">99 bottles of OOP</a></li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/99-bottles-by-sandi-katrina.notes.markdown">Notas sobre 99 bottles of OOP</a></li>
<li>Nuevo libro, <a href="foo/bar/bar/foo.html">Refactoring to patterns</a>, de Joshua Kerievsky, donde habla de
<em>Gradual Cutover Refactoring</em></li>
<li>Las autoras: <a href="https://www.sandimetz.com/">Sandi Metz</a> y <a href="http://www.kytrinyx.com/">Katrina Owen</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ready player one]]></title>
    <link href="http://rchavarria.github.io/blog/2017/03/26/ready-player-one/"/>
    <updated>2017-03-26T20:52:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/03/26/ready-player-one</id>
    <content type="html"><![CDATA[<h5>de Ernest Cline</h5>

<h2>Por qué lo he leído</h2>

<p><img class="left" src="/images/2017/ready-player-one.jpg"></p>

<p>La primera vez que leí una recomendación sobre el libro fue en <a href="http://www.microsiervos.com/archivo/libros/ready-player-one.html">Microsiervos</a>.
Comentaban que era un libro de ciencia ficción relacionado con los videojuegos
con muchísimas referencias a videojuegos de los años 80.</p>

<p>Al principio no estaba seguro si me gustaría o no. Puede que conozca unos
cuantos juegos de los 80, pero por aquellos años yo era aún un niño, así que no
estaba seguro de que fuera a entender todas esas referencias.</p>

<p>Pero más adelante, los de Microsiervos lo volvieron a recomendar, y un poco
después escuché otra recomendación por parte de Kevin Kelly en el
<a href="http://fourhourworkweek.com/2016/06/05/kevin-kelly-ai-virtual-reality-and-the-inevitable">podcast de Tim Ferris</a>. Uno no se puede resistir a tantas recomendaciones.</p>

<!-- more -->


<h2>De qué trata el libro</h2>

<p>La historia que cuenta el libro está ubicada en un tiempo futuro. Un tiempo
donde todo gira alrededor de internet. La vida digital tiene más peso que la
vida <em>analógica</em>. Pero no todo el mundo se puede permitir las mejores
conexiones a internet.</p>

<p>El protagonista es un estudiante que no tiene una vida fácil. Pero le apasionan
los videojuegos.</p>

<p>Un creador de videojuegos ha creado el mejor videojuego de todos los tiempos.
Es un juego de realidad virtual donde cada jugador está representado por un
avatar y la acción se desarrolla en un mundo virtual. Ese mundo tiene multitud
de escenarios, planetas, ciudades y edificios, los avatares se reúnen, chatean
o hacen videoconferencias. Vamos, todo lo que se puede hacer online, se hace a
través del videojuego. El hecho es que el creador del juego muere, pero antes
de morir organiza un concurso dentro del videojuego, y aquel que gane el
concurso obtendrá un premio que le cambiará la vida.</p>

<p>El concurso trata de encontrar tesoros, de buscar pistas, de superar
pruebas,... Todos ellos referenciando a juegos de la juventud del creador de
juegos, que resulta que son juegos reales de los años 80 y 90. Un jugador
importante de este concurso, es nuestro protagonista, que por más suerte que
otra cosa, es quien supera la primera prueba, lo que desencadena una carrera
frenética por conseguir el premio.</p>

<h2>Conclusiones y valoración</h2>

<p>El libro es una pasada. La historia es sencilla, a veces predecible, pero tiene
unos cuantos giros inesperados que te hacen disfrutar. La trama no es
complicada para nada de seguir. Aún así, hace infinitos guiños a la historia de
los videojuegos. Personalmente, no he entendido todos de ellos, pero si has
jugado a algún videojuego en tu vida, seguro que sentirás muchas conexiones.</p>

<p>También resulta muy interesante para alguien muy relacionado con la tecnología,
como yo, pues el autor describe hardware y software que podrían ser realidad
hoy en día, pero quizá no están muy extendidos entre la gente o es una
tecnología un poco verde todavía, pero puede que sean realidad dentro de pocos
años.</p>

<p>Si eres un apasionado de los videojuegos (aunque no hayas conocido los inicios
de ellos) o si eres un apasionado de la tecnología, estoy seguro de que este
libro te encantará y disfrutarás leyéndolo. Y si no te apetece leer, puedes
esperar a la película (prevista para marzo de 2018, según <a href="http://www.imdb.com/title/tt1677720/?ref_=nv_sr_1">IMDB</a>).</p>

<h2>Notas tomadas</h2>

<p>Simplemente, tomé esta nota:</p>

<blockquote><p>(Hablando sobre comecocos) Permitía vencer a un rival controlado por
ordenador. En un juego como ese, un jugador humano con talento siempre podía
ganar a la máquina, porque el software no era capaz de improvisar. O bien
reaccionaba aleatoriamente, o en un número limitado de formas
predeterminadas, basadas en una cifra finita de condiciones programadas con
antelación. Ese era un axioma de los videojuegos, y seguiría siéndolo hasta
que los seres humanos inventen la verdadera inteligencia artificial.</p></blockquote>

<p>¿Estaremos ya cerca de ese <em>final</em>? Espero que no. Los videojuegos perderán su
gracia.</p>

<h2>Referencias</h2>

<ul>
<li><a href="http://www.amazon.es/gp/product/B00UVAREXK/">Ready player one</a> en Amazon</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The nature of software developent]]></title>
    <link href="http://rchavarria.github.io/blog/2017/03/05/the-nature-of-software-developent/"/>
    <updated>2017-03-05T16:06:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/03/05/the-nature-of-software-developent</id>
    <content type="html"><![CDATA[<h5>de Ron Jeffries</h5>

<p><img class="left" src="https://imagery.pragprog.com/products/363/rjnsd.jpg?1409862136" width="260" height="392" title="The nature of software development" ></p>

<h2>Por qué lo he leído</h2>

<p>Como casi todos los libros, por recomendación. Ví que lo recomendaba
<a href="https://carlosbuenosvinos.com/">Carlos Buenosvinos</a>, y no pude resistirme. Además, el autor es una leyenda
viva del desarrollo del software y del manifiesto Agile, así que tenía que ser
un libro de aúpa.</p>

<p>¿Un libro que trata sobre la <strong>naturaleza</strong> de la profesión a la que te
dedicas? A leerlo casi, casi, sin pensarlo.</p>

<!-- more -->


<h2>Qué esperaba y qué encontré</h2>

<p>Esperaba un libro largo, pesado. Tipo como una biblia o enciclopedia. Un
compendio de mejores prácticas, de leyes no escritas, los 101 mandamientos del
desarrollo del sofware.</p>

<p>De eso nada. <a href="https://pragprog.com/book/rjnsd/the-nature-of-software-development">The nature of sofware development</a> es un libro que se lee con una
facilidad pasmosa. Es increíble como <a href="http://ronjeffries.com/">Ron Jeffries</a> simplifica hasta los
conceptos más complejos de explicar. Hace que el proceso de desarrollo que él
explica parezca el único que debe existir, el natural, al que se debería tender
si dejáramos que las fuerzas actuaran solas (tipo naturaleza, no sé si se me
entiende la metáfora).</p>

<p>Es un libro relativamente corto, con muchas (y muy buenas) ilustraciones.
Dividido en capìtulos digeribles muy fácilmente. Un lenguaje llano, sencillo,
pero preciso.</p>

<h2>Conclusiones</h2>

<p>Por supuesto que es un libro donde se describe muchas mejores prácticas. A mí
me parece que describe el ideal de cómo se debería desarrollar un proyecto
software. Casi tan bueno, que me parece un sueño.</p>

<p>Es un libro que recomendaría leer a todo aquel que su trabajo esté relacionado
con cualquier fase en el desarrollo del software: diseño, programador, dueño de
producto,...</p>

<h2>Qué he aprendido</h2>

<blockquote><p>Las cosas van mejor si cada funcionalidad, también llamada <em>historia</em>, sólo
tardamos <strong>dos o tres</strong> días en implementarla.</p></blockquote>

<p>Coincido totalmente con esa visión. La sufro cada día. Si algo dentro del
equipo nos lleva más de 2/3 días, comenzamos a perder el foco, empiezan a
aparecer pequeñas tareas (pues ya que...) que nos hacen desviarnos del objetivo
inicial. Y al final, se hace muy difícil dar una historia por zanjada. Si
dividimos el trabajo en pequeñas historias entregables y que podamos
materializar en menos de 3 días, todo va mejor la mayor parte del tiempo.</p>

<blockquote><p>Para obtener la mejor calidad, un progreso continuado y una gran
predictabilidad, los tests y las refactorizaciones son la mejor forma
conocida de trabajar.</p></blockquote>

<!-- split -->


<blockquote><p>Necesitamos un progreso constante, regular e ininterrumpido. Para mantener un
progreso ininterrumpido, necesitamos un diseño claro y limpio todo el tiempo.
Y para conseguirlo, necesitamos refactorizar nuestro código.</p></blockquote>

<p>Dos grandes pilares del desarrollo: <strong>tests</strong> y <strong>refactorizaciones</strong></p>

<h2>Frases que quiero recordar</h2>

<blockquote><p>Valor es lo que uno quiere</p></blockquote>

<!-- split -->


<blockquote><p>Un experto excelentemente remunerado no debería ser remunerado solamente
porque es un experto. Debería ser excelentemente remunerado por ayudar a
otras personas a que se conviertan en expertos.</p></blockquote>

<!-- split -->


<blockquote><p>El estilo de <em>funcionalidad a funcionalidad</em> incluye un ciclo completo de
desarrollo en cada iteración: requisitos, diseño, codificación y testeo.</p></blockquote>

<!-- split -->


<blockquote><p>Podemos construir todo el diseño primero, o podemos construir cada
funcionalidad completamente de una en una, cada una con su base. Lo que no
podemos hacer es construir toda la base al principio, así como tampoco
podemos construir todas las funcionalidades al principio. Es de lejos mucho
más seguro construir una versión simple pero funcional de cada funcionalidad
primero.</p></blockquote>

<!-- split -->


<blockquote><p>Trabajamos incrementalmente. Necesitamos un buen diseño relativamente pronto,
pero solo necesitamos un <strong>pequeño</strong> buen diseño.</p></blockquote>

<!-- split -->


<blockquote><p>Toma cada posible idea como una posible forma de comenzar a hacer cosas
durante un tiempo. Luego, haz tuyo el proceso, y construye tus propias ideas.
¡Pero mantenlo simple!</p></blockquote>

<!-- split -->


<blockquote><p>Nuestro trabajo no es ceñirnos al plan, es ir corrigiendo el curso para
obtener el mejor resultado, no llegar a algún punto fijo.</p></blockquote>

<!-- split -->


<blockquote><p>Lo hacemos mejor no cuando predecimos cuándo habremos terminado, si no cuando
elegimos cuándo está terminado (pero es que debemos mantenernos siempre en un
estado de <em>terminado</em> de forma constante)</p></blockquote>

<!-- split -->


<blockquote><p>La palabra refactorizar se refiere al proceso simple y regular de mantener el
código limpio. Cuando la carretera se convierte en un camino intrincado, lo
enderezamos refactorizando el código.</p></blockquote>

<h2>Referencias</h2>

<ul>
<li><a href="https://vimeo.com/79106557">The fundamental theorem of Agile Software Development</a>, de J.B.Rainsberger</li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/the-nature-of-software-development-by-ron-jeffries.markdown">Notas sobre The nature of Software development</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Phoenix project]]></title>
    <link href="http://rchavarria.github.io/blog/2017/01/19/the-phoenix-project/"/>
    <updated>2017-01-19T22:23:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/01/19/the-phoenix-project</id>
    <content type="html"><![CDATA[<h5>de Gene Kim</h5>

<p><img class="left" src="/images/2017/phoenix-project.png" width="200" height="246"></p>

<h2>Por qué lo he leído</h2>

<p>Había visto varias referencias al libro por Twitter, blogs y distintos
podcasts. Sabía que el libro era muy similar a <a href="/blog/2013/04/10/la-meta">La meta</a>, de Eliyahu M.
Goldratt, un libro que me gustó bastante.</p>

<p>Así que, tras ver que <a href="http://www.eferro.net/2016/03/some-books-i-recently-read.html">Eduardo Ferro</a> también lo había leído, me decidí a
leerlo yo también.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>No creo que se pudiera esperar tanto como de <a href="/blog/2013/04/10/la-meta">La meta</a>. Ese libro es un recurso
más que recomendable para conocer la <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_las_limitaciones">Teoría de las restricciones</a>. Pero
esperaba algo similar enfocado en el mundo del software.</p>

<p>Esperaba una historia de éxito de una persona o grupo de personas que van
superando problemas, uno tras otro, donde el autor los aproveche para explicar
su punto de vista y dar forma a las teorías que quiere explorar.</p>

<h2>Qué encontre</h2>

<p>Más o menos lo que esperaba. A través de una historia llena de problemas a
solucionar, el autor expone las teorías que quiere difundir. Estas teorías
están relacionadas con el desarrollo de software y más concretamente con el
mundillo DevOps.</p>

<p>En realidad, el autor defiende unas prácticas que son la fundación del
movimiento DevOps, pero para llegar hasta ahí, el protagonista de la historia
comienza con un ascenso que le lleva a ser el director del departamento de TI
de una empresa que no destaca por su gestión de servicios tecnológicos, pero
que solucionando problema tras problema, y con la ayuda de una figura un poco
enigmática (muy al estilo de <em>La meta</em>), va mejorando hasta hacer del
departamento y la empresa un lugar mucho mejor.</p>

<h2>Conclusiones</h2>

<p>Por un lado, el libro me ha gustado. Es un libro sobre el mundo del desarrollo
de software, muy al estilo de <em>La meta</em>, que también me gustó. Y describe el
proceso que sigue una empresa ficticia de ser un desastre, a ser una empresa
envidiable en su sector.</p>

<p>Pero por otro, me ha decepcionado un poco. Esperaba que estuviera más centrado
en el desarrollo, pero está más centrado en la gestión y provisión de servicios
de TI. No es nada malo, pero estoy más interesado en lo primero.</p>

<p>De todas formas, el libro es interesante, sobre todo si quieres conocer cómo
hacer bien las cosas en un departamento de TI. Creo que este libro es una buena
aproximación al mundo DevOps. Pero no deja a los desarrolladores en muy buen
lugar, así que si eres desarrollador, no te tomes todas las cosas que dicen
sobre nosotros muy a pecho.</p>

<h2>Qué he aprendido</h2>

<blockquote><p>La única cosa más peligrosa que un desarrollador, es un desarrollador
conspirando sobre temas de seguridad</p></blockquote>

<!-- space -->


<blockquote><p>Eliyahu M. Goldratt, quien creó la teoría de las restricciones, nos mostró
que cualquier mejora echa en cualquier sitio que no sea el cuello de botella
es una ilusión, es inútil</p></blockquote>

<!-- space -->


<blockquote><p>Los tiempos de espera dependen de la utilización del recurso</p></blockquote>

<!-- space -->


<blockquote><p>La necesidad reducir contínuamente los ciclos de tiempo es parte del <em>Primer
Camino</em>. La necesidad de la amplificación de los bucles de <em>feedback</em> (o
realimentación), idealmente desde el cliente, es parte del <em>Segundo Camino</em>.
El <em>Tercer Camino</em> va de asegurarnos de estar introduciendo tensión
continuamente en el sistema, de forma que estamos contínuamente reforzando
hábitos y mejorando algo</p></blockquote>

<h2>Recursos relacionados</h2>

<ul>
<li><a href="/blog/2013/04/10/la-meta">La meta</a>, de Eliyahu M. Goldratt</li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/phoenix-project-by-gene-kim.markdown">Notas sobre el libro</a></li>
<li>Blog de <a href="http://www.eferro.net/2016/03/some-books-i-recently-read.html">Eduardo Ferro</a></li>
<li><a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_las_limitaciones">Teoría de las restricciones</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The 4 hour body]]></title>
    <link href="http://rchavarria.github.io/blog/2016/12/04/the-4-hour-body/"/>
    <updated>2016-12-04T18:14:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2016/12/04/the-4-hour-body</id>
    <content type="html"><![CDATA[<h6>de Tim Ferriss</h6>

<p><img class="left" src="https://raw.githubusercontent.com/rchavarria/blog-post-incubator/master/published-book-notes/img/4-hour-body-cover.jpeg" width="200" height="250"></p>

<h3>Por qué lo he leído</h3>

<p>Soy un oyente del podcast de <a href="http://fourhourworkweek.com/about/">Tim Ferriss</a>, <a href="http://fourhourworkweek.com/podcast/">the 4 hour workweek podcast</a>, y me parece una persona bastante peculiar, con unas ideas bastante rompedoras, y muy preocupado por el aprender y dominar muy distintas disciplinas rápidamente. No estoy de acuerdo con todo lo que Tim <em>predica</em>, pero la verdad es que muchas de sus ideas me parecen muy buenas y les han dado resultados a muchos de sus seguidores. Entiendo que eso no quiere decir que funcionen en todos los casos, pero al menos las ideas locas de Tim han sido probadas más de una vez.</p>

<p><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/4-hour-body-by-tim-ferriss.markdown">The 4 hour body</a>, o <em>El cuerpo perfecto en 4 horas</em> que es su título en español, trata de dos cosas básicamente: cómo perder peso, y cómo ganar músculo. Y yo estoy interesado en perder peso, asi que ¿por qué no conocer algunas ideas de una persona seguida por millones?</p>

<!-- more -->


<h3>De qué trata el libro</h3>

<p>El libro trata de enseñarte cómo conseguir un cuerpo perfecto en 4 horas. Bueno, el título creo que está más escogido para cuadrar con otros libros del autor como <em>La semana laboral de 4 horas</em> y otros con títulos similares.</p>

<p>Trata temas relacionados con la pérdida de peso, otros temas sobre cómo ganar músculos de forma brutal o de cómo tener sexo increíble. En el libro propone seguir una dieta que llama <em>de bajos hidratos de carbono</em> y sugiere seguir una serie de ejercicios para ganar músculo basado en el concepto de <em>mínima dosis efectiva</em>.</p>

<p>Al tratar temas muy diversos y con objetivos casi contradictorios (no puede ser que quieras perder peso y que quieras tener cuerpo de culturista a la vez), el autor explica que no es necesario leer el libro de principio a fin, basta con concentrarte en los aspectos que a uno más le interesen.</p>

<h3>Conclusiones y valoración</h3>

<p>Como ya he dicho, el tema que me interesaba (y me interesa) es el de la pérdida de peso. Por eso no puedo valorar el libro al completo, pero la parte de la pérdida de peso es algo controvertida.</p>

<p>A lo largo de su vida, el autor ha experimentado con varios alimentos y técnicas para conseguir reducir la grasa corporal y con ejercicios para ganar músculo. Son métodos fuera de lo común y no parecen estar basados en datos muy científicos. En realidad, creo que el autor se queda con los estudios científicos que apoyan sus creencias.</p>

<p>Aún así, con todo lo inusual de sus consejos, algunos me parece que tienen su lógica, y cogiéndolos con cuidado, creo que se pueden aprovechar algunas ideas. Aunque hay otras, como por ejemplo el consejo de no comer nada de fruta si se quiere perder grasa corporal (porque se supone que la fructosa es un azúcar que se absorve rápidamente y luego se convertirá en grasa) no me gusta mucho. Una cosa es estar interesado en perder peso y otra cosa es dejar de comer alimentos saludables por conseguirlo más rápido. Además, parece ser que la carencia de vitaminas debido a dejar de comer fruta, la aconseja suplir tomando complementos vitamínicos. Y eso no me mola, no tengo ganas de tomar pastillas para suplir un alimento que tengo al alcance de la mano.</p>

<h3>Qué he aprendido</h3>

<p>Dieta para perder peso, ejercicio para ganar musculo</p>

<p>Concepto de <strong>Mínima Dosis Efectiva</strong>: la mínima dosis que produce el resultado esperado. Cualquiercosa por encima de MED es desperdicio. Por ejemplo, para hervir agua necesitas hasta 100ºC. Todo lo que sobrepases esa temperatura no va a hacer que hierba más. O si necesitas 15 minutos de sol para activar la melanina, 4 horas friéndote en la playa no te van a poner mucho más moreno.</p>

<p>Dieta básica baja en carbohidratos: evita carbohidratos blancos, come las mismas pequeñas comidas una y otra vez, no hagas menús complicados, no bebas calorías, no comas fruta, tómate un día de descanso a la semana</p>

<h3>Frases que me gustaría recordar</h3>

<blockquote><p>Cualquier dieta popular se puede resumir en estos 4 puntos: comer más verdura, comer menos grasa saturada, hacer más ejercicio y quemar más calorías, comer más ácidos grasos omega-3</p></blockquote>

<!-- more -->


<blockquote><p>Es <strong>tu responsabilidad</strong>, no la de tu médico o dietista, aprender a qué es lo que mejor responde tu cuerpo (<em>algo así como: experimenta con tu cuerpo</em>)</p></blockquote>

<!-- more -->


<blockquote><p>En el contexto del libro, hay dos dosis mínimas a tener en cuenta: para eliminar grasa acumulada: hacer lo mínimo necesario para disparar una cascada de hormonas específicas de pérdida de grasa, y que para añadir músculo: hacer lo mínimo necesario para disparar mecanismos de crecimiento específicos (músculos) y sistémicos (hormonales)</p></blockquote>

<!-- more -->


<blockquote><p>Tu peso viene y va, como un yo-yo. Acéptalo, búscalo, eso es mejor buscar un balance fijo.</p></blockquote>

<!-- more -->


<blockquote><p>Diferentes fuentes de calorías producen diferentes resultados. Influyen 3 variables: digestión, la proporción hidratos-proteína-grasa y el tiempo.</p></blockquote>

<!-- more -->


<blockquote><p>4 principios de comportamientos anti-fallos: hazlo consciente (diario de ingestas, foto de comida que vas a comer), hazlo como un juego (medidas, motivacion,...), hazlo competitivo (acepta la presión de otros como tú), hazlo pequeño y temporal (en lugar de correr 1h todos los días, corre 5min los primeros días)</p></blockquote>

<!-- more -->


<blockquote><p>Dieta básica baja en carbohidratos: evita carbohidratos blancos, come las mismas pequeñas comidas una y otra vez, no hagas menús complicados, no bebas calorías, no comas fruta, tómate un día de descanso a la semana</p></blockquote>

<!-- more -->


<blockquote><p>Alimentos que bajan el nivel de glucosa en sangre (aunque no quiere decir que adelgacen por sí mismos): alimentos con alto contenido graso, fructosa, zumo de limòn y canela</p></blockquote>

<!-- more -->


<blockquote><p>Más que la cantidad, es el tamaño y la velocidad de las comidas que determina el nivel de glucosa. Lo mejor que puedes hacer es comer despacio.</p></blockquote>

<h3>Recursos relacionados</h3>

<ul>
<li>Todas las <a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/4-hour-body-by-tim-ferriss.markdown">notas sobre el libro</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
