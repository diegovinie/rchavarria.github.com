<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: refactoring | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/refactoring/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2017-10-19T22:25:24+02:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Workflows of refactoring]]></title>
    <link href="http://rchavarria.github.io/blog/2015/09/13/charla-tecnica-workflows-refactoring/"/>
    <updated>2015-09-13T10:08:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/09/13/charla-tecnica-workflows-refactoring</id>
    <content type="html"><![CDATA[<p>Esta semana el post trata sobre las notas que he tomado de una charla técnica
titulada <a href="https://www.youtube.com/watch?v=vqEg37e4Mkw">Workflows of refactoring</a>. El autor de la charla, hablando de
<em>refactoring</em>, no podría ser otro que <a href="http://www.martinfowler.com/">Martin Fowler</a>. En la charla, Martin
comienza hablando de distintos modos de trabajar, dependiendo de la situación,
por ejemplo, nos encontraremos añadiendo funcionalidad o limpiando el código.
Después, Martin describe distintos tipos de refactorizaciones, más allá del
típico paso en TDD o de la refactorización cambiando unos cuantos nombres a las
variables.</p>

<!-- more -->




<iframe width="560"
        height="315"
        src="https://www.youtube.com/embed/vqEg37e4Mkw"
        frameborder="0"
        allowfullscreen></iframe>


<h2>Notas tomadas</h2>

<blockquote><p>La primera vez que la gente escucha hablar de <em>refactoring</em> es cuando oye hablar
del ciclo de TDD: red > green > refactor.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p>¿Por qué separar los dos pasos que incluyen el código en TDD? ¿Uno para
escribir el código y otro para refactorizar? Puede que esté hecho para los
programadores menos experimentados y para los impacientes, para aquellos que
antes de nada quieren tener algo funcionando. Kent Beck hablaba de dos modos
de trabajar, dos sombreros: añadiendo funcionalidad y modo mantenimiento
(refactorizando). Se puede cambiar entre ellos, pero no se puede andar
mezclándolos.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p>Otros modos, otros sombreros: mejoras de rendimiento, donde el rendimiento
prima sobre la legibilidad; experimentos (donde el resultado va a ser descartado).</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p><strong>TDD refactoring</strong>: el refactoring que pasa cuando estás haciendo TDD, o tienes
una batería de tests en la que apoyarte</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p><strong>Litter-pickup refactoring</strong>: similar a la regla del Boy Scout. Se trata de que
tienes que trabajar con una base de código que no está escrita como a tí te gustaría
(aunque lo más probable es que hayas sido tú quien la haya escrito). Vas navegando
por el código, y de repente ves algún detalle que no te encaja. Paras todo, y lo
arreglas. En definitiva, como el Boy Scout, dejas el campo un poquito mejor de lo
que te lo encontraste. No quieres pasar mucho tiempo limpiándolo, pero sí dejarlo
un poquito mejor.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p>Cuando encuentras alguna pieza de código en la que tienes que invertir cierto
tiempo entendiendo qué es lo que hace. Cuando terminas entendiéndolo, ¿qué
haces? ¿Lo dejas como está? ¿Y si la próxima vez vuelves a perder tanto tiempo?
Tendrás que refactorizarlo. <strong>Comprehension refactoring</strong>.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p>Hay situaciones en las que después de un tiempo, vuelves a ver código y piensas:
"hey! Ahora conozco una nueva y mejor forma de hacer esto". Esto tiene mucho que
ver con el <em>diseño evolutivo</em>. Por ejemplo, refactorizar un poquito antes de
añadir una nueva funcionalidad. Normalmente, el refactoring es beneficioso en el
largo y medio plazo. Este en concreto, es beneficioso para la tarea en la que
estás trabajando en este mismo momento.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p><strong>Planned refactoring</strong>. Un buen equipo necesitaría poco de este tipo de
refactoring. Para el resto de mortales, un poco de refactorizaciones planificadas
no hace daño.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p><strong>Long-term refactoring</strong>. Por ejemplo, cuando tienes un montón de módulos que
tienen dependencias caóticas. En lugar de parar el desarrollo y dedicar 2 o 3
semanas refactorizando todo esto, ¿qué tal si vas refactorizando poco a poco,
sin romper nada, gradualmente,... hasta que lo consigas? Quizá no tengas del
todo claro cómo llegar al final, pero si vas poco a poco, lo más seguro es que
tarde o temprano encuentres el camino.</p></blockquote>

<h2>Conclusión</h2>

<p>Me parece una charla interesantísima, recomendada 100%. Y no sólo echarle un
vistazo por encima, sino profundizar en los conceptos que Martin Fowler expone.
La charla es la keynote de una conferencia sobre Programación Orientada a
Objectos bastante conocida, así que tiene todas las papeletas de ser un
recurso muy útil.</p>

<p>No estoy seguro, pero tiene pinta de que todos estos conceptos y nombres que
Martin da a los distintos tipos de refactorizaciones los vamos a ir viendo y
desarrollando en años venideros.</p>

<p>Así que ya sabes, haz un hueco en la agenda, y ¡a visualizar la charla!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Therapeutic refactoring]]></title>
    <link href="http://rchavarria.github.io/blog/2015/07/12/charla-tecnica-therapeutic-refactoring/"/>
    <updated>2015-07-12T19:09:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/07/12/charla-tecnica-therapeutic-refactoring</id>
    <content type="html"><![CDATA[<p>Acabo de visualizar la charla <a href="https://www.youtube.com/watch?v=J4dlF0kcThQ">Therapeutical Refactoring</a>, de <a href="https://twitter.com/kytrinyx">Katrina Owen</a>,
creadora de <a href="http://exercism.io">exercism.io</a>, y me ha encantado.</p>

<p>Es una charla donde nos cuenta la historia de una refactorización. Me ha
gustado especialmente cómo cuenta la refactorización. Ocultando las partes
del código que no interesan en el paso actual y resaltando aquellas que
sí.</p>

<p>Me ha recordado mucho a cómo vemos los desarrolladores el código,
focalizándonos en pequeños detalles, entremezclados en líneas y líneas de
código.</p>

<!-- more -->




<iframe width="560"
        height="315"
        src="https://www.youtube.com/embed/J4dlF0kcThQ"
        frameborder="0"
        allowfullscreen></iframe>


<p>En el repositorio <a href="https://github.com/kytrinyx/therapeutic-refactoring">therapeutic-refactoring</a> se pueden ver todos los pasos
que Katrina ha dado en la refactorización.</p>

<h2>Notas</h2>

<p>Alrededor del minuto 19 nos habla del término <em>codejunk</em>. Codejunk trata
sobre ruido, ruido que nos molesta para entender el código, pequeños detalles
que hacen que gastemos más energía de la necesaria para entender qué hace
el código. Algunos no son errores en sí, pero son como pequeños picores
que no te dejan disfrutar.</p>

<p>Describe 10 (de menos a más molestos):</p>

<ol>
<li>Comentarios penosos</li>
<li>Espacios en blanco al final de las líneas</li>
<li>Código comentado</li>
<li>Paréntesis innecesarios</li>
<li>Parámetros explícitos por defecto</li>
<li><code>import</code>s o <code>require</code>s (dependiendo del lenguaje) innecesarios</li>
<li><code>string</code>s hechas de <code>string</code>s</li>
<li>Demasiado trabajo <em>manual</em> (deja que el pc haga el trabajo, no lo hagas tú)</li>
<li>Tests duplicados, hay que poner el mismo mimo en el código de tests
que en el de producción</li>
<li>Una combinación de todos los anteriores</li>
</ol>


<h2>Moral de la historia</h2>

<p>Refactorizar te da como un cerebro externo (exobrain).
Cada uno de nosotros podemos retener una cantidad finita de detalles en la
memoria (me recuerda al post de J.B.Rainsberger
<a href="http://blog.thecodewhisperer.com/2015/03/28/your-tests-are-dragging-you-down">Your tests are dragging you down</a>). Programar es sobretodo, mantener en
mente todos esos detalles. Nuestra memoria trabaja peor bajo condiciones
de miedo o estrés. Refactorizar pone a salvo muchos de estos detalles,
permitiéndonos trabajar más relajadamente y más confiados en que estamos
haciendo un buen trabajo.</p>
]]></content>
  </entry>
  
</feed>
