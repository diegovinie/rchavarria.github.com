<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dart | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/dart/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2017-11-30T21:35:20+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dart Streams]]></title>
    <link href="http://rchavarria.github.io/blog/2015/03/28/dart-streams/"/>
    <updated>2015-03-28T01:39:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/03/28/dart-streams</id>
    <content type="html"><![CDATA[<p>Siendo Dart un lenguaje muy influenciado por JavaScript, no podría dejar de lado
conceptos como la <strong>programación asíncrona</strong>. Existen varios métodos para manejar
la asincronía, y uno de ellos son los <strong>Streams</strong>. Si estás muy interesado en
el método te recomiendo una charla de <a href="http://r.va.gg">Rod Vagg</a>, <a href="https://www.youtube.com/watch?v=oeKkwZhKgP0">Embrace the asynchronous</a>.</p>

<p>Los <em>Streams</em> en Dart forman una interfaz única para cualquier cosa que necesite
enviar repetidamente una serie de datos de forma asíncrona, ya sean eventos HTML
(como escuchar clicks del usuario), o eventos de entrada/salida en una aplicación
de servidor.</p>

<p>Operaciones sobre <em>Streams</em>:</p>

<ul>
<li>Consumir: los datos son sacados de un <code>Stream</code> a uno o varios <code>StreamSubscriber</code></li>
<li>Producir: los datos son introducidos en un <code>Stream</code> desde un <code>StreamController</code></li>
</ul>


<!-- more -->


<h2>Consumiendo un <code>Stream</code></h2>

<p>En lugar de introducir datos al Stream a través de un <code>StreamController</code>,
que podría ser algo largo de contar, vamos a utilizar el constructor
<code>Stream.fromIterable()</code>, el cual nos permite construir un <code>Stream</code> a partir de
una lista de objetos, por ejemplo.</p>

<p>Típicamente, se usa el método <code>listen()</code> para subscribirse a un <code>Stream</code>. Este método
es llamado cada vez que se recibe un dato:</p>

<p>```
var data = [1, 2, 3, 4, 5];
var stream = new Stream.fromIterable(data);</p>

<p>// subscribe to the streams events
stream.listen((value) {
  print("Received: $value");
});
```</p>

<p><code>Stream</code> también tiene otros métodos: <code>first</code>, <code>last</code>, <code>length</code> y <code>isEmpty</code>. Todos
ellos devuelven un <code>Future</code>, como los que estudiamos en <a href="/blog/2015/01/29/operaciones-asincronas-en-dart-con-futures/">Futures con Dart</a>, el cual
se completará con el valor apropiado dentro del <code>Stream</code>:</p>

<p>```
streamProperties() {
  var stream;</p>

<p>  stream = new Stream.fromIterable([1, 2, 3, 4, 5]);
  stream.first.then((value) => print("stream.first: $value"));  // 1</p>

<p>  stream = new Stream.fromIterable([1, 2, 3, 4, 5]);
  stream.last.then((value) => print("stream.last: $value"));  // 5</p>

<p>  stream = new Stream.fromIterable([1, 2, 3, 4, 5]);
  stream.isEmpty.then((value) => print("stream.isEmpty: $value")); // false</p>

<p>  stream = new Stream.fromIterable([1, 2, 3, 4, 5]);
  stream.length.then((value) => print("stream.length: $value")); // 5
}
```</p>

<p>También se pueden tener varios listeners, pero para eso hay que convertir el <code>Stream</code>
en un stream de broadcast con <code>asBroadcastStream()</code>. Podremos comprobar de qué tipo
es un stream con la propiedad <code>isBroadcast</code>.</p>

<p>```
var data = [1, 2, 3, 4, 5];
var stream = new Stream.fromIterable(data);
var broadcastStream = stream.asBroadcastStream();</p>

<p>broadcastStream.listen((value) => print("stream.listen: $value"));
broadcastStream.first.then((value) => print("stream.first: $value"));
//...
```</p>

<h2>Subconjuntos de datos de un <code>Stream</code></h2>

<p>Los <code>Stream</code>s tienen algunos métodos de utilidad que permiten seleccionar un subconjunto
de los datos que vendrán en él. Cada uno de estos métodos devuelve un
<code>Stream</code> al que podemos registrar un listener. Para una lista completa de estos métodos
se puede consultar la documentación oficial: <a href="http://api.dartlang.org/dart_async/Stream.html">API Streams</a>.</p>

<p><code>where</code>: selecciona aquellos datos que cumplen una condición:</p>

<p>```
broadcastStream</p>

<pre><code>.where((value) =&gt; value % 2 == 0) 
.listen((value) =&gt; print("where: $value"));
</code></pre>

<p>```</p>

<p><code>take</code>: toma solo los <code>n</code> primeros elementos:</p>

<p>```
broadcastStream</p>

<pre><code>.take(3) 
.listen((value) =&gt; print("take: $value"));
</code></pre>

<p>```</p>

<p><code>skip</code>: se salta los <code>n</code> primeros elementos:</p>

<p>```
broadcastStream</p>

<pre><code>.skip(3)
.listen((value) =&gt; print("skip: $value"));
</code></pre>

<p>```</p>

<p><code>takeWhile</code>: va tomando datos mientras la condición sea verdadera:</p>

<p>```
broadcastStream</p>

<pre><code>.takeWhile((value) =&gt; value &lt; 3) 
.listen((value) =&gt; print("takeWhile: $value"));
</code></pre>

<p>```</p>

<p><code>skipWhile</code>: va saltando datos mientras la condición sea verdadera:</p>

<p>```
broadcastStream</p>

<pre><code>.skipWhile((value) =&gt; value &lt; 3)
.listen((value) =&gt; print("skipWhile: $value"));
</code></pre>

<p>```</p>

<h2>Transformando streams</h2>

<p>El método <code>Stream.transform()</code> admite un parámetro de tipo <code>StreamTransformer</code>.
Es posible crear uno con el método <code>fromHandlers()</code>, el cual admite un
método como parámetro. Este método se llamará con 2 parámetros: cada uno de
los valores del <code>Stream</code> original, y un <code>StreamSink</code> al cual podremos añadir
el valor transformado. La salida de <code>transform()</code> es un nuevo <code>Stream</code> cuyos
valores han sido transformados por el <code>StreamTransformer</code>.</p>

<p>Todo esto se ve mucho más claro con un poco de código:</p>

<p>```
var transformer = new StreamTransformer.fromHandlers(handleData: (value, sink) {
  // create two new values from the original value
  sink.add("Message: $value");
  sink.add("Body: $value");
});</p>

<p>// transform the stream and listen to its output
stream.transform(transformer).listen((value) => print("listen: $value"));
```</p>

<p>Un ejemplo de la vida real podría ser la lectura de un fichero o de una
petición HTTP, transformando los datos recibidos a <code>String</code> con el decodificador
<code>UTF8.decoder()</code> del paquete <code>dart:convert</code>.</p>

<p>```
File file = new File("some_file.txt");
file.openRead()</p>

<pre><code>.transform(UTF8.decoder) // use a UTF8.decoder
.listen((String data) =&gt; print(data));
</code></pre>

<p>```</p>

<h2>Validando los valores de un <code>Stream</code></h2>

<p>Otros métodos útiles podrían ser <code>any()</code>, <code>every()</code> y <code>contains()</code>, los cuales
devuelven todos <code>Future&lt;boolean&gt;</code>, es decir, un <code>Future</code> que se completa con un
valor de <code>true</code> o <code>false</code>.</p>

<p>Estos métodos servirían para realizar ciertas comprobaciones sobre los datos
recibidos por el <code>Stream</code>. Siguiendo con el ejemplo que crea un <code>Stream</code> a partir
de un array con los valores del 1 al 5:</p>

<p>```
broadcastStream</p>

<pre><code>.any((value) =&gt; value &lt; 5)
.then((result) =&gt; print("Any less than 5?: $result")); // true
</code></pre>

<p>broadcastStream</p>

<pre><code>.every((value) =&gt; value &lt; 5)
.then((result) =&gt; print("All less than 5?: $result")); // false
</code></pre>

<p>broadcastStream</p>

<pre><code>.contains(4)
.then((result) =&gt; print("Contains 4?: $result")); // true
</code></pre>

<p>```</p>

<h2>Gestión de errores con <code>StreamSubscription</code></h2>

<p>Existen dos alternativas para la gestión de errores en los streams. Usando el
objeto <code>StreamSubscription</code> que retorna <code>listen()</code> o pasando los manejadores de
eventos al propio método <code>listen()</code>.</p>

<p>Usando <code>StreamSubscription</code> devuelto por <code>listen()</code>:</p>

<p><code>
var subscription = stream.listen(null);
subscription.onData((value) =&gt; print("listen: $value"));
subscription.onError((err) =&gt; print("error: $err"));
subscription.onDone(() =&gt; print("done"));
</code></p>

<p>Pásandolos como parámetros:</p>

<p>```
var subscription = stream.listen(</p>

<pre><code>(value) =&gt; print("listen: $value"),
onError: (err) =&gt; print("error: $err"),
onDone: () =&gt; print("done")
);
</code></pre>

<p>```</p>

<h2>Eliminando la suscripción a un <code>Stream</code></h2>

<p>Con el método anterior de obtener un objeto <code>StreamSubscription</code>, podemos
utilizar dicha referencia para cancelar la suscripción con el método <code>cancel()</code>.</p>

<p><code>
var subscription = stream.listen(null);
subscription.onData((value) {
  print("listen: $value");
  if (value == 2) subscription.cancel();
});
</code></p>

<h2>Referencias:</h2>

<ul>
<li><a href="https://www.youtube.com/watch?v=oeKkwZhKgP0">Embrace the asynchronous</a></li>
<li><a href="/blog/2015/01/29/operaciones-asincronas-en-dart-con-futures/">Futures con Dart</a>, en este propio blog</li>
<li><a href="http://api.dartlang.org/dart_async/Stream.html">API Streams</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Operaciones asíncronas en Dart con Futures]]></title>
    <link href="http://rchavarria.github.io/blog/2015/01/29/operaciones-asincronas-en-dart-con-futures/"/>
    <updated>2015-01-29T22:06:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/01/29/operaciones-asincronas-en-dart-con-futures</id>
    <content type="html"><![CDATA[<p><a href="http://dartlang.org">Dart</a> es un lenguaje de programación que se ejecuta en un único hilo. Si un
bloque de código bloquea dicho hilo (por ejemplo haciendo una operación de
entrada-salida de larga duración), la aplicación quedará <em>congelada</em>. Las
operaciones asíncronas permiten al programador crear operaciones sin bloquear
la aplicación entera. Dart usa la clase <code>Future</code> para realizar estas
operaciones asíncronas.</p>

<p>En el <a href="https://www.dartlang.org/docs/tutorials/futures/">tutorial sobre Futures</a> podrás encontrar información acerca de cómo
usar esta API de Dart.</p>

<!-- more -->


<h2>Introducción</h2>

<p>El siguiente código haría que la aplicación quedara congelada:</p>

<p>```
import 'dart:io';</p>

<p>void printDailyNewsDigest() {
  File file = new File("dailyNewsDigest.txt");
  print(file.readAsStringSync());
}</p>

<p>void main() {
  printDailyNewsDigest();
  printWinningLotteryNumbers();
  printWeatherForecast();
  printBaseballScore();
}
```</p>

<p>El problema de este código es que <code>readAsStringSync()</code> no retorna hasta que no
termina, con lo que las llamadas al resto de métodos serán retrasadas.</p>

<p>Para lograr hacer que esa llamada no bloquee la ejecución del resto, Dart proporciona
los <em>Futures</em>.</p>

<h2>¿Qué es un <em>Future</em>?</h2>

<p>Es simplemente un medio para obtener un valor en algún momento en el futuro.</p>

<p>La forma en la que funciona es la siguiente: una función que necesita hacer una
acción muy costosa en el tiempo, encola dicha acción como un trabajo para hacer y
devuelve un objeto <code>Future</code> inmediatamente, de esta forma se consigue no bloquear
el hilo de ejecución de Dart. Más adelante, cuando el trabajo ha terminado, y el
valor está disponible, se dice que el <code>Future</code> se ha completado con dicho valor.</p>

<p>Para obtener el valor que representa <code>Future</code>, se usa el método <code>then()</code>, pasándole
como parámetro una función de callback que será llamada con el valor del <code>Future</code>.</p>

<h2>¿Cómo se usa?</h2>

<p>El método bloqueante anterior quedaría así usando <code>Future</code>:</p>

<p>```
import 'dart:io';
import 'dart:async';</p>

<p>void printDailyNewsDigest() {
  File file = new File("dailyNewsDigest.txt");
  Future future = file.readAsString();
  future.then((content) {</p>

<pre><code>print(content);
</code></pre>

<p>  });
}
```</p>

<p>Esta vez, para leer el fichero se usa el método <code>readAsString()</code>, el cual no bloquea
el hilo y retorna un <code>Future</code>. Después, se registra un callback a través del método
<code>then()</code>. Este callback recibe como parámetro el valor que esperamos que retorne
<code>readAsString()</code>, que es el contenido del fichero. Es en este callback donde
se imprime el contenido del fichero leído.</p>

<p>El propio método <code>then()</code> devuelve también un <code>Future</code>, por lo cual se pueden
encadenar distintas llamadas <code>then()</code>.</p>

<h2>Gestión de errores</h2>

<p>La gestión de errores con <code>Future</code> es muy sencilla, ya que la clase proporciona el
método <code>catchError()</code> que será llamado si se produce un error a la hora de conseguir
el valor que representa el <code>Future</code>.</p>

<p>El método anterior se puede reescribir así:</p>

<p>```
void printDailyNewsDigest() {
  File file = new File("dailyNewsDigest.txt");
  Future future = file.readAsString();
  future.then((content) => doSomethingWith(content))</p>

<pre><code>    .catchError((e) =&gt; handleError(e));
</code></pre>

<p>}
```</p>

<p>De esta forma, si <code>readAsString()</code> produce un error, la variable <code>future</code> se completará
con error (en lugar de completarse con el valor del contenido del fichero), lo que
provocará que el <code>Future</code> devuelto por <code>then()</code> se complete también con error, lo que hará
que se llame al método <code>catchError()</code>, el cual gestionará el error.</p>

<h2>Encadenando múltiples llamadas a <code>then()</code></h2>

<p>Supongamos que existen tres funciones: <code>expensiveA()</code>, <code>expensiveB()</code> y <code>expensiveC()</code>. Todas
ellas devolviendo <code>Future</code>s, de forma que se pueden encadenar llamadas a <code>then()</code> de esta
forma:</p>

<p>```
expensiveA().then((aValue) => expensiveB())</p>

<pre><code>        .then((bValue) =&gt; expensiveC()) 
        .then((cValue) =&gt; doSomethingWith(cValue));
</code></pre>

<p>```</p>

<p>También existe otra posibilidad, y es esperar a que termine la ejecución de las tres, para
realizar alguna acción solamente cuando los tres <code>Future</code>s se hayan completado. Para ello,
el API proporciona el método <code>wait()</code>.</p>

<p>```
Future.wait([expensiveA(), expensiveB(), expensiveC()])</p>

<pre><code>  .then((List responses) =&gt; chooseBestResponse(responses));
</code></pre>

<p>```</p>

<p>Aquí, <code>wait()</code> devuelve un <code>Future</code> cuyo valor es una lista con los valores de todos los
<code>Future</code>s pasados como parámetros.</p>

<h2>Creando tus propios <code>Future</code></h2>

<p>De acuerdo, entendido cómo se usan. Pero, ¿y si lo que quiero es ser yo quien comienza la
cadena de <code>Future</code>s? ¿Cómo se crea el primero de ellos?</p>

<p>```
Future methodReturningAFuture() {</p>

<pre><code>return new Future.value('foo bar');
</code></pre>

<p>}
```</p>

<p>El método del código anterior devuelve un valor, un <code>Future</code> que se resuelve al valor
<code>foo bar</code>. Si quisiéramos imprimir esa cadena por consola, haríamos lo siguiente:</p>

<p>```
methodReturningAFuture()</p>

<pre><code>.then((message) =&gt; print(message));
</code></pre>

<p>```</p>

<h2>Conclusión</h2>

<p>Si así <em>en papel</em> no te ha quedado lo suficientemente claro, te recomiendo que te pases
por el <a href="https://www.dartlang.org/docs/tutorials/futures/">tutorial sobre Futures</a> o que le eches un ojo al <a href="https://github.com/rchavarria/dart-tutorials/tree/master/futures">código completo</a> del tutorial.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calcular hashes MD5 en Dart con cipher]]></title>
    <link href="http://rchavarria.github.io/blog/2015/01/22/calcular-md5-dart-cipher/"/>
    <updated>2015-01-22T23:02:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/01/22/calcular-md5-dart-cipher</id>
    <content type="html"><![CDATA[<p>Cuando estoy aprendiendo un lenguaje de programación, me gusta practicar
con él, me gusta escribir código con él. Puedes leer los libros o los blogs
que quieras, pero hasta que no escribas aplicaciones y las ejecutes, nunca
apredenderás nada de ese lenguaje.</p>

<p>Para practicar me gusta <a href="http://solveet.com">Solveet</a>. Puedes encontrar problemas muy diversos,
tanto fáciles como más complicados. Publicas tu código, con lo que todo el
mundo puede verlo (por eso te esfuerzas en dejar tu código un poquito más
limpio).</p>

<p>Recientemente decidí resolver un problema en el que se trata de escribir
un <a href="http://www.solveet.com/exercises/Acceder-a-la-API-Marvel/299">acceso a la API pública de Marvel</a>. Uno de los pasos para acceder a dicha
API es calcular el hash MD5 de unos parámetros a pasar a la API para
autenticarte. Dart es un lenguaje moderno, así que pensé que sería muy
fácil calcular hashes MD5. ¡Menuda decepción me llevé!</p>

<!-- more -->


<h2>Crypto</h2>

<p>En realidad no soy ningún experto en Dart, pero no encontré que el lenguaje
proporcionara clases o métodos para hacerlo. Existe una librería llamada
crypto, que parece haber sido escrita por alguien de dentro, pero me
pareció que estaba abandonada y sin documentación (repito, fue una impresión
mía, que me perdone el autor(es)).</p>

<h2>Cipher</h2>

<p>Por suerte encontré <a href="https://github.com/izaera/cipher">cipher</a>, una librería escrita por <a href="https://twitter.com/izaera">Iván Zaera</a>, que me
puso las cosas más fáciles. El repositorio en git parece activo y tiene
una documentación mucho mejor que la de crypto. Al menos encontré la forma
de usar la librería y hacer lo que quería.</p>

<p>Pero no encontré exactamente lo que buscaba, lo encontré algo desperdigado
entre las páginas de la wiki. Así que este post es para mostrar el método
que encontré para <strong>calcular hashes MD5 en Dart con cipher</strong>.</p>

<h2>Código</h2>

<p>Para usar la librería, hay que añadir la dependencia de la librería al
fichero <code>pubspec.yaml</code> del proyecto:</p>

<p>```
...
dependencies:</p>

<pre><code>cipher: "&gt;=0.7.1 &lt;0.8.0"
</code></pre>

<p>...
```</p>

<p>La siguiente clase, contiene un método público, <code>digest</code>, que acepta un
<code>String</code> como parámetro y devuelve un <code>String</code> con el hash MD5 del mismo:</p>

<p><code>``
// needs</code>cipher` as a project's dependency
import 'package:cipher/cipher.dart';
import 'package:cipher/impl/server.dart';
import 'dart:typed_data';
import 'dart:convert';</p>

<p>/<em>*
 * Uses cipher package to compute the MD5 hash of a given String
 </em>/
class Utf8String2MD5 {</p>

<pre><code>Utf8Encoder encoder;
Digest md5;

Utf8String2MD5() {
    // cipher must be initialized before using any class from the package
    initCipher();

    // cipher class to compute the MD5
    md5 = new Digest('MD5');
    encoder = new Utf8Encoder();
}

/**
 * @param message Message which MD5 hash will be computed
 * @return the MD5 hash of `message`
 */
String digest(String message) {
    // get utf-8 values of the message
    List&lt;int&gt; utf8Data = encoder.convert(message);
    // convert to the input data for the cipher class
    Utf8List inputData = new Uint8List.fromList(utf8Data);
    // compute the MD5
    Uint8List digestValue = md5.process(inputData);

    return digestValue
        .map((i) =&gt; i.toRadixString(16)) // converts to hexadecimal string
        .map((s) =&gt; s.padLeft(2, '0')) // pad strings with 0
        .join(); // join all elements in the List to build a String
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crear Web Components con Dart y Polymer]]></title>
    <link href="http://rchavarria.github.io/blog/2014/12/13/crear-web-components-con-dart-y-polymer/"/>
    <updated>2014-12-13T18:42:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2014/12/13/crear-web-components-con-dart-y-polymer</id>
    <content type="html"><![CDATA[<p><a href="http://dartlang.org">Dart</a> es un lenguaje de programación, no muy conocido hoy en día, pero
que tiene un gran potencial, ya que está pensado para aplicaciones
web, tanto para la parte servidora como para la parte cliente. Así,
con Dart puedes escribir código que se ejecuta en el navegador y
código ejecutándose en un servidor que responda a ese cliente.</p>

<p><a href="http://polymer-project.org">Polymer</a> es una implementación del estándar HTML Web Components,
un estándar que quiere revolucionar la manera en la que se desarrollan
aplicaciones web en los navegadores.</p>

<p>En este tutorial describo lo que he aprendido siguiendo el tutorial acerca
de <a href="https://www.dartlang.org/docs/tutorials/polymer-intro/">Cómo crear un Web Component con Dart y Polymer</a>. Si quieres bucear
en el código directamente, puedes hacerlo en mi repositorio de Github
<a href="https://github.com/rchavarria/dart-tutorials/tree/master/custom-element-dart-tutorial">Custom element Dart tutorial</a>.</p>

<!-- more -->


<h2>Qué vamos a crear</h2>

<p>El Web Component que crearemos con este tutorial es un sencillo cronómetro,
con el cual podremos comenzar a contar el tiempo, pausarlo o detenerlo completamente.</p>

<p>Rápidamente, los pasos que vamos a seguir son:</p>

<ol>
<li>Importar el fichero HTML que contiene la definición del Web Component</li>
<li>Usar el Web Component en nuestra propia página web</li>
<li>Inicializar Polymer. La librería de Dart que vamos a usar ya proporciona
el mecanismo para hacerlo, no te preocupes</li>
</ol>


<h2>Ficheros de los que consta el tutorial</h2>

<ul>
<li><code>web/index.html</code>: es el punto de entrada de la aplicación. Inicializa Polymer,
importa el Web Component y usa el mismo.</li>
<li><code>web/tute_stopwatch.html</code>: código HTML que define el Web Component.
importa el Web Component y usa el mismo.</li>
<li><code>web/tute_stopwatch.dart</code>: código Dart que implementa el Web Component.</li>
</ul>


<h2>Instalando Polymer.dart</h2>

<p>Para poder usar Polymer, primero es necesario instalarlo como una dependencia del
proyecto. Para ello, modificar el fichero <code>pubspec.yaml</code> y añadir el siguiente
contenido:</p>

<p><code>
dependencies:
  polymer: "&gt;=0.15.1 &lt;0.16.0"
</code></p>

<p>Después, ejecutar el comando <code>pub get</code>. <code>pub</code> es una herramienta que viene con el
SDK de Dart. Dart Editor también puede ejecutar este comando para instalar todas
las dependencias del proyecto.</p>

<p>Para inicializar Polymer, modificar <code>web/index.html</code> y añadir esta línea al final
del mismo:</p>

<p>``` html
...</p>

<script type="application/dart">export "package:polymer/init.dart";</script>


<p>...
```</p>

<h2>Incluir Polymer en la aplicación</h2>

<p>Estos son los ficheros a modificar para usar Polymer en la creación del
Web Component:</p>

<p><code>web/tute_stopwatch.html</code>: importar el fichero <code>packages/polymer/polymer.html</code>
antes de definir cualquier Web Component en la aplicación:</p>

<p><code>html
&lt;link rel="import" href="packages/polymer/polymer.html"&gt;
&lt;polymer-element name="tute-stopwatch"&gt;
</code></p>

<p><code>web/tute_stopwatch.dart</code>: importar la librería Polymer en el fichero Dart:</p>

<p><code>
import 'dart:html';
import 'package:polymer/polymer.dart';
// ...
</code></p>

<h2>Instanciar un Web Component</h2>

<p>En la página web donde se va a usar el Web Component, debemos importar la definición
del mismo, usar un tag con su nombre (como si fuera un componente HTML normal) e
inicializar Polymer. De forma que <code>web/index.html</code> quedaría parecido a:</p>

<p>``` html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;!-- importa la definición del Web Component --&gt;
&lt;link rel="import" href="tute_stopwatch.html"&gt;
</code></pre>

<p>  </head></p>

<p>  <body></p>

<pre><code>&lt;!-- usa el Web Component --&gt;
&lt;tute-stopwatch&gt;&lt;/tute-stopwatch&gt;

&lt;!-- inicializa Polymer --&gt;
&lt;script type="application/dart"&gt;export "package:polymer/init.dart";&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<h2>Definiendo el Web Component</h2>

<p>La definición del mismo está en el fichero <code>web/tute_stopwatch.html</code>. Para definirlo
hay que usar el tag <code>&lt;polymer-element&gt;</code> y asignar un nombre al Web Component. En
este caso <code>tute-stopwatch</code>.</p>

<p>El tag <code>&lt;polymer-element&gt;</code> puede tener dos tags hijos: <code>&lt;template&gt;</code>, que contiene
el código HTML; y <code>&lt;script&gt;</code>, que contiene el código Dart.</p>

<p>``` html
<polymer-element name="tute-stopwatch">
  <template></p>

<pre><code>...
</code></pre>

<p>  </template>
  <script type="application/dart" src="tute_stopwatch.dart"></script>
</polymer-element>
```</p>

<h2>Dando comportamiento al Web Component</h2>

<p>El comportamiento es implementado en Dart, en el fichero <code>web/tute_stopwatch.dart</code>.
En este fichero, se declara una clase que extiende de <code>PolymerElement</code> y está
anotada con <code>@CustomTag</code>. El contenido de <code>@CustomTag</code> debe coincidir con el
nombre dado en la definición del Web Component.</p>

<p>```
@CustomTag('tute-stopwatch')
class TuteStopwatch extends PolymerElement {</p>

<pre><code>TuteStopwatch.created() : super.created();
</code></pre>

<p>}
```</p>

<p>Para que todo esté correcto, la clase <code>TuteStopwatch</code> debe heredar de <code>PolymerElement</code> o
implementar las interfaces <code>Polymer</code> y <code>Observable</code>. Además, debe definir un
constructor <em>nombrado</em> que llame a <code>super.created()</code>.</p>

<h2>Enlazando datos entre Dart y HTML</h2>

<p>En la parte visual (HTML) se pueden usar las llaves dobles <code>{{...}}</code> para utilizar una
variable anotada como <code>@observable</code> en la parte de comportamiento (Dart). Por ejemplo,
para usar una <code>String</code> que al modificarla en Dart se actualice la vista HTML, los
ficheros <code>web/tute_stopwatch.html</code> y <code>web/tute_stopwatch.dart</code> quedarían:</p>

<p>``` html
<polymer-element name="tute-stopwatch">
  <template></p>

<pre><code>&lt;div&gt;{{counter}}&lt;/div&gt;
</code></pre>

<p>  </template>
  ...
</polymer-element>
```</p>

<p>```
@CustomTag('tute-stopwatch')
class TuteStopwatch extends PolymerElement {</p>

<pre><code>...
@observable String counter;

void aMethod() {
    counter = '14:59';
}
</code></pre>

<p>}
```</p>

<p>Para hacer un doble enlace, de Dart a HTML y viceversa, se puede consultar en enlace
<a href="https://www.dartlang.org/docs/tutorials/forms/#binding-data">Two-way data binding using Polymer</a>.</p>

<h2>Creando manejadores de eventos</h2>

<p>De la misma forma que se puede enlazar variables, se pueden enlazar manejadores de
eventos que gestionen las interacciones del usuario. Por ejemplo, para responder
ante un click del usuario, en HTML:</p>

<p><code>html
&lt;button on-click="{{start}}"&gt;Start&lt;/button&gt;
</code></p>

<p>Mientras que en Dart:</p>

<p>```
@CustomTag('tute-stopwatch')
class TuteStopwatch extends PolymerElement {</p>

<pre><code>...
void start(Event evt, var detail, Node target) {
    ...
}
</code></pre>

<p>}
```</p>

<p>Donde:</p>

<ul>
<li><code>evt</code>: contiene información sobre el evento</li>
<li><code>detail</code>: puede proveer información adicional sobre el evento</li>
<li><code>target</code>: el nodo HTML que lanzó el evento</li>
</ul>


<p>Para más información, como los manejadores de eventos disponibles y más, consultar
<a href="http://www.polymer-project.org/polymer.html#declarative-event-mapping">Declarative event mapping</a>.</p>

<h2>Desplegando la aplicación</h2>

<p>Antes de desplegar, es necesario el uso de <em>transformadores</em> de Polymer para
completar el proceso. Para ello, modificar <code>pubspec.yaml</code> añadiendo las siguientes
líneas:</p>

<p>```
...
dependencies:
  polymer: ...
transformers:
- polymer:</p>

<pre><code>entry_points: web/index.html
</code></pre>

<p>```</p>

<p>Definiendo <code>entry_points</code> indicamos a Polymer qué ficheros HTML queremos que transforme.</p>

<p>Para probar el Web Component desarrollado podemos seleccionar <em>Ejecutar como JavaScript</em>
sobre el fichero <code>web/index.html</code> desde Dart Editor.</p>

<p>O también, tenemos el comando <code>pub serve</code> en línea de comandos. Este comando nos indicará
una dirección URL donde poder probar la aplicación.</p>

<p>El comando <code>pub build</code> genera ficheros que pueden ser desplegados en un servidor
aparte y que hará posible ejecutar la aplicación en cualquier navegador moderno.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mi primer katayuno]]></title>
    <link href="http://rchavarria.github.io/blog/2014/11/02/mi-primer-katayuno/"/>
    <updated>2014-11-02T01:14:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2014/11/02/mi-primer-katayuno</id>
    <content type="html"><![CDATA[<p>El pasado 25 de octubre asistí a un <a href="http://katayunos.com">katayuno</a> organizado por <a href="http://aprendiendotdd.com">Aprendiendo TDD</a>.
Esta pequeña reunión tuvo lugar en <a href="http://www.materiagriscoworking.com">MateriaGris Coworking</a>, un espacio de coworking
que ha montado un gran amigo mío.</p>

<p>El katayuno consistía en resolver un sencillísimo problema (el tema no es resolver
un gran problema sino practicar TDD): desarrollar un método que, tomando como parámetros
dos números enteros <code>a</code> y <code>b</code>, devuelva una lista con el doble de todos los números
impares entre ambos. Realizamos dos iteraciones, cada vez haciendo <em>pair programming</em>
con una pareja distinta.</p>

<p>En este post voy a describir cómo fueron mis dos iteraciones, y algo de código <a href="http://dartlang.org">Dart</a> que
he escrito después intentando simularlas, para poder ilustrar todo el proceso.</p>

<!-- more -->


<h2>Iteración 1</h2>

<p>En este primera iteración seguimos unos pasos que a mí me parecían correctos.
Empezamos solucionando los casos más sencillos, como aquellos que el resultado
era una lista vacía por ejemplo, para terminar con los más complicados. Estos
pasos me parecían correctos, quizá porque estoy acostumbrado a resolverlos de
ese modo.</p>

<p>Más tarde, como vimos en la pequeña restrospectiva de la iteración mi pareja
y yo mostramos nuestro código, y criticaron bastante nuestro código, la verdad.
No es nada malo, de hecho, aprendimos bastante y otras parejas nos enseñaron
otro enfoque que me pareció interesante.</p>

<p>Al final de la iteración, nuestro código quedó más o menos así:</p>

<pre><code>class OddDoubler {

    List&lt;int&gt; compute(int a, int b) {
        List&lt;int&gt; list = new List&lt;int&gt;();

        while (a &lt;= b) {
            if (isOdd(a)) {
                list.add(a * 2);
            }
            a++;
        }

        return list;
    }

    boolean isOdd(n) =&gt; n % 2 != 0;
}
</code></pre>

<p>El código completo, incluidos tests:
<a href="https://github.com/rchavarria/katayuno-octubre-2014/blob/master/iteration-1/odd-doubles.dart">iteración 1</a>.</p>

<p>A mí, personalmente, el código de producción me gusta, sencillo y
al grano. Pero para llegar a él, hay un paso,
<a href="https://github.com/rchavarria/katayuno-octubre-2014/commit/135d644fdbe75c5c8d6e17cd8f1461f7eaac67ce">donde introducimos el bucle while</a>
que quizá sea un paso demasiado grande, por lo que quizá los tests
elegidos no sean los más adecuados.</p>

<h2>Iteración 2</h2>

<p>En esta segunda iteración cambiamos de pareja. Y también cambiamos la forma
de atacar el problema. Esta vez, siguiendo los consejos de los compañeros
de la iteración anterior, decidimos resolver el problema avanzando por
estados intermedios. Así que esta vez, no solucionamos el problema
desde los casos más sencillos hasta los más complicados.</p>

<p>Decidimos que los pasos intermedios serían:</p>

<ul>
<li>Decidir si un número is impar o no</li>
<li>Implementar un método que nos diera una lista de todos los números entre
dos números dados</li>
<li>Implementar un método que nos eliminara de una lista los números pares</li>
<li>Implementar un método que multiplicara por 2 todos los elementos de
una lista</li>
</ul>


<p>No llegamos a completarlo del todo, la iteración se nos quedó corta, pero
la idea la implementé más tarde y éste es el resultado de la
segunda iteración:</p>

<pre><code>class OddDoubler {

    boolean isOdd(int n) =&gt; n % 2 != 0;

    List&lt;int&gt; getNumbers(int a, int b) =&gt; new List&lt;int&gt;.generate((b - a + 1), (int index) =&gt; a + index);

    List&lt;int&gt; filterOdds(List&lt;int&gt; numbers) {
        numbers.removeWhere((n) =&gt; !isOdd(n));
        return numbers;
    }

    List&lt;int&gt; doubleNumbers(List&lt;int&gt; numbers) =&gt; numbers.map((n) =&gt; n * 2);

    // This method should be the only public method
    // It resolves the KATA
    List&lt;int&gt; compute(int a, int b) =&gt; doubleNumbers(filterOdds(getNumbers(a, b)));
}
</code></pre>

<p>El código completo, incluidos tests:
<a href="https://github.com/rchavarria/katayuno-octubre-2014/blob/master/iteration-2/odd-doubles.dart">iteración 2</a>.</p>

<p>Me gusta más la aproximación de esta iteración, pero lo que no me gusta
es que hay métodos públicos que en realidad deberían ser privados. Son
públicos porque hemos creado tests para comprobar su funcionamiento, pero
deberían ser privados porque no aportan nada fuera de la implementación
de la clase.</p>

<p>Como todo en el desarrollo del software, toda decisión tiene su parte
buena y su parte no tan buena.</p>

<h2>Conclusión</h2>

<p>Es la primera vez que participo en un evento de este tipo, y espero que no
sea la última. La experiencia me encantó.</p>

<p>Sí, es cierto, en la primera iteración nos dieron bastante caña a mi pareja
y a mí, pero eso nos sirvió para entender que no todas las aproximaciones son
igual de buenas, y que hay que ser humilde para tener la mente abierta y
poder aprender de los demás compañeros.</p>

<p>Este tipo de eventos nos ayudan a ser mejores profesionales, y era mi objetivo
al participar en él. Gracias a <a href="http://aprendiendotdd.com">Aprendiendo TDD</a> y a <a href="http://www.materiagriscoworking.com">MateriaGris Coworking</a>
creo que todos aprendimos algo aquella mañana.</p>

<p>Gracias chicos.</p>
]]></content>
  </entry>
  
</feed>
