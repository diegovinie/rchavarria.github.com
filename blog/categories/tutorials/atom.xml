<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tutorials | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/tutorials/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2014-12-13T19:11:48+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Crear Web Components con Dart y Polymer]]></title>
    <link href="http://rchavarria.github.io/blog/2014/12/13/crear-web-components-con-dart-y-polymer/"/>
    <updated>2014-12-13T18:42:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2014/12/13/crear-web-components-con-dart-y-polymer</id>
    <content type="html"><![CDATA[<p><a href="http://dartlang.org">Dart</a> es un lenguaje de programación, no muy conocido hoy en día, pero
que tiene un gran potencial, ya que está pensado para aplicaciones
web, tanto para la parte servidora como para la parte cliente. Así,
con Dart puedes escribir código que se ejecuta en el navegador y
código ejecutándose en un servidor que responda a ese cliente.</p>

<p><a href="http://polymer.org">Polymer</a> es una implementación del estándar HTML Web Components,
un estándar que quiere revolucionar la manera en la que se desarrollan
aplicaciones web en los navegadores.</p>

<p>En este tutorial describo lo que he aprendido siguiendo el tutorial acerca
de <a href="https://www.dartlang.org/docs/tutorials/polymer-intro/">Cómo crear un Web Component con Dart y Polymer</a>. Si quieres bucear
en el código directamente, puedes hacerlo en mi repositorio de Github
<a href="https://github.com/rchavarria/dart-tutorials/tree/master/custom-element-dart-tutorial">Custom element Dart tutorial</a>.</p>

<!-- more -->


<h2>Qué vamos a crear</h2>

<p>El Web Component que crearemos con este tutorial es un sencillo cronómetro,
con el cual podremos comenzar a contar el tiempo, pausarlo o detenerlo completamente.</p>

<p>Rápidamente, los pasos que vamos a seguir son:</p>

<ol>
<li>Importar el fichero HTML que contiene la definición del Web Component</li>
<li>Usar el Web Component en nuestra propia página web</li>
<li>Inicializar Polymer. La librería de Dart que vamos a usar ya proporciona
el mecanismo para hacerlo, no te preocupes</li>
</ol>


<h2>Ficheros de los que consta el tutorial</h2>

<ul>
<li><code>web/index.html</code>: es el punto de entrada de la aplicación. Inicializa Polymer,
importa el Web Component y usa el mismo.</li>
<li><code>web/tute_stopwatch.html</code>: código HTML que define el Web Component.
importa el Web Component y usa el mismo.</li>
<li><code>web/tute_stopwatch.dart</code>: código Dart que implementa el Web Component.</li>
</ul>


<h2>Instalando Polymer.dart</h2>

<p>Para poder usar Polymer, primero es necesario instalarlo como una dependencia del
proyecto. Para ello, modificar el fichero <code>pubspec.yaml</code> y añadir el siguiente
contenido:</p>

<p><code>
dependencies:
  polymer: "&gt;=0.15.1 &lt;0.16.0"
</code></p>

<p>Después, ejecutar el comando <code>pub get</code>. <code>pub</code> es una herramienta que viene con el
SDK de Dart. Dart Editor también puede ejecutar este comando para instalar todas
las dependencias del proyecto.</p>

<p>Para inicializar Polymer, modificar <code>web/index.html</code> y añadir esta línea al final
del mismo:</p>

<p>``` html
...</p>

<script type="application/dart">export "package:polymer/init.dart";</script>


<p>...
```</p>

<h2>Incluir Polymer en la aplicación</h2>

<p>Estos son los ficheros a modificar para usar Polymer en la creación del
Web Component:</p>

<p><code>web/tute_stopwatch.html</code>: importar el fichero <code>packages/polymer/polymer.html</code>
antes de definir cualquier Web Component en la aplicación:</p>

<p><code>html
&lt;link rel="import" href="packages/polymer/polymer.html"&gt;
&lt;polymer-element name="tute-stopwatch"&gt;
</code></p>

<p><code>web/tute_stopwatch.dart</code>: importar la librería Polymer en el fichero Dart:</p>

<p><code>
import 'dart:html';
import 'package:polymer/polymer.dart';
// ...
</code></p>

<h2>Instanciar un Web Component</h2>

<p>En la página web donde se va a usar el Web Component, debemos importar la definición
del mismo, usar un tag con su nombre (como si fuera un componente HTML normal) e
inicializar Polymer. De forma que <code>web/index.html</code> quedaría parecido a:</p>

<p>``` html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;!-- importa la definición del Web Component --&gt;
&lt;link rel="import" href="tute_stopwatch.html"&gt;
</code></pre>

<p>  </head></p>

<p>  <body></p>

<pre><code>&lt;!-- usa el Web Component --&gt;
&lt;tute-stopwatch&gt;&lt;/tute-stopwatch&gt;

&lt;!-- inicializa Polymer --&gt;
&lt;script type="application/dart"&gt;export "package:polymer/init.dart";&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<h2>Definiendo el Web Component</h2>

<p>La definición del mismo está en el fichero <code>web/tute_stopwatch.html</code>. Para definirlo
hay que usar el tag <code>&lt;polymer-element&gt;</code> y asignar un nombre al Web Component. En
este caso <code>tute-stopwatch</code>.</p>

<p>El tag <code>&lt;polymer-element&gt;</code> puede tener dos tags hijos: <code>&lt;template&gt;</code>, que contiene
el código HTML; y <code>&lt;script&gt;</code>, que contiene el código Dart.</p>

<p>``` html
<polymer-element name="tute-stopwatch">
  <template></p>

<pre><code>...
</code></pre>

<p>  </template>
  <script type="application/dart" src="tute_stopwatch.dart"></script>
</polymer-element>
```</p>

<h2>Dando comportamiento al Web Component</h2>

<p>El comportamiento es implementado en Dart, en el fichero <code>web/tute_stopwatch.dart</code>.
En este fichero, se declara una clase que extiende de <code>PolymerElement</code> y está
anotada con <code>@CustomTag</code>. El contenido de <code>@CustomTag</code> debe coincidir con el
nombre dado en la definición del Web Component.</p>

<p>```
@CustomTag('tute-stopwatch')
class TuteStopwatch extends PolymerElement {</p>

<pre><code>TuteStopwatch.created() : super.created();
</code></pre>

<p>}
```</p>

<p>Para que todo esté correcto, la clase <code>TuteStopwatch</code> debe heredar de <code>PolymerElement</code> o
implementar las interfaces <code>Polymer</code> y <code>Observable</code>. Además, debe definir un
constructor <em>nombrado</em> que llame a <code>super.created()</code>.</p>

<h2>Enlazando datos entre Dart y HTML</h2>

<p>En la parte visual (HTML) se pueden usar las llaves dobles <code>U+007B {...}}</code> para utilizar una
variable anotada como <code>@observable</code> en la parte de comportamiento (Dart). Por ejemplo,
para usar una <code>String</code> que al modificarla en Dart se actualice la vista HTML, los
ficheros <code>web/tute_stopwatch.html</code> y <code>web/tute_stopwatch.dart</code> quedarían:</p>

<p>``` html
<polymer-element name="tute-stopwatch">
  <template></p>

<pre><code>&lt;div&gt; { {counter}} &lt;/div&gt;
</code></pre>

<p>  </template>
  ...
</polymer-element>
```</p>

<p>```
@CustomTag('tute-stopwatch')
class TuteStopwatch extends PolymerElement {</p>

<pre><code>...
@observable String counter;

void aMethod() {
    counter = '14:59';
}
</code></pre>

<p>}
```</p>

<p>Para hacer un doble enlace, de Dart a HTML y viceversa, se puede consultar en enlace
<a href="https://www.dartlang.org/docs/tutorials/forms/#binding-data">Two-way data binding using Polymer</a>.</p>

<h2>Creando manejadores de eventos</h2>

<p>De la misma forma que se puede enlazar variables, se pueden enlazar manejadores de
eventos que gestionen las interacciones del usuario. Por ejemplo, para responder
ante un click del usuario, en HTML:</p>

<p><code>html
&lt;button on-click="{ {start}}"&gt;Start&lt;/button&gt;
</code></p>

<p>Mientras que en Dart:</p>

<p>```
@CustomTag('tute-stopwatch')
class TuteStopwatch extends PolymerElement {</p>

<pre><code>...
void start(Event evt, var detail, Node target) {
    ...
}
</code></pre>

<p>}
```</p>

<p>Donde:</p>

<ul>
<li><code>evt</code>: contiene información sobre el evento</li>
<li><code>detail</code>: puede proveer información adicional sobre el evento</li>
<li><code>target</code>: el nodo HTML que lanzó el evento</li>
</ul>


<p>Para más información, como los manejadores de eventos disponibles y más, consultar
<a href="http://www.polymer-project.org/polymer.html#declarative-event-mapping">Declarative event mapping</a>.</p>

<h2>Desplegando la aplicación</h2>

<p>Antes de desplegar, es necesario el uso de <em>transformadores</em> de Polymer para
completar el proceso. Para ello, modificar <code>pubspec.yaml</code> añadiendo las siguientes
líneas:</p>

<p>```
...
dependencies:
  polymer: ...
transformers:
- polymer:</p>

<pre><code>entry_points: web/index.html
</code></pre>

<p>```</p>

<p>Definiendo <code>entry_points</code> indicamos a Polymer qué ficheros HTML queremos que transforme.</p>

<p>Para probar el Web Component desarrollado podemos seleccionar <em>Ejecutar como JavaScript</em>
sobre el fichero <code>web/index.html</code> desde Dart Editor.</p>

<p>O también, tenemos el comando <code>pub serve</code> en línea de comandos. Este comando nos indicará
una dirección URL donde poder probar la aplicación.</p>

<p>El comando <code>pub build</code> genera ficheros que pueden ser desplegados en un servidor
aparte y que hará posible ejecutar la aplicación en cualquier navegador moderno.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aplicacion web RESTful con Spring MVC]]></title>
    <link href="http://rchavarria.github.io/blog/2014/01/22/restful-spring-mvc/"/>
    <updated>2014-01-22T23:10:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2014/01/22/restful-spring-mvc</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
    Find an English version of this post directly in the <a href="https://github.com/rchavarria/javaee-6-demos/tree/master/spring-mvc">source code repository</a>.
</div>


<p>En esta demo crearemos una aplicación web para demostrar el uso del framework
Spring MVC para crear servicios REST.</p>

<p><img class="right" src="/images/2014/spring-mvc.png" title="Spring MVC" ></p>

<p>Será una aplicación web sencilla, sin persistencia en base de datos (para no
complicarla), pero será una aplicación Spring MVC completa donde, en lugar de
generar las respuestas mediante páginas JSP, éstas serán generadas en formato
JSON, para ser consumidas como si se trataran de servicios web.</p>

<!-- more -->


<p>La aplicación no será un servicio web, estrictamente hablando, pero responderá a
peticiones HTTP <code>get</code>, <code>post</code>, <code>put</code> y <code>delete</code> como si se tratara de uno de ellos.</p>

<h1>Instrucciones</h1>

<p>La aplicación será la típica que ofrece operaciones <a href="https://es.wikipedia.org/wiki/CRUD">CRUD</a>,
y gestionará una lista de casas, pisos, chalets,... Es decir, los tipos de propiedades
gestionadas por una agencia inmobiliaria. Por eso, nuestra entidad, nuestro
recurso (hablando en terminología REST), será una Propiedad o <code>Property</code>.</p>

<p>Veamos los distintos pasos que daremos para desarrollar la aplicación:</p>

<h2>Definir la URI para acceder a nuestra entidad</h2>

<p>Solamente tendremos un recurso al que acceder, una Propiedad, así que solo
tendremos una URI a la que acceder:</p>

<pre><code>http://&lt;server name&gt;/springmvc/properties
</code></pre>

<p>Debemos definir los métodos HTTP que usaremos para gestionar las Propiedades:</p>

<ul>
<li><code>GET /properties</code>: devolverá una lista de Propiedades</li>
<li><code>GET /properties/{id}</code>: devolverá los detalles de una Propiedad identificada por {id}</li>
<li><code>POST /properties</code>: creará una nueva Propiedad</li>
<li><code>DELETE /properties/{id}</code>: borrará una Propiedad</li>
<li><code>PUT /properties/{id}</code>: actualizará una Propiedad</li>
</ul>


<h1>Crear un controlador MVC de consultas</h1>

<p>El controlador, que responderá a peticiones de consulta (listar y obtener
por id), se llamará
<code>es.rchavarria.springmvc.rest.PropertiesQueriesController</code>.</p>

<p>Responderá a peticiones HTTP que consulten datos, tales como listar las Propiedades u
obtener los detalles de una de ellas.</p>

<p>Debemos marcar el controlador con anotaciones de Spring MVC de forma que Spring
reconozca la clase como controlador MVC. Usaremos las anotaciones para indicar
qué URI gestionará. Nuestro controlador vacío podría ser algo así:</p>

<pre><code>@Controller
@RequestMapping("/properties")
public class PropertiesQueriesController {
}
</code></pre>

<h2>Crear un método que liste Propiedades</h2>

<p>Nuestro primer método será uno que devuelva una lista de Propiedades. La lista
será creada/obtenida/generada por un servicio, no por el controlador en sí
mismo. En un principio, el servicio gestionará las Propiedades sin ningún tipo
de persistencia, pero siempre podremos implementarla en un futuro.</p>

<p>El método mapeará el método <code>get</code> de HTTP y su valor retornado será parte del
cuerpo de la respuesta. De esta forma, la respuesta no será generada por una
página JSP, sino que la respuesta será texto en formato JSON generado
a partir de un objeto Java:</p>

<pre><code>@RequestMapping(method = RequestMethod.GET)
@ResponseStatus(HttpStatus.OK)
@ResponseBody
public List&lt;String&gt; getAllProperties() {
    return Arrays.asList("one", "two", "three");
}
</code></pre>

<h2>Crear tests para probar el controlador</h2>

<p>Este test será un test de integración, ya que no podemos considerarlo como un
test unitario. No lo podemos considerar así ya que el test arrancará un pequeño
servidor web, arrancará nuestro controlador y realizará peticiones HTTP reales
contra él (un test unitario no debería hacer tantas tareas).</p>

<p>Usaremos <a href="https://code.google.com/p/mockito/">Mockito</a> para simular dependencias
externas y un componente proporcionado por Spring MVC, <code>MockMVC</code>. Este componente
será el servidor y gestionará las peticiones y analizará las respuestas de
nuestro controlador.</p>

<p>El siguiente código muestra cómo preparar un servidor y cómo configurar nuestro
controlador en él:</p>

<pre><code>// ...

private MockMvc mockMvc;

@InjectMocks
PropertiesQueriesController controller;

@Mock
PropertyService propertyService;

@Before
public void setup() {
    MockitoAnnotations.initMocks(this);

    mockMvc = standaloneSetup(controller)
            .setMessageConverters(new MappingJackson2HttpMessageConverter())
            .build();
}

// ...
</code></pre>

<p>Y en el siguiente código vemos cómo probar una petición HTTP <code>get</code>:</p>

<pre><code>@Test
public void testRequestAllPropertiesUsesHttpOK() throws Exception {
    when(propertyService.requestAllProperties()).thenReturn(allProperties());

    mockMvc.perform(get("/properties")
        .accept(MediaType.APPLICATION_JSON))
        .andExpect(status().isOk());
}
</code></pre>

<p>Crearemos otro test, para comprobar esta vez que el resultado es el esperado:</p>

<pre><code>@Test
public void testRequestAllPropertiesRendersOkAsJSON() throws Exception {
    when(propertyService.requestAllProperties()).thenReturn(allProperties());

    mockMvc.perform(get("/properties")
        .accept(MediaType.APPLICATION_JSON))
        .andDo(print())
        .andExpect(jsonPath("$[0].city").value("first city"))
        .andExpect(jsonPath("$[1].address").value("second address"))
        .andExpect(jsonPath("$[2].price").value(300));
}
</code></pre>

<p>Para ver más tests o los tests al completo, por favor, echa un vistazo al
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/spring-mvc">código de la demo</a>
en github.</p>

<h2>Añadir un método al controlador que acepte un parámetro en la URI</h2>

<p>Usaremos URIs del tipo <code>http://&lt;server&gt;/springmvc/properties/&lt;id&gt;</code> para obtener los
detalles de una Propiedad en concreto. <code>&lt;id&gt;</code> representa un identificador de Propiedad,
y el controlador deberá devolver los detalles de la misma en lugar de una lista con
todas las propiedades.</p>

<p>En el controlador, anotaremos un nuevo método con <code>@RequestMapping</code> la cual tendrá
dos parámetros: <code>method</code>, será el método HTTP <code>get</code>; y <code>value</code>, para dar un nombre al
parámetro. La anotación <code>@ResponseStatus</code> indica al framework el código de estado
HTTP que deberá devolver y <code>@ResponseBody</code> nos indica que el valor devuelto por el
método debe ser el cuerpo de mensaje de respuesta.</p>

<p>Este nuevo método tendrá un parámetro, anotado con <code>@PathVariable</code>. Esta anotación
mapea los parámetros del método con parámetros en la URI.</p>

<pre><code>@RequestMapping(method = RequestMethod.GET, value="/{id}")
@ResponseStatus(HttpStatus.OK)
@ResponseBody
public Property getProperty(@PathVariable String id) {
    return propertyService.findById(id);
} 
</code></pre>

<p>Crearemos un test similar al anterior test de integración, pero para no hacer eterno
este post, prefiero que le eches un vistazo al código en el
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/spring-mvc">proyecto de github</a>.</p>

<h2>Configurar controladores MVC</h2>

<p>Usaremos anotaciones para configurar nuestros controladores, Spring MVC lo hace
extremadamente fácil y proporciona una anotación, <code>@EnableWebMVC</code>, que hace
prácticamente todo por nosotros. Y esto es casi todo lo que hay que hacer para
configurar una aplicación MVC.</p>

<p>Nuestra configuración está centralizada en una clase, la cual será sencillísima
y se parecerá a ésta:</p>

<pre><code>@Configuration
@EnableWebMvc
@ComponentScan(basePackages = { "es.rchavarria.springmvc.rest.controllers" })
public class MVCConfig {}
</code></pre>

<p>También crearemos un test de integración para comprobar que configuramos bien
nuestros controladores. Busca el test <code>MVCConfigIntegrationTest</code> en el
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/spring-mvc">repositorio de código</a>
para verlo.</p>

<h2>Inicializar la aplicación web</h2>

<p>Seguiremos sin usar ficheros XML para configurar nuestra aplicación, por lo que lo haremos
a través del código.</p>

<p>Crearemos una clase que herede de una proporcionada por Spring,
<code>AbstractAnnotationConfigDispatcherServletInitializer</code>,
y sobreescribiremos los siguientes métodos:</p>

<ul>
<li><code>getRootConfigClasses</code>: debe devolver un array de clases que configuren el contexto raíz
(root context). Por ahora, no tenemos tal cosa, por lo que puede devolver un array
vacío o simplemente el valor <code>null</code>.</li>
<li><code>getServletConfigClasses</code>: debe devolver un array de clases que configuren el
contexto servlet.</li>
<li><code>getServletMappings</code>: debe devolver los mapeos del servlet.</li>
</ul>


<p>Ya estamos listos para ejecutar nuestra demo en un contenedor de servlets. En este caso,
ejecutaremos la aplicación en un servidor Tomcat 7. Para ello, añadiremos el plugin de
maven de Tomcat 7 a nuestro fichero <code>pom.xml</code>...</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
&lt;/plugin&gt;
</code></pre>

<p>... y ejecutaremos la aplicación con el comando <code>mvn tomcat7:run</code>.</p>

<h2>¿Por dónde seguir?</h2>

<p>Este post ya ha quedado demasiado largo para publicarse, pero no he encontrado forma de
hacerlo más corto y contar todos los pasos involucrados para este desarrollo, pero todavía
tenemos muchísimo trabajo por hacer, por lo que animo a visitar el repositorio de
código fuente de la demo.</p>

<p>Algunas tareas que quedan pendientes, podrían ser:</p>

<ul>
<li>Crear un nuevo controlador, un controlador de comandos (en contraposición a controlador de
consulta), que permita al usuario a crear, actualizar o borrar una Propiedad.</li>
<li>Crear tres métodos en el controlador, uno por cada acción (crear, actualizar y borrar).</li>
<li>Recuerda, cada método deberá estar probado por un test unitario o de integración, que no
se te olvide.</li>
</ul>


<h1>Recursos y lecturas</h1>

<ul>
<li><a href="http://spring.io/guides/tutorials/rest">Build RESTful services with Spring</a></li>
<li><a href="https://github.com/rchavarria/javaee-6-demos/tree/master/spring-mvc">Source code of this demo</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apache MyFaces como implementacion de JavaServer Faces]]></title>
    <link href="http://rchavarria.github.io/blog/2013/10/28/myfaces-implementacion-javaserver-faces/"/>
    <updated>2013-10-28T13:12:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2013/10/28/myfaces-implementacion-javaserver-faces</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
    Find an English version of this post directly in the <a href="https://github.com/rchavarria/javaee-6-demos/tree/master/jsf-basics">source code repository</a>.
</div>


<p>Esta semana, en esta demo sobre Java EE escribiremos una sencilla aplicación
para conocer JavaServer Faces 2.1, un framework MVC impulsado por los
estándares Java EE.</p>

<p>Será similar a otras demos. Tendremos una página de bienvenida, con un
formulario donde el usuario podrá introducir su email y una contraseña. Los
datos del formulario se enviarán a una nueva página que mostrará los
parámetros y sus valores enviados al servidor y permitirá navegar de vuelta
a la pantalla inicial.</p>

<p>Para probarla, simplemente bájate el código, ejecuta el comando <code>mvn</code> y
visita <a href="http://localhost:8080/login.jsf">http://localhost:8080/login.jsf</a> para disfrutar.</p>

<!-- more -->


<h2>Demo</h2>

<p>La demo será una aplicación que mostrará los parámetros enviados a través de
una petición HTTP, y el esquema de navegación será el siguiente:</p>

<p><img class="center" src="/images/2013/jsf-navigation.png" title="Esquema de navegación" ></p>

<h3>Comencemos con el esqueleto</h3>

<p>La forma más rápida de comenzar es con un <em>archetype</em> de maven. Así pues,
usaremos el archetype por defecto de maven, el cual nos creará un
esqueleto inicial para comenzar con nuestra aplicación web. Escribir el
siguiente comando:</p>

<p>```
mvn archetype:generate \</p>

<pre><code>-DgroupId=&lt;group-id&gt; \
-DartifactId=&lt;app-id&gt; \
-DarchetypeArtifactId=maven-archetype-webapp
</code></pre>

<p>```</p>

<p>Donde <code>group-id</code> es el nombre de grupo, por ejemplo, el nombre de la empresa
seguido por el del proyecto. Esta demo usará <code>es.rchavarria.jsf</code>. <code>app-id</code> es
el nombre que queremos para nuestra nueva aplicación, digamos <code>jsf-basics</code>.</p>

<p>Este comando creará el esqueleto de una aplicación web Java, e incluirá una
primera página <code>.jsp</code> (que podemos borrar) y un descriptor de la aplicación
web, <code>web.xml</code>. Para la demo, modificaremos estos ficheros y añadiremos otros
para completarla.</p>

<h3>Añadimos dependencias</h3>

<p>El siguiente paso es añadir las dependencias necesarias a nuestro proyecto:</p>

<ul>
<li><code>myfaces-api</code>: el API pública de clases del proyecto core de Apache MyFaces.</li>
<li><code>myfaces-impl</code>: la implementación privada del API de Apache MyFaces Core</li>
<li><code>tomahawk20</code>: componentes y utilidades JSF para su uso con la implementación de
JSF 2.x.</li>
<li><code>javax-servlet</code>: para acceder al objeto <em>request</em> dentro de la aplicación.</li>
<li><code>jetty</code>: incluiremos <code>jetty</code> como nuestro servidor para desarrollo.</li>
</ul>


<h3>Configurar FacesServlet en el descriptor de la applicación web</h3>

<p>Necesitamos configurar un servlet, FacesServlet en nuestro caso, que gestione
todas las peticiones a JSF. Para ello modificaremos el fichero <code>web.xml</code> de la
siguiente forma:</p>

<p>``` xml
<servlet></p>

<pre><code>&lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
&lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
</code></pre>

<p></servlet>
<servlet-mapping></p>

<pre><code>&lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
&lt;url-pattern&gt;*.jsf&lt;/url-pattern&gt;
</code></pre>

<p></servlet-mapping>
```</p>

<p>Esto hará que el servlet llamado <em>Faces Servlet</em> gestionará todas las peticiones
a páginas que terminen en <code>.jsf</code>.</p>

<p>La mayoría de tutoriales se quedan aquí, pero esta configuración <strong>NO</strong> es
suficiente. Es necesario añadir un listener a nuestro servlet, que dispare la
inicializaci´on de MyFaces. Asegúrate de incluir esto en el <code>web.xml</code>:</p>

<p>``` xml
<listener></p>

<pre><code>&lt;listener-class&gt;org.apache.myfaces.webapp.StartupServletContextListener&lt;/listener-class&gt;
</code></pre>

<p></listener>
```</p>

<p>Estamos en una demo, y por lo tanto bajo un entorno de desarrollo, por lo que
recomendaría usar un <em>context param</em> para indicarselo a MyFaces.</p>

<p>``` xml
<context-param></p>

<pre><code>&lt;param-name&gt;javax.faces.PROJECT_STAGE&lt;/param-name&gt;
&lt;param-value&gt;Development&lt;/param-value&gt;
</code></pre>

<p></context-param>
```</p>

<p>Para ver una lista completa de parámetros que podemos usar, no dejes de leer la
documentacón sobre cómo
<a href="https://myfaces.apache.org/core21/myfaces-impl/webconfig.html">configurar MyFaces</a>.</p>

<h3>Crear una <em>managed bean</em> llamada <code>login</code></h3>

<p>Crearemos una <em>managed bean</em>, que no es más que un POJO que será inyectado en
nuestra vista de JSF y podremos acceder a sus getters/setters y otros métodos.</p>

<p>Crearla es realmente sencillo, usaremos la anotación <code>@ManagedBean</code> y ya estará
casi todo hecho. Como primer uso, haremos que devuelva un título para nuestro
futuro formulario de login. Es un caso de uso muy sencillo, pero nos servirá para
conocer la potencia de JSF. Un vistazo al código:</p>

<p>``` java
import javax.faces.bean.ManagedBean;</p>

<p>@ManagedBean(name = "login", eager = true)
public class GreetingBean {</p>

<pre><code>public String getMessage() {
    return "Login user";
}
</code></pre>

<p>}
```</p>

<p>En el próximo paso, veremo cómo acceder a esta managed bean.</p>

<h3>Crear una vista para la página de login</h3>

<p><a href="https://en.wikipedia.org/wiki/Facelets">Facelets</a> es el sistema de plantillas por defecto en JSF 2.0 (y posteriores).
Esto supone que el código de la vista es XML y se guarda en ficheros con la
extensión <code>.xhtml</code>. Podemos usar componentes JSF dentro de esta vista así como
acceder a managed beans a través del Expression Language, proporcionado por el
estándar Java EE.</p>

<p>Gracias a que las vistas son <em>plantillas</em>, podemos crear componentes visuales
con ellas y reutilizarlos a lo largo de nuestro proyecto.</p>

<p>Aquí muestro un extracto de nuestra vista de login, el fichero <code>login.xhtml</code> que
se encuentra en el directorio <code>src/webapp</code>:</p>

<p>``` html
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
&lt;html xmlns="http://www.w3.org/1999/xhtml"</p>

<pre><code>  xmlns:f="http://java.sun.com/jsf/core"
  xmlns:h="http://java.sun.com/jsf/html"&gt;
</code></pre>

<!-- ... -->


<pre><code>  &lt;h:form styleClass="form-signin"&gt;
    &lt;h2&gt;#{login.message}&lt;/h2&gt;

    &lt;h:commandButton id="login" value="Log me in" 
                     styleClass="btn btn-lg btn-primary btn-block"
                     action="#{login.submit}" /&gt;
  &lt;/h:form&gt;
</code></pre>

<p></html>
```</p>

<p>Nótese que se han definido dos nuevos <em>namespaces</em>: <code>f</code> y <code>h</code>. Esto nos permitirá
usar componentes reutilizables proporcionados por JSF.</p>

<p>En el código vemos que tomamos el título <code>h2</code> de la managed bean llamada <code>login</code>
a través de una sentencia de Expression Language: <code>#{login.message}</code>. Esto
invocará al método <code>getMessage()</code> definido en nuestra managed bean.</p>

<p>El elemento <code>h:commandButton</code> nos permite usar el método <code>submit()</code> de la managed
bean para controlar el siguiente paso a dar en nuestro modelo de navegación. Este
tipo de métodos se conocen como <em>action method</em>. Devuelven una <code>String</code>, la cual
identifica la siguiente vista a renderizar.</p>

<h3>Una nueva managed bean</h3>

<p>Crearemos una nueva managed bean, llamada <code>paramReader</code>. Su propósito será el de
leer los parámetros de la petición HTTP enviada desde la vista anterior y
devolver estos parámetros en forma de lista de valores a una nueva vista.</p>

<p>Para leer los parámetros, lo haremos a través del objeto <code>HttpServletRequest</code>,
all cual accederemos a través de <code>ExternalContext</code> del <code>FacesContext</code>, del
siguiente modo:</p>

<p>``` java
  public List<Parameter> getParams() {</p>

<pre><code>  FacesContext fc = FacesContext.getCurrentInstance();
  HttpServletRequest request = (HttpServletRequest) fc.getExternalContext().getRequest();
  // ...      
  return params;
</code></pre>

<p>  }
```</p>

<h3>Crear una nueva vista</h3>

<p>En esta nueva vista, manipularemos la lista de valores devueltos por la
managed bean <code>paramReader</code>. Por defecto, JSF no proporciona ningún componente
para manipular listas de datos, por lo que aquí usaremos <a href="http://myfaces.apache.org/tomahawk/index.html">Apache Tomahawk</a> y
su componente <code>dataList</code>.</p>

<p>Nuestra nueva vista, <code>success.xhtml</code>, mostrará lal lista de valores en un elemento
HTML. El código (parcial) será algo parecido a esto:</p>

<p>``` html
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
&lt;html xmlns="http://www.w3.org/1999/xhtml"</p>

<pre><code>  xmlns:h="http://java.sun.com/jsf/html"
  xmlns:t="http://myfaces.apache.org/tomahawk"&gt;
</code></pre>

<!-- ... -->


<pre><code>  &lt;ul&gt;
    &lt;t:dataList var="aParam"
                value="#{paramReader.params}"&gt;
      &lt;li&gt;
        &lt;h:outputText value="#{aParam.key}" /&gt; :
        &lt;h:outputText value="#{aParam.value}" /&gt;
      &lt;/li&gt;
    &lt;/t:dataList&gt;
  &lt;/ul&gt;

  &lt;h:form&gt;
    &lt;h:commandLink action="#{paramReader.login}"&gt;Back to login page&lt;/h:commandLink&gt;
  &lt;/h:form&gt;
</code></pre>

<p></html>
```</p>

<p>Usaremos el action method <code>login()</code> en el elemento <code>h:commandLink</code> para permitir al
usuario navegar de vuelta al la página de login.</p>

<h2>Ejecutar</h2>

<p>Para ver la demo en acción, simplemente ejecutar el comando maven <code>mvn jetty:run</code>.
Esto arrancará el servidor. Después, visita la URL
<a href="http://localhost:8080/login.jsf">http://localhost:8080/login.jsf</a> y a jugar!.</p>

<h2>Enlaces y referencias</h2>

<ul>
<li><a href="https://javaserverfaces.java.net/">Mojarra project</a>:
the reference implementation of the JSF specification.</li>
<li><a href="https://en.wikipedia.org/wiki/JavaServer_Faces">JSF on Wikipedia</a>:
Wikipedia entry for JavaServer Faces.</li>
<li><a href="https://en.wikipedia.org/wiki/Facelets">Facelets</a>: Facelets is the default templating system for JSF, instead of JSP's pages</li>
<li><a href="https://myfaces.apache.org/">MyFaces</a>:
an implementation developed by Apache.</li>
<li><a href="http://myfaces.apache.org/tomahawk/index.html">Apache Tomahawk</a>: componentes y utilidades JSF para su uso con la implementación de
JSF 2.x.</li>
<li><a href="http://java.dzone.com/articles/making-distinctions-between">Kinds of managed beans</a>:
a comparison table of several kinds of managed beans.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Entendiendo el ciclo de vida de entidades JPA]]></title>
    <link href="http://rchavarria.github.io/blog/2013/09/29/entendiendo-ciclo-vida-entidades-jpa/"/>
    <updated>2013-09-29T15:24:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2013/09/29/entendiendo-ciclo-vida-entidades-jpa</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
    Find an English version of this post directly in the <a href="https://github.com/rchavarria/javaee-6-demos/tree/master/jpa-entities">source code repository</a>.
</div>


<p>En esta demo aprenderemos en qué estados puede encontrarse una entidad JPA,
y qué métodos proporciona el estándar para transicionar una entidad de un
estado a otro.</p>

<p>Se puede ver el código fuente de la demostración en el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/jpa-entities"><code>jpa-entities</code></a>
del repositorio de las demos en github.</p>

<!-- more -->


<h2>Demo</h2>

<p>Esta demo pertenece a una serie de
<a href="/blog/2013/09/03/demos-tecnologias-javaee">tutoriales de demostración de tecnologías J2EE</a> y
en esta en particular aprenderemos los estados del ciclo de vida de una entidad
JPA y cómo transicionar entre ellos.</p>

<p>Una frase leída en uno de los enlaces que aparecen al final del post dice (traducción
libre):</p>

<blockquote><p>Si, a la hora de modificar entidades, piensas en ellas como transiciones de estados en lugar
de ejecuciones de sentencias SQL, harás tu desarrollo mucho más sencillo.</p></blockquote>

<p>Y es que alguna ventaja tendría que tener lo que proporciona JPA, que es la abstracción
de la base de datos. Si no dejamos de pensar en SQL, nunca podremos abstraernos de la
base de datos. Parece muy buena idea lo de ver la vida de una entidad como una serie
de transiciones de un estado a otro.</p>

<h2>Antes de comenzar</h2>

<p>Antes de nada, existen unas entidades y unos tests sencillos, de ejercitación y puesta a
punto de JPA, Hibernate (implementación de JPA para esta demo) y Derby (el motor de
base de datos utilizada aquí).</p>

<p>Echa un vistazo primero a estas clases (<code>Person</code>, <code>ContactablePerson</code>, <code>Phone</code>) y a los
tests (<code>BasicPersistenceTest</code> y <code>AdvancedPersistenceTest</code>) para poder comprender mejor
el ciclo de vida que describiremos a continuación.</p>

<h2>Estados de una entidad JPA</h2>

<p>Una entidad se puede encontrar en alguno de estos estados:</p>

<ul>
<li>No existe todavía: no es un estado en sí, pero podría verse con el origen de todo.</li>
<li><strong>Nueva</strong>: la entidad se acaba de instaciar con el operador <code>new</code>, como una clase Java
de toda la vida. No está asociado a ningún contexto de persistencia.</li>
<li><strong>Gestionada</strong>: tiene una identidad persistente y está asociada a un contexto de
persistencia.</li>
<li><strong>Separada</strong>: tiene una identidad persistente pero no está asociada a un contexto de
persistencia.</li>
<li><strong>Eliminada</strong>: tiene una identidad persistente, está asociada a un contexto de persistencia,
pero está marcada para ser eliminada de la base de datos.</li>
</ul>


<h2>Ciclo de vida, transiciones</h2>

<p>En el siguiente diagrama, de la documentación de Oracle, se pueden ver las transiciones
posibles de una manera gráfica.</p>

<p><img class="center" src="http://docs.oracle.com/cd/E16439_01/doc.1013/e13981/img/lifeent30.gif" title="Transiciones de una entidad JPA" ></p>

<h3>Transición de nueva a gestionada</h3>

<p>Fácilmente, con el método <code>persist</code>:</p>

<p>``` java
@Test
public void testFromNewToManaged() {</p>

<pre><code>ContactablePerson p = createContactablePerson();

em.persist(p);
assertTrue("entity's state is 'managed'", em.contains(p));
</code></pre>

<p>}
```</p>

<h3>Transición de gestionada a separada</h3>

<p>Existen dos formas:</p>

<ol>
<li>Mediante el método <code>detach</code>.</li>
<li>Cerrando el gestor de entidades, <code>EntityManager.close()</code>.</li>
</ol>


<p>Usando el método <code>detach</code>:</p>

<p>``` java
@Test
public void testFromManagedToDetachedUsingDetachMethod() {</p>

<pre><code>ContactablePerson p = createContactablePerson();
em.persist(p);

em.detach(p);
assertFalse("entity is not in persistence context", em.contains(p));
</code></pre>

<p>}
```</p>

<p>Cerrando el gestor:</p>

<p>``` java
@Test
public void testFromManagedToDetachedClosingEntityManager() {</p>

<pre><code>ContactablePerson p = createContactablePerson();
em.persist(p);

tx.commit();
em.close();

try {
    em.contains(p);
    fail("em should be closed, and the entity shouldn't be managed by him");
} catch (IllegalStateException e) { }
</code></pre>

<p>}
```</p>

<h3>Transición de separada a gestionada</h3>

<p>``` java
@Test
public void testFromDetachedToManaged() {</p>

<pre><code>ContactablePerson p = createContactablePerson();
em.persist(p);
em.detach(p);

ContactablePerson mergedPerson = em.merge(p);

assertFalse("original entity is not managed...", em.contains(p));
assertTrue("... but merged one is", em.contains(mergedPerson));
</code></pre>

<p>}
```</p>

<p>Una entidad previamente gestionada pero que fue separada, es posible actualizarla
a un nuevo contexto de persistencia. Pero hay que tener cuidado, el objeto original
no es el que pasa a ser gestionado, si no que es el devuelto por el método <code>merge</code>.</p>

<h3>Transición de gestionada a eliminada</h3>

<p>``` java
@Test
public void testFromManagedToRemoved() {</p>

<pre><code>ContactablePerson p = createContactablePerson();
em.persist(p);

em.remove(p);
assertFalse("entity has been removed and it is not managed", em.contains(p));
</code></pre>

<p>}
```</p>

<h3>Transición de eliminada a gestionada</h3>

<p>Aunqe esta transición no está documentada en el diagrama anterior de Oracle, es posible
transicionar una entidad a gestionada una vez ésta ya ha sido marcada como eliminada.
Dejo a elección del lector encontrarle utilidad y sentido a esta transición, ya que
aunque sea posible, dudo de su valor. Esta transición es posible si usamos el método
<code>persist</code> sobre la entidad eliminada.</p>

<p>``` java
@Test
public void testFromRemovedToManaged() {</p>

<pre><code>ContactablePerson p = createContactablePerson();
em.persist(p);
em.remove(p);
assertFalse("entity has been removed", em.contains(p));

em.persist(p);
assertTrue("entity is managed again", em.contains(p));
</code></pre>

<p>}
```</p>

<h2>Notas finales</h2>

<p>Antes de terminar, me gustaría recalcar algo acerca de la creación del <code>EntityManagerFactory</code>
y <code>EntityManager</code>, ya que es una cuestión muy importante a la hora de desarrollar nuestras
aplicaciones.</p>

<p>La creación de un <code>EntityManagerFactory</code> es <strong>muy</strong> costoso, y sólo se debería crear
<strong>una</strong> vez en toda la vida de nuestra aplicación. Es por esta razón, que su creación
está en un método estático, que se ejecuta antes que cualquier test, y que sólo se
ejecuta una vez para todos los tests de la suite:</p>

<p>``` java
@BeforeClass
public static void classSetUp() {</p>

<pre><code>emf = Persistence.createEntityManagerFactory("test-jpa");
</code></pre>

<p>}
```</p>

<p>Por otro lado, la creación de una <code>EntityManager</code> es mucho más ligero, y la recomendación
dada por la documentación es la de crear una de ellas por cada transacción que vayamos
a realizar. Pero cuidado, esto no quiere decir que debamos crear una de ellas en
cada consulta a la base de datos, si no más bien, una por cada petición de la aplicación
cliente, es decir, que es una buena práctica agrupar varias consultas siempre y
cuando estas consultas tengan el objetivo de crear un único resultado al cliente.</p>

<p>Por esta razón de que es poco costoso crear un <code>EntityManager</code>, su creación se
realiza en el método <code>setUp</code> del test, de forma que tendremos un contexto de persistencia
limpio en la ejecución de cada uno de nuestros tests, pero reaprovecharemos las
conexiones a la base de datos, ya que éstas se mantienen en el <code>EntityManagerFactory</code>.</p>

<p>``` java
@Before
public void setUp() throws Exception {</p>

<pre><code>em = emf.createEntityManager();
// ...
</code></pre>

<p>}
```</p>

<h2>Ejecución</h2>

<p>Esta demo se puede ejecutar como un test de JUnit, y estaría integrado en la ejecución
de <code>maven</code>, así que simplemente ejecuta el comando <code>mvn test</code> para ver los resultados.</p>

<h2>Enlaces para ampliar información</h2>

<ul>
<li><a href="https://github.com/rchavarria/javaee-6-demos/tree/master/jpa-entities">Código de la demo en github</a></li>
<li><a href="/blog/2011/05/19/uso-de-jpa-hibernate-y-derby">Usar JPA, Hibernate y Derby</a>:
un post en este mismo blog sobre cómo usar JPA, Hibernate como implementación del estándar
y Derby como base de datos.</li>
<li><a href="http://www.davidmarco.es/blog/entrada.php?id=144">An excellent JPA tutorial</a>:
uno de los mejores tutoriales sobre JPA que he encontrado en español.</li>
<li><a href="http://docs.jboss.org/hibernate/core/4.0/hem/en-US/html_single">Hibernate EntityManager</a>:
implementación de JPA dentro del framework Hibernate.</li>
<li><a href="http://docs.oracle.com/cd/E16439_01/doc.1013/e13981/undejbs003.htm">What is a JPA entity?</a>:
documentación de Oracle sobre entidades JPA.</li>
<li><a href="http://www.objectdb.com/java/jpa/persistence/managed">Working with JPA entities objects</a>:
más documentación sobre entidades JPA.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crear una applicación cliente para un servicio web]]></title>
    <link href="http://rchavarria.github.io/blog/2013/09/26/crear-cliente-servicio-web/"/>
    <updated>2013-09-26T07:41:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2013/09/26/crear-cliente-servicio-web</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
    Find a lightweight English version of this post directly in the <a href="https://github.com/rchavarria/javaee-6-demos/tree/master/ws-jaxws-client">source code repository</a>.
</div>


<p>En esta demo crearemos un cliente para el servicio web desarrollado en la demo
anterior. Para ello, utilizaremos una herramienta proporcionada por Java para
generar unas clases a partir del fichero WSDL de descripción del servicio web, y
usaremos dichas clases para invocar el servicio. Así de fácil.</p>

<p>Se puede ver el código fuente de la demostración en el directorio
<a href="https://github.com/rchavarria/javaee-6-demos/tree/master/ws-jaxws-client"><code>ws-jaxws-client</code></a>
del repositorio de las demos en github.</p>

<!-- more -->


<h2>Demo</h2>

<p>Esta demo pertenece a una serie de
<a href="/blog/2013/09/03/demos-tecnologias-javaee">tutoriales de demostración de tecnologías J2EE</a> y
en esta en particular crearemos en cliente que invocará a los métodos expuestos por el servicio
web desarrollado en la demo anterior. Estos métodos son:</p>

<ol>
<li>Añadir usuario: añadiremos un nombre de usuario al servicio.</li>
<li>Obtener usuario: mediante un identificador, obtendremos un nombre de usuario.</li>
</ol>


<p>Con lo cual, añadiremos y consultaremos usuarios.</p>

<h2>Pasos a seguir</h2>

<h3>Arrancar el servicio web</h3>

<p>Lo primero que debemos hacer es arrancar nuestro servicio web. Es necesario para que
el fichero WSDL, que describe el servicio, esté disponible y actualizado. También
es posible usar un fichero ya existente, por ejemplo, en el caso de que queramos
desarrollar un cliente para un servicio web de terceros. En definitiva, el elemento
realmente importante en un servicio web, es el fichero WSDL, que es quien define
de manera inequívoca el servicio en sí.</p>

<p>Para esta demo, arrancaremos el servicio web desarrollado en la
<a href="/blog/2013/09/19/crear-servicio-web-jaxws">demo anterior</a>. Básicamente, los comandos
para arrancarlo, partiendo del directorio raíz del código fuente de todas las demos:</p>

<p><code>
cd ws-jaxws-cxf
mvn jetty:run
</code></p>

<p>De esta forma tendremos el fichero WSDL disponible en <code>http://localhost:8080/Users?wsdl</code>.</p>

<h3>Generar las clases necesarias con <code>wsimport</code></h3>

<p>Java proporciona una herramienta, <code>wsimport</code>, que genera las clases necesarias
para poder consumir fácilmente un servicio web a partir de un fichero WSDL.</p>

<p>La sintaxis del comando es:</p>

<p><code>
wsimport [options] &lt;WSDL_URI&gt;
</code></p>

<p>Así, en nuestro caso, un ejemplo sería:</p>

<p><code>   
wsimport http://localhost:8080/Users?wsdl
</code></p>

<p>Este comando genera las clases, las compila y borra el código fuente. Esto no es
muy práctico a la hora de aprender, así que usaremos algunas opciones para
obtener el código fuente de las clases generadas.</p>

<ul>
<li><code>-d src/main/java</code>: indica el directorio donde queremos generar las clases.</li>
<li><code>-keep</code>: mantiene los ficheros <code>.java</code> generados.</li>
<li><code>-Xnocompile</code>: no compila los fuentes generados, ya se encargará nuestra
herramienta de ello, no os preocupéis.</li>
</ul>


<p>El comando completo quedaría:</p>

<p><code>
wsimport -d src/main/java -keep -Xnocompile http://localhost:8080/Users?wsdl
</code></p>

<p>Las clases generadas que más nos importan, son:</p>

<ul>
<li><code>UsersManagementService</code>: esta clase representa el servicio web en sí.</li>
<li><code>UsersManagement</code>: esta clase contiene los mismos métodos que el servicio web
definido por el fichero WSDL, y actúa como un proxy a la hora de invocar a nuestro
servicio. A esta clase se le denomina <code>port</code> (puerto), y es quien nos permite llamar
a los <em>métodos</em> web.</li>
</ul>


<h3>Crear un test de JUnit para invocar el servicio web</h3>

<p><img class="left" src="/images/2013/web-service-test.png" title="Ejecución de la demo como un test" ></p>

<p>Usaremos un sencillo test de JUnit para invocar a nuestro servicio. Se puede utilizar
una clase normal de Java, con un método <code>main</code>, pero haciéndolo con un test, podemos
integrar su ejecución en el ciclo de vida del proyecto gestionado por <code>maven</code> y
ejecutarlo muy fácilmente con <code>mvn test</code>.</p>

<p>Antes de nada, es necesario añadir la dependencia de JUnit a nuestro proyecto:</p>

<p>``` xml
<dependency></p>

<pre><code>&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;version&gt;4.8.1&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>Crearemos el test en el paquete <code>es.rchavarria.ws.client</code>. En el método <code>setUp</code>
de nuestro test (el que se ejecutará antes que cualquier test) crearemos una
instancia del servicio, y a través de él, obtendremos una instancia de nuestra
clase <em>port</em>. Esta clase será quien nos permita invocar al servicio web.</p>

<p>``` java
//...
public class JaxWsClientTest {</p>

<pre><code>private UsersManagement port;

@Before
public void setUp() {
    UsersManagementService service = new UsersManagementService();
    port = service.getUsersManagementPort();
}
</code></pre>

<p>//...      <br/>
}
```</p>

<h3>Invocando el servicio web</h3>

<p>Ahora ya disponemos de la clase <em>port</em>, así que ya somos capaces de invocar los
métodos expuestos por el servicio: <code>addUser</code> y <code>getUser</code>. A por ellos!!</p>

<p>``` java
@Test
public void test() {</p>

<pre><code>assertEquals(1, port.addUser("The boss"));
assertEquals(2, port.addUser("The king"));
assertEquals(3, port.addUser("The queen"));

assertEquals("The boss", port.getUser(1));
assertEquals("The queen", port.getUser(3));
assertEquals("The king", port.getUser(2));
</code></pre>

<p>}
```</p>

<h2>Ejecución</h2>

<p>Esta demo se puede ejecutar como un test de JUnit, y estaría integrado en la ejecución
de <code>maven</code>, así que simplemente ejecuta el comando <code>mvn test</code> para ver los resultados.</p>

<p>He añadido también un plugin, surefire report, por lo que ejecutnado el comando
<code>mvn site</code>, la herramienta generará (entre otras cosas), un informe con los resultados
de la ejecución de nuestros tests. Ejecuta el comando y abre el fichero HTML que
encontrarás en esta ruta dentro del directorio raiz del proyecto <code>target/site/index.html</code>.</p>

<h2>Enlaces para ampliar información</h2>

<ul>
<li><a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnayl.html">Building web services with JAX-WS</a></li>
<li><a href="http://docs.oracle.com/javaee/6/tutorial/doc/giepu.html">Building RESTful Web Services with JAX-RS</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
