<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: talks | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/talks/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2017-01-19T21:54:48+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Charla no técnica: How to learn anything... fast]]></title>
    <link href="http://rchavarria.github.io/blog/2015/08/30/how-learn-anything-fast/"/>
    <updated>2015-08-30T19:09:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/08/30/how-learn-anything-fast</id>
    <content type="html"><![CDATA[<p>En los trabajos creativos, como en el desarrollo de software, la capacidad para
aprender es un elemento diferenciador. A mí me encanta aprender. Cualquier
cosa. Aunque normalmente siempre elijo temas relacionados con la ciencia,
matemáticas, juegos de ingenio o, cómo no, el desarrollo de software. Cuando vi
el título de la charla (<a href="https://www.youtube.com/watch?v=EtJy69cEOtQ">How to learn anything... fast</a>) me interesó
bastante. ¿Aprender cualquier cosa rápidamente?. ¡Ya me ha cazado!.</p>

<p>En esta charla, <a href="http://joshkaufman.net/">Josh Kaufman</a> indica 5 pasos para aprender cualquier cosa en 20
horas. Típicamente se acepta que para dominar una habilidad, para ser maestro
en algún arte, hacen falta <strong>10.000 horas de práctica deliberada</strong> en esa habilidad
o arte. Josh dice que no tenemos que ir tan lejos, que con <strong>20 horas podemos ser
suficientemente competentes</strong> en cualquier cosa que nos propongamos.</p>

<!-- more -->




<iframe width="560"
        height="315"
        src="https://www.youtube.com/embed/EtJy69cEOtQ"
        frameborder="0"
        allowfullscreen></iframe>


<h2>Pasos</h2>

<ol>
<li>Decidir <strong>qué</strong> aprender.</li>
<li><strong>Dividir</strong> aquello que queremos aprender en habilidades más pequeñas y que
puedan ser practicadas de forma independiente, e identificar aquellas
habilidades más importantes, aquellas habilidades esenciales que te van a
permitir aprender lo que quieres.</li>
<li><strong>Investigar</strong> esas habilidades esenciales. Investiga lo justo y necesario para
saber las mejores formas de realizar las habilidades. Elige de 3 a 5
recursos y pasa rápido por ellos, no profundices (en esta fase) en ellos, ya lo
harás cuando practiques. No uses esta fase para procrastinar, para retrasar el
aprendizaje.</li>
<li>Hacer fácil la práctica. <strong>Elimina distraciones</strong> (TV, móvil, internet,
familiares,...), elimina fricciones, reduce el esfuerzo de comenzar a
practicar, que sea fácil ponerte a ello.</li>
<li>Antes de comenzar, <strong>comprometerse</strong> a realizar al menos 20 horas de práctica
deliberada y enfocada, sin distracciones. Con este compromiso se trata de
eliminar la frustración de todo comienzo, donde somos patéticos con la nueva
habilidad, pero que después de unas prácticas deliberadas, podremos comprobar
nuestro avance.</li>
</ol>


<h2>Conclusión</h2>

<p>Bueno, no creo que 20 horas sean suficientes para aprender <em>cualquier</em> cosa.
Creo que hay materias, habilidades, que necesitan más que eso. Yo no me tomo al
pie de la letra lo que afirma Josh, pero creo que parte de razón sí que tiene.
Puede que 20 horas no sean suficientes para dominar una materia, pero los
consejos que encontramos en esta charla sí me parecen fundamentales para
aprender cualquier cosa, específicamente dividir en partes esenciales aquello
que queremos aprender, eliminar distracciones y fricción y comprometernos con
nosotros mismos a realizar un mínimo de horas de práctica deliberada y
enfocada.</p>

<p>En todo el proceso, echo de menos la recogida de feedback y la medida del
progreso. Quizá el autor lo ha diseñado así para mantener el proceso lo más
simple y más corto posible. Pero aún así, yo añadiría alguna forma de saber si
al final de todo el proceso he llegado donde quería.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: A short history of Software Engineering]]></title>
    <link href="http://rchavarria.github.io/blog/2015/08/16/history-software-engineering/"/>
    <updated>2015-08-16T21:42:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/08/16/history-software-engineering</id>
    <content type="html"><![CDATA[<p>Estas son las notas de una charla técnica titulada
<a href="https://www.youtube.com/watch?v=9IPn5Gk_OiM">A short history of software engineering</a>, por <a href="https://twitter.com/nusco">Paolo Perrota</a>. La charla,
creo que la encontré por un tweet de <a href="https://twitter.com/jbrains">J.B.Rainsberger</a> recomendándola.</p>

<p>La charla trata sobre la historia de la Ingeniería del Software. Un poco lo
de siempre, que la Ingeniería de Software quizá no debiera llamarse
<em>Ingeniería</em>, similitudes y diferencias con otras ingenierías,... Pero Paolo
hace una presentación muy amena y divertida, sin duda merece la pena ver la
charla para saber un poco más sobre nuestra pasión: el desarrollo de
software.</p>

<!-- more -->




<iframe width="560"
        height="315"
        src="https://www.youtube.com/embed/9IPn5Gk_OiM"
        frameborder="0"
        allowfullscreen></iframe>


<h2>Notas</h2>

<p><strong>1968</strong> fue la primera vez que alguien (la OTAN) dijo que el software se
entregaba tarde, fuera de presupuesto, con baja calidad y que no hacía
exactamente lo que tenía que hacer (es decir, que contenía bugs).</p>

<p>La solucion propuesta fue una nueva disciplina, que llamaron <strong>Ingeniería
del Software</strong>, para tratar de salir de esa crisis de proyectos fallidos. Despues
de más de 20 años, decidieron que ya no era una crisis, que era el estado del
arte, que una crisis no dura 20 años.</p>

<p>La Ingeniería del Software trata de solucionar 3 problemas:</p>

<ol>
<li><strong>Eliminar complejidad interna</strong>: si no hay código fuente, no hay complejidad
interna, no hay problema. De ahí que hayan intentado crear <em>lenguajes</em> con los
que no se necesitarían progrmadores. Empezaron diciéndolo en los años 50, con
Cobol. Lo vendían como que era un lenguaje que hasta los managers podrían
entender. El problema es que el desarrollo de software no es solamente
<strong>complejidad accidental</strong> (no toda la complejidad es introducida por los
programadores), sino también <strong>complejidad esencial</strong>, existe en el problema
mismo.</li>
<li><strong>Eliminar errores humanos</strong>: intentaron utilizar las matemáticas, para probar
que el software era correcto. Y vinieron los <em>formal methods</em>, pero es muy caro.
Aparentemente, un monton de matemáticas no pueden reemplazar los tests. Las
matemáticas no pueden solucionar todos los problemas humanos.</li>
<li><strong>Eliminar variabilidad en el proyecto</strong>: otras ingenierías lo hacen: Ingeniería
Civil, Ingeniería mecánica,... En Ingeniería Civil dicen que hay dos tipos de
proyectos: los repetibles y los únicos. Adivinas qué tipo de proyectos no van
tan bien, adivinas qué tipo se pasan de presupuesto. Si vas a hacer algo único,
va a llover dentro (anécdota de aquella casa única que hicieron, con tantas
goteras).</li>
</ol>


<p>En Ingeniería Civil hay dos fases: proyecto y construcción. Similarmente, en
Ingeniería del Software podríamos traducirlas a: diseño e implementación. ¡Pues
no! Las fases, en realidad, son: desarrollo y compilación.</p>

<p>Las economías de ambas ingenierías son muy distintas. En la charla hace
referencia a otra charla, creo que es ésta:
<a href="https://www.youtube.com/watch?v=zDEpeWQHtFU">Real Software Engineering, de Glenn Vaderburg</a>, donde habla precisamente de
éstas diferencias económicas. Mientras que en Ingeniería Civil el mayor coste
es el de construcción, en Ingeniería del Software, el mayor coste es el
desarrollo, el diseño.</p>

<p>Si en un proyecto software tienes 100 programadores, por analogías anticuadas,
quizá creas que tienes 100 albañiles, pero en realidad es como si tuvieras 100
arquitectos para diseñar el mismo edificio. ¿A que eso ya parece algo más
complejo de gestionar?</p>

<p>A continuación, pasa a hablar de metodologías (RUP, DSDM, Prince2, CMMI,...).
Al final, no pudieron eliminar ninguna de las 3 cosas. Pero, y si en lugar de
eliminarlas, ¿las aceptamos?</p>

<p>Las metodologías Agile se basan en 3 puntos:</p>

<ol>
<li>Observa, mira alrededor</li>
<li>Haz una hipótesis</li>
<li>Haz un experimento</li>
</ol>


<p>Estos 3 puntos no son más que el <strong>método científico</strong>. Por lo que el desarrollo
de software es empírico, no es <em>Ingeniería</em>.</p>

<h2>Conclusiones</h2>

<p>Esta es una de esas charlas en la que se discute la idea sobre si la Ingeniería
del Software debería llamarse Ingeniería o no. La idea propuesta aquí es que
no, pero justo el argumento que da el ponente para ello es uno de los argumentos
que veo yo de por qué la Ingeniería del Software sí es una Ingeniería. Paolo
dice que las bases de Agile son las mismas reglas que el método científico, por
lo que el desarrollo de software es empírico, y que por eso no es Ingeniería.
Pero yo no concibo un ingeniero sin un lado científico. ¿Qué es la Ingeniería si
no identificar problemas (observar), idear una solución (hipótesis) y construirla
(experimento)?.</p>

<h2>Referencias</h2>

<ul>
<li><a href="https://www.youtube.com/watch?v=9IPn5Gk_OiM">A short history of software engineering</a></li>
<li><a href="https://www.youtube.com/watch?v=zDEpeWQHtFU">Real Software Engineering</a>, de Glenn Vanderburg</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Is TDD dead? Of course not!]]></title>
    <link href="http://rchavarria.github.io/blog/2015/01/17/charla-tecnica-is-tdd-dead/"/>
    <updated>2015-01-17T17:35:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/01/17/charla-tecnica-is-tdd-dead</id>
    <content type="html"><![CDATA[<p>Hace poco, vi posteada una charla de <a href="http://twitter.com/emilybache">Emily Bache</a> titulada <a href="https://www.youtube.com/watch?v=PCEHRFHKZSk">Is TDD dead? Of course not!</a>
en el blog <a href="http://garajeando.blogspot.com/2015/01/interesting-talk-is-tdd-dead-of-course.html">Garajeando</a>, un blog que suelo leer. Poco después la vi posteada
en otro blog que suelo leer, <a href="http://alvarogarcia7.github.io/blog/2015/01/06/talk-is-tdd-dead-of-course-not-by-emily-bache">The long way through Software Craftsmanship</a>. ¿Algo debería tener
la charla no? Aquí hay un resumen de lo que la charla me a aportado a mí:</p>

<!-- more -->


<p>Básicamente, la charla habla de las tres críticas que <a href="http://twitter.com/dhh">David Heinemeier Hansson</a>
hizo a la práctica de TDD con su <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">TDD is dead, long live testing</a>.</p>

<ol>
<li>Fundamentalismo: para evitarlo, experimenta TDD, inténtalo por tí mismo, que no
te lo cuenten. Después, juzga por tí mismo. Para experimentarlo existen prácticas
como las <em>code katas</em> o <em>coding dojos</em> y herramientas como <a href="http://cyber-dojo.org">cyber-dojo.org</a>.</li>
<li>Daña el diseño: diseñar es difícil (con o sin TDD). TDD
te empuja a introducir nuevos niveles de indirección, hacia el Principio de
Inversión de Dependencias. Aún así, es <strong>tu responsabilidad</strong> como programador
saber cuándo tu aplicación tiene demasiados niveles de indirección y actuar en
consecuencia.</li>
<li>Foco en tests unitarios: puede que David tenga razón aquí, hay mucho foco
en los tests unitarios. Emily nos habla de unos <a href="http://coding-is-like-cooking.info/tag/approval-testing">tests de Aprobación</a> como
complemento a los unitarios.</li>
</ol>


<p>Un montón de consejos (la mayoría) sobre TDD son para principiantes de TDD.
Así que, cuando te den alguno, piensa si ya has superado esa barrera, y si lo
has hecho, ignora el consejo, porque tú ya estas por encima de él. Aprende a
discernir qué información es válida para tu nivel.</p>

<iframe width="560" height="315" src="http://rchavarria.github.io//www.youtube.com/embed/PCEHRFHKZSk" frameborder="0" allowfullscreen></iframe>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla sobre eXtreme Programming]]></title>
    <link href="http://rchavarria.github.io/blog/2014/09/20/charla-sobre-extreme-programming/"/>
    <updated>2014-09-20T01:27:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2014/09/20/charla-sobre-extreme-programming</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/2014/xppractices.jpg" width="360" height="270" title="Prácticas de eXtreme Programming" ></p>

<p>Recientemente he dado una charla en el trabajo acerca de <a href="http://www.extremeprogramming.org">eXtreme Programming</a>.
No es nada del otro mundo, tampoco pretendo dar lecciones a nadie y tampoco
he descubierto nada que no estuviera escrito ya. Pero al hacer la charla he
reunido un poco de información de aquí y de allá, y ya que he hecho ese
pequeño esfuerzo, ¿por qué no plasmarlo aquí?</p>

<p>A continuación os dejo el guión que escribí mientras la preparaba. No conté
todo lo que está, ni está todo lo que conté, pero este fue mi pequeño trabajo
de campo.</p>

<!-- more -->


<h2>Introducción al desarrollo ágil de software</h2>

<p>El desarrollo de software comenzó siendo hecho por ingenieros, de los de toda
la vida (que no quiere decir que sea malo, pero como veremos fue diferente),
lo que condicionó su forma de hacerlo, pero construir software es más parecido
a crear una obra de arte: requiere <em>creatividad</em> y <em>artesanía</em>.</p>

<p>A diferencia de otros productos de la ingeniería, el software es maleable,
muchas veces ilógico y siempre se encuentra incompleto (por eso se parece
a una obra de arte).</p>

<p>Al entender estas diferencias es cuando empiezan a surgir nuevas forma de
desarrollar software, como el desarrollo ágil de software.</p>

<p>No existen metodologías o procesos ágiles (en contra de todo lo que se vende
últimamente), sólo existen <strong>equipos ágiles</strong>. Eso que se describe como
metodología ágil no es más que la construcción de un entorno para que los
equipos aprendan a ser ágiles.</p>

<p>Diferencias con lo que se venía haciendo hasta ahora:</p>

<ul>
<li>La forma en la que el equipo trabaja junto es más importante que cualquier
proceso (gente y comunicación frente a procesos y herramientas).</li>
<li>El cliente, el usuario, pasa a ser un miembro esencial del equipo.</li>
<li>El mayor problema con el desarrollo de software son los requisitos
cambiantes. Para la mayoría de los proyectos, aceptar los cambios puede
costar menos que asegurar que los requisitos no van a cambiar nunca.</li>
</ul>


<p>Al cambiar la forma de ver los cambios, resulta que es más fácil cambiar cómo
se gestionan los proyectos. En lugar de gestionar actividades y esperar al
final del todo a tener una aplicación, los agilistas gestionan los requisitos
(aceptando que éstos van a cambiar) y se muestra al cliente cómo la aplicación
va cambiando con el tiempo.</p>

<h2>Gestión por funcionalidades</h2>

<p>En la gestión tradicional, se planifican las actividades una detrás de otra,
cuando finaliza una comienza la siguiente. Así hasta el final del proyecto.
Es entonces la única vez donde se muestra el software creado.</p>

<p>¿Cómo funciona? Los requisitos son constantes a lo largo del tiempo, y fluyen a
través de las actividades como por una línea de montaje. Cada actividad finaliza
con los requisitos a la vez  y al final de la línea se entrega un software.
Podemos tener gente especializada en cada actividad, e ir cambiando de equipo
según vamos cambiando de actividad. La única pega que tiene es que los requisitos
no son constantes, por lo que todo lo demás no sirve de nada.</p>

<p>¿Y Agile? Agile considera que los requisitos no son constantes. Cada requisito,
cada funcionalidad se presenta al cliente como una Historia de Usuario. El gráfico
anterior se gira 90º y el proceso en sí mismo es el que permanece constante. Se
planifican los requisitos por prioridad, y se va trabajando uno a uno pasándolo por
todas las actividades, por lo que vamos teniendo requisitos completos poco a poco.
Tener los requisitos priorizados permite cambiarlos a antojo. Y no solo eso,
también permite finalizar el proyecto en el momento en el que queramos.</p>

<p>Este giro de 90º permite a los managers a tener una estimación de coste por
requisito, no por actividad.</p>

<p>Uno de los costes de gestionar requisitos es que siempre hay que estar listo para
nuevas funcionalidades, por lo que se debe mantener una calidad muy alta tanto en
diseño como en código.</p>

<h2>Cómo evoluciona el software</h2>

<p>En todo desarrollo de software llega un momento en el al que arreglar un bug,
resulta que se crean uno o varios pequeños bugs por ahí dispersos.</p>

<p>Barry Boehm ya encontró que según va avanzando un proyecto software en su ciclo
de vida, el coste de un cambio se vuelve cada vez más y más grande. Un concepto
que lo explica mejor podría ser el Principio de Oxidación del Software.</p>

<p>Esta curva se comenzó interpretando de forma que se debían crear documentos de
requisitos lo más detallados y lo más estáticos posibles. Agile no lo considera
así, en lugar de eso se prepara para que los cambios en los requisitos cuesten
poco.</p>

<p>Para eso, y para combatir la oxidación del software, Agile propone:</p>

<ul>
<li>Refactorizar: hacerlo sin descanso, sin límites, sin parar, sin excusas…
refactoriza</li>
<li>Tests: unitarios y de aceptación. También se aceptan otros: de integración,
de sistema, de lo que sea, pero tests. Automáticos, eso si. Con ellos se logra
eliminar el miedo a los cambios.</li>
<li>Entrega temprana y frecuente: con ello se aumenta el feedback del cliente y
ayuda a identificar cambios. Y cuanto antes se detecten estos cambios, menor
coste tendrán.</li>
</ul>


<p>¿Cómo mantener la capacidad de poder realizar cambios manteniendo el coste en
niveles aceptables? Sólo porque el cliente no vea el código no significa que
no tengamos que hacer esfuerzo para mantener la capacidad de realizar cambios.
Y esto se consigue manteniendo un alto nivel de calidad, una baja complejidad
y una cobertura de tests lo más alta posible.</p>

<h2>Introducción a XP</h2>

<p>El primer proyecto en el que se usó eXtreme Programming comenzó el 6 de marzo
de 1996. XP es uno de los famosos Procesos Ágiles, entre los que se encuentran
Scrum, Kanban,…</p>

<p>En lugar de entregar todo lo que el cliente desea en un futuro lejano, XP va
entregando el software trocito a trocito, según se va necesitando.</p>

<p>XP hace hincapié en el trabajo en equipo. Managers, clientes y programadores
forman parte del mismo equipo. Los clientes se sienten bien siendo parte del
equipo, los programadores contribuyen activamente y los managers se encargan
de que exista una buena comunicación.</p>

<p>¿Por qué extremo? Por una serie de reglas y prácticas las lleva a su máxima
expresión, mucho más que en proyectos tradicionales.</p>

<h2>De vuelta a lo básico, qué es lo que en realidad importa</h2>

<p>Como ya sabemos, crear software es muy complicado. Por lo que no tiene sentido
perder el tiempo en tareas que no importan. XP se deshace de tareas o actividades
que se consideran que no aportan valor.</p>

<p>XP tiene una serie de reglas que se pueden englobar en estos cuatro aspectos:</p>

<ul>
<li><em>Escuchar</em>: hay que aprender, hay que conocer el problema. Eso te dirá qué es
lo que debes testear. Como probablemente no lo averigües tú solo, deberás
escuchar a los clientes, a los usuarios, managers y demás gente de negocio.</li>
<li><em>Diseñar</em>: hay que escuchar lo que el código nos cuenta acerca de cómo quiere
estar estructurado, y darle forma poco a poco.</li>
<li><em>Codificar</em>: si al final del día no hay un software ejecutable, no habrás
hecho nada.</li>
<li><em>Testear</em>: hay que saber cuándo hemos terminado. De otra forma, estarás atascado
pensando si todo cumple con lo establecido o no. Pero lo peor de todo, es que
tampoco vas a saber cómo de cerca estás de tu destino.</li>
</ul>


<h2>Reglas</h2>

<p>Algunas reglas sueltas quizá no tengan sentido, pero combinadas se puede ver
hacia dónde van, qué es lo que quieren conseguir.</p>

<h3>Escuchar</h3>

<p>Se escriben Historias de Usuario (las cuales son el corazón de la planificación
en un proyecto XP).</p>

<p>El proyecto se divide en iteraciones o sprints.</p>

<p>Al final de cada iteración, se realiza una pequeña entrega de funcionalidades.</p>

<p>Se crean tres niveles de planificación:</p>

<ul>
<li>Release plan: mira hacia el futuro unos cuantos meses y agrupa historias
en grandes entregas.</li>
<li>Next Iteration plan: se agrupan las historias que se van a realizar en
la próxima iteración.</li>
<li>Current Iteration plan: las historias definidas para esta iteración se
dividen hasta que se encuentran tareas que se pueden acometer fácilmente.
Los planes se toman como algo vivo, no como algo estático. Si el cliente
cambia de idea, se cambian los planes. Si el equipo se retrasa en una entrega,
se cambian los planes.</li>
</ul>


<p>Se intenta conseguir un Ritmo Sostenible.</p>

<p>Cada dia comienza con un Stand-up Meeting.</p>

<p>Se mide la Velocidad del Proyecto.</p>

<p>Se favorecen los Espacios Abiertos y se fomenta la Movilidad de las Personas.</p>

<h3>Diseñar</h3>

<p>Simplicidad, se busca siempre lo más sencillo posible. Para poder mostrárselo
al cliente lo antes posible y obtener feedback.</p>

<p>Siempre se usa una Metáfora del Sistema, se busca usar el lenguaje propio
del negocio, la jerga que se usa en el entorno para el cual se está
desarrollando el software.</p>

<p>Se crean Spikes, para reducir riesgos.</p>

<p>Ninguna funcionalidad se añade prematuramente (yagni).</p>

<p>Se Refactoriza en cualquier momento y en cualquier lugar que sea posible.</p>

<p>Se usan Tarjetas CRC para las decisiones de diseño. Así, todos los miembros
del equipo entienden y contribuyen al diseño.</p>

<h3>Codificar</h3>

<p>El cliente siempre está disponible para resolver dudas sobre el software.</p>

<p>El código se escribe siguiendo unos Estándares consensuados por el equipo.</p>

<p>Primero, se escriben los Tests Unitarios, luego el código de producción.</p>

<p>Todo el código de producción se escribe mientras se Programa por Parejas.</p>

<p>Se Integra Frecuentemente, mejor con Integración Contínua.</p>

<p>El código es de todos, Collective Ownership.</p>

<h3>Testear</h3>

<p>En un proyecto XP, los programadores toman la actitud de ser ellos quien
demuestran al cliente que los requisitos funcionan, y no al revés, no es
el cliente quien demuestra que lo que pidió no funciona.</p>

<p>Todo el código debe tener Tests Unitarios. Y todos los tests pasan antes
de sacar una versión.</p>

<p>Cuando se encuentra un bug, se crea un test para reproducirlo, arreglarlo,
y que nunca vuelva a salir una versión con ese bug.</p>

<p>Se escriben Tests de Aceptación. Se ejecutan frecuentemente y su puntuación
se hace pública.</p>

<h2>Valores</h2>

<p>XP mejora un proyecto software en cinco aspectos fundamentales, que se han
convertido en los valores de XP. Las reglas que acabamos de ver son consecuencia
de maximizar estos valores.</p>

<ul>
<li>Simplicidad: se hace lo que es necesario, pero nada más. No se añade complejidad
extra porque sí. Se avanza a pasos pequeños pero firmes.</li>
<li>Comunicación: todo el mundo es parte del equipo. Siempre que se pueda, la
comunicación es cara a cara.</li>
<li>Feedback: al final de cada iteración se entrega un software ejecutable y
válido. Se demuestra el software pronto y frecuentemente.</li>
<li>Respeto: todo el mundo da y recibe respeto. Los programadores respetan la
experiencia de los clientes y al revés.</li>
<li>Coraje: siempre se dice la verdad sobre las estimaciones y el estado de las
tareas.</li>
</ul>


<h2>Para seguir leyendo</h2>

<ul>
<li><a href="http://www.adictosaltrabajo.com/detalle-noticia.php?noticia=379">Principio de oxidación del software (Spanish)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Barry_Boehm">Barry Boehm</a></li>
<li><a href="http://www.extremeprogramming.org/lessons.html">XP lessons learned</a></li>
<li><a href="http://www.extremeprogramming.org/when.html">When should XP be used</a></li>
<li><a href="http://www.agile-process.org">Agile process</a></li>
<li><a href="http://www.amazon.com/Extreme-Programming-Explained-Embrace-Edition/dp/0321278658">Extreme programming explained</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Escribiendo JavaScript sólido como una roca]]></title>
    <link href="http://rchavarria.github.io/blog/2014/06/26/charla-tecnica-escribe-javascript-como-roca/"/>
    <updated>2014-06-26T20:00:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2014/06/26/charla-tecnica-escribe-javascript-como-roca</id>
    <content type="html"><![CDATA[<p>Hace poco, he visto una charla técnica impartida por
<a href="https://twitter.com/damian">Damian Nicholson</a>
titulada <em>Writing (testable | maintainable | scalable | rock solid) JavaScript</em>,
que traduzco libremente como <em>Escribiendo JavaScript sólido como una roca</em>.</p>

<p>En la charla, Damian analiza varios aspectos de porqué es difícil testear
cierto código JavaScript y finaliza contando su experiencia escribiendo código
para evitar todos esos errores.</p>

<!-- more -->




<iframe src="http://rchavarria.github.io//player.vimeo.com/video/68526881" width="500" height="161" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>


<h3>Consejos</h3>

<p>A lo largo de la charla, Damian suelta unos cuantos pequeños consejos:</p>

<ol>
<li>JavaScript + Unit testing = Good code</li>
<li>Apóyate en los objetos. Según el conferenciante, los objetos te llevarán a
diseñar clases, éstas a agruparlas en módulos, y los módulos a organizar mejor
tus ficheros JavaScript.</li>
<li>Sobretodo, uno debería testear su API pública, aunque no limitarse a ella.</li>
</ol>


<h3>Problemas a la hora de testear código JavaScript</h3>

<p>A través de un sencillo snipet de código, Damian expone algunos de los problemas
más comunes a la hora de escribir código JavaScript que lo hace difícilmente
testeable:</p>

<ul>
<li>Funciones anónimas.</li>
<li>Acoplamiento fuerte con el DOM, por ejemplo en el uso y abuso de ids en elementos
HTML</li>
<li>Hacer llamadas al servidor mezcladas con otra lógica de nuestra aplicación.</li>
<li>Callbacks anidados.</li>
<li>Mezclar código HTML y JavaScript, por ejemplo, excribiendo <em>templates</em> HTML a
fuego en JavaScript.</li>
</ul>


<h3>Su propia experiencia</h3>

<ul>
<li>usar data-attributes para parametrizar, o configuraciones. Depender menos de ids
en los elementos HTML.</li>
<li>Conocer el ciclo de vida de los frameworks que utilizamos, y <em>engancharnos</em> a los
eventos del ciclo que dirigen el proceso.</li>
<li>Aislar nuestra aplicación de los detalles de plugins de terceros (gran consejo éste).</li>
<li>Apóyate en <a href="http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension">mixins</a>.
Con ellos podrás extender la funcionalidad de tus objetos, de una forma parecida a
la herencia, aunque muy diferente a ella.</li>
<li>Mantén funcionalidades privadas en ámbitos privados
(patrón <a href="http://www.codeproject.com/Articles/247241/Javascript-Module-Pattern">módulo</a>).</li>
</ul>


<h3>Conclusión</h3>

<p>Es una charla eminentemente práctica, por lo que es totalmente recomendable
si quieres conocer de primera mano buenos consejos sobre cómo escribir código
JavaScript testeable.</p>

<p>No estoy de acuerdo en todos los consejos que comenta Damian, pero la voz de
la experiencia tiene muchísimo valor, por lo que la charla me parece fenomenal.</p>
]]></content>
  </entry>
  
</feed>
