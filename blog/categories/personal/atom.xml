<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: personal | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/personal/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2018-02-18T10:39:45+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Practical Object-Oriented Design in Ruby]]></title>
    <link href="http://rchavarria.github.io/blog/2018/01/17/practical-object-oriented-design-in-ruby/"/>
    <updated>2018-01-17T22:03:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2018/01/17/practical-object-oriented-design-in-ruby</id>
    <content type="html"><![CDATA[<h5>de Sandi Metz</h5>

<p><img class="left" src="/images/2018/poodr.jpg" width="250" height="323"></p>

<h3>Por qué lo he leído</h3>

<p>Éste es un libro que lo recomienda mucha gente cuando se habla de <em>programación
orientada a objetos</em>, es muy mencionado en conversaciones por twitter y el
mundo online. Pero la guinda del pastel vino cuando ví que lo recomendaba
<a href="https://twitter.com/carlosble">Carlos Blé</a> en su blog. Entonces supe que era una lectura obligada.</p>

<!-- more -->


<h3>De qué trata el libro</h3>

<p>Va sobre programación orientada a objetos. Normalmente, al hablar de POO, no se
avanza mucho más allá de herencia y polimorfismo. Sandi va muchos pasos más
allá. Explica la POO desde un punto de vista un poco diferente, donde los
objetos no son el centro del paradigma, si no los mensajes que se intercambian
entre ellos.</p>

<p>Por supuesto, el libro también habla de herencia, de cuándo usarla y cuándo no.
Habla de composición, comparándola con la herencia. Y habla de otras formas de
reutilizar o compartir el código.</p>

<p>Por último, habla sobre cómo gestionar los tests de nuestra aplicación
manteniendo unos costes de desarrollo bajo control.</p>

<h3>Conclusiones y valoración</h3>

<p>Es curioso que para describir el paradigma de la programación orientada a
objetos no se centre en objetos, si no en los mensajes que deben pasarse entre
ellos. Es un cambio de punto de vista, y me gustaría poder interiorizarlo
fácilmente, pero no me resulta así. Es un esfuerzo que debo hacer y que seguro
que merecerá la pena.</p>

<p>Aunque centrado en Ruby, describe otras formas de reutilizar código aparte de
la herencia y la composición. Les llama módulos, o roles. En otros lenguajes
existen conceptos similares, como los <em>traits</em> en PHP o los <em>mixins</em> en
JavaScript. No creo que se puedan aplicar a todos los lenguajes de
programación, pero si a la mayoría de los lenguajes dinámicos.</p>

<p>En cuanto a la valoración, coincido con muchísima gente: este libro puede ser
un antes y un después en la comprensión de la Programación Orientada a
Objectos, sobre todo por el punto de vista tan diferente a la hora de
entenderla. Envío de mensajes, envío de mensajes, envío de mensajes,...</p>

<h3>Qué he aprendido</h3>

<p>Impresionante ver cómo refactoriza una herencia a una composición de objetos:
engloba una colección de objetos en una nueva clase, crea una factoría que crea
cada una de las partes, simplifica las partes como dadas de configuación. De
esta forma, añadir un nuevo tipo no requiere una nueva clase, solamente nueva
configuración</p>

<p>Diseñar basado en mensajes crea aplicaciones más flexibles que diseñar pensando
en objetos. En lugar de preguntarte: tengo un objeto ¿qué debería hacer?,
deberías preguntarte tengo un mensaje, ¿a quién se lo envío? No hay que
centrarse en los objetos de dominio, si no en los mensajes que se pasan entre
ellos.</p>

<p>Eligiendo relaciones (herencia, roles/<em>duck typing</em>, composición)</p>

<ol>
<li>Herencia para relaciones <em>es-un</em> (is-a). Especialmente si la jerarquía es
estrecha y tiene pocos niveles</li>
<li>Role/duck type para relaciones <em>se-comporta-como</em> (behaves-like-a). Donde
varios objetos no relacionados se quieren comportar del mismo modo</li>
<li>Composición para relaciones <em>tiene-un</em> (has-a). Un objeto tiene varias
partes pero es más que la suma de ellas, si no sería una colección y ya está</li>
</ol>


<p>Para obtener el máximo valor de los tests, hay que tener el mínimo de ellos.
Para ello, hay que testear cada cosa una sola vez, y en el lugar apropiado.</p>

<ol>
<li>Mensajes entrantes tipo <em>query</em> hay que testear el <strong>estado</strong> que devuelven</li>
<li>Mensajes salientes tipo <em>command</em>, hay que testear que son llamados, cuantas
veces y con qué parámetros</li>
<li>Mensajes salientes tipo <em>query</em>, no se testean (ya los testearán los tests
de otro objeto)</li>
</ol>


<h3>Frases que me gustaría recordar</h3>

<blockquote><p>Siempre existe una tension entre mejorarlo ahora o mejorarlo después. Un buen
diseñador sabe minimizar los costes tomando decisiones valorando lo que sabe
ahora y lo que sabrá en el futuro, porque nunca sabrás menos de lo que sabes
hoy</p></blockquote>

<!-- more -->


<blockquote><p>Gestiona la dirección de las dependencias: depende de cosas que cambien menos
frecuentemente que tú. Para conocer las dependencias más interesantes nos
fijamos en 3 aspectos: probabilidad del cambio, nivel de abstracción y número
de dependencias (sobretodo de la 1ª y 3ª)</p></blockquote>

<!-- more -->


<blockquote><p>Las cosas que una clase conoce conforman su <strong>contexto</strong>, lo cual tiene un
efecto directo en lo fácil o difícil que es reusar (y por tanto testear) esa
clase</p></blockquote>

<!-- more -->


<blockquote><p>Para que una herencia funcione, debe de haber una relación de
generalización-especialización, donde la especialización sea todo lo general
y algo más</p></blockquote>

<!-- more -->


<blockquote><p>La regla general de refactorizar a una herencia es colocar el código de tal
forma que haya que promocionar abstracciones a las superclases, en lugar de
<em>rebajar</em> concrecciones a las subclases</p></blockquote>

<!-- more -->


<blockquote><p>Si hay código que pregunta por el tipo de un objeto para enviar un mensaje u
otro, estamos necesitando <em>duck typing</em>, una abstracción. Cuando además del
interfaz (<em>duck type</em>) necesitamos compartir comportamiento, necesitamos un
<em>role</em> (módulo, trait, mixing,...)</p></blockquote>

<!-- more -->


<blockquote><p>La composición es otra forma de organizar el código donde cada parte es más
independiente, pero no tenemos delegacion automática de mensajes, si no que
hay que hacerlo de forma explícita</p></blockquote>

<!-- more -->


<blockquote><p>Código creado con composición es <em>transparente</em> (T de <em>true</em>), suelen ser
clases pequeñas con una única responsabilidad y suele ser fácil entenderlas.
Son <em>usables</em> (U de <em>true</em>) porque son pequeños y enfocados. Son <em>razonables</em>
(R de true) porque se pueden extender sin modificar</p></blockquote>

<h3>Recursos relacionados</h3>

<ul>
<li>El resto de <a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/practical-object-oriented-design-ruby-by-sandi-metz.markdown">notas sobre POODR</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[99 bottles of OOP]]></title>
    <link href="http://rchavarria.github.io/blog/2017/10/19/99-bottles-oop/"/>
    <updated>2017-10-19T22:06:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/10/19/99-bottles-oop</id>
    <content type="html"><![CDATA[<h5>de Sandi Metz y Katrina Owen</h5>

<p><img class="left" src="/images/2017/99-bottles-of-oop.jpg" width="250" height="323"></p>

<h2>Por qué lo he leído</h2>

<p>No conozco personalmete a ninguna de las 2 autoras, pero soy un fan de Sandi y
colaboro en un proyecto open source de Katrina, ¿cómo no iba a leer
<a href="https://www.sandimetz.com/99bottles">99 bottles of OOP</a>?</p>

<p>Ya había leído con anterioridad el libro de Sandi, <a href="http://www.poodr.com/">Programming OODR</a> y me
gustó muchísimo, así que este libro prometía. También había visto alguna charla
de Katrina sobre refactorizaciones, y me asombraron muchísimo, por su claridad
y por su calidad.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>Considero que ambas autoras son un referente en el mundo del desarrollo de
software, por lo que esperaba que el libro me enseñara nuevos temas o ideas
sobre los que aprender y profundizar.</p>

<p>Según había escuchado en algunas entrevistas a las autoras, el libro basa sus
<em>enseñanzas</em> en un caso real, solucionando un problema sencillo, ideal para
realizar en katas, por lo que esperaba que todos los conceptos serían fáciles
(o al menos más fáciles) de entender ya que estarían ilustrados con código real
y ejecutable (mira, como si fueran tests).</p>

<h2>Qué encontre</h2>

<p>Encontré la historia de una refactorización. Sandi y Katrina exponen primero
varias formas de resolver un problema, en principio sencillo, y después van
desgranando una de ellas. Poco a poco, cambio a cambio, refactorización a
refactorización, van cambiando el código hacia una solución muy pulida.</p>

<p>Es impresionante ver cómo van justificando cada cambio. Es como leer tus
propios pensamientos, pero un paso más allá. Muchos de los cambios que proponen
parecen de perogrullo, pero muy pocas veces me he parado a pensar por qué me
parecen así. Es como si racionalizaran el instinto del programador.</p>

<h2>Conclusiones</h2>

<p>Es impresionante cómo va describiendo la refactorización línea a línea. Elimina
multitud de code smells, muchas veces de línea en línea, apoyándose en tests.
Es una gozada ver cómo va quedando el código</p>

<p>(...) es un acto de bondad hacia el lector de tu código. El código que revela
su intención está construido en base a la acumulación de actos así de
intencionados. Programa intencionadamente (escribe un <code>case</code> en lugar de un
<code>if</code> para indicar que las condiciones están relacionadas). <strong>Es una pasada como
el libro racionaliza estas decisiones y las explica</strong></p>

<p>Resulta interesante cómo nombra las cosas, conceptos, clases, variables,...
Nombrado es una de las cosas más difíciles en Computer Science.</p>

<h2>Qué he aprendido</h2>

<p>Una forma de ser mejor identificando olores en el código es practicar
describiendo las características del código, tomando nota de las cosas que te
llaman la atención: incluye cualquier patrón que veas, y cosas que te gustan,
odias o que simplemente no entiendes.</p>

<p>Si el código no está abierto a modificaciones y no sabes por dónde empezar...
empieza eliminando olores en el código. No sabes cómo hacer que el código esté
abierto a modificaciones, así que empiezas a eliminar olores, con la esperanz
de encontrarlo por el camino</p>

<p>Los programadores habilidosos hacen lo correcto cuando intuyen la verdad.
Cuando no la intuyen, se embarcan en experimentos cuidadosos, precisos,
reproducibles y reversibles.</p>

<p>Los atajos demasiado inteligentes son una falsa economía. Invierte en código
que diga la verdad. Simplemente escríbelo. Di no a los atajos, di no a las
chapuzas y ñapas.</p>

<p>Unos consejos que podrían resumir el libro completo serían: busca la
simplicidad, no crees abstracciones demasiado pronto, enfócate en los olores
del código, anda en pasos pequeños, sigue las <em>Flocking rules</em>, refactoriza
siempre en verde, arregla los problemas sencillos primero, trabaja
horizontalmente (cambios horizontales, nunca verticales), buscar puntos de
estabilidad, sé disciplinado, no persigas las cosas brillantes/famosas/de moda</p>

<h2>Frases que me gustaría recordar</h2>

<blockquote><p>Escribir código es el proceso de encontrar el camino hasta el siguiente punto
estable, no el punto final en sí mismo. No es el resultado final, si no el
camino.</p></blockquote>

<!-- more -->


<blockquote><p>El código como el método <code>pluralize</code> (que devuelve <code>bottle</code> o <code>bottles</code>
dependiendo de un número) se escribe cuando los programadores se llevan el
principio DRY al extremo. Cuando te encuentres en una situación como esta,
hazte las siguientes preguntas. Estas mismas preguntas también te ayudarán a
saber si tu código es bueno o costoso.</p></blockquote>

<ol>
<li>El cambio que voy a hacer, ¿hace el código más difícil de entender? Cuando
las abstraciones son las correctas, el código es fácil de entender.</li>
<li>¿Cuál es el coste futuro de no hacer nada ahora? Si no hacer nada no
incrementa los costes, retrasa los cambios.</li>
<li>¿Cuando llegará ese momento?, o ¿cuánto tardaré en obtener más información?
Tolera pacientemente la duplicación si haciéndolo te ayuda a descubrir la
abstracción correcta.</li>
</ol>


<!-- more -->


<blockquote><p>Kent Beck describe diferentes formas de hacer que tus tests pasen. 3 de sus
<em>Green Bar Patterns</em> son:</p></blockquote>

<ol>
<li>Fake It ("Til You Make It"): este estilo de TDD puede parecer extraño y
tedioso, pero con práctica puede llegar a ser natural y rápido</li>
<li>Obvious Implementation: cuidado con ir directamente a la solucion obvia, te
puede llevar por el camino equivocado. Desarrollar el hábito de escribir
solamente el código suficiente para hacer que el test pase te fuerza a escribir
mejores tests.</li>
<li>Triangulate: dirigir las abstracciones conservativamente con los tests. La
triangulación requiere escribir varios test de una sola vez, lo que
significa que tendrás varios test fallando simultáneamente. La idea es escribir
el código necesario para hacer que todos esos tests pasen de forma simultánea.</li>
</ol>


<!-- more -->


<blockquote><p>Hacer que el código existente esté abierto a nuevos requisitos requiere
normalmente de identificar y nombrar abstracciones. Las <em>Flocking Rules</em> se
centran en hacer que las diferencias parezcan similitudes, y por eso son una
herramienta muy útil para descubrir abstracciones. Las Flocking Rules
seleccionan las cosas más parecidas, encuentran la menor diferencia entre ellas
y hacen el cambio más simple para eliminar esa diferencia (evalúa el código,
evalúa y ejecuta, evalúa y usa el código, evalúa, y finalmente borra el código
no usado)</p></blockquote>

<!-- more -->


<blockquote><p>Cuando estés sufriendo por encontrar un buen nombre pero sólo tienes unas
cuantas ocurrencias para guiarte, puede ser de ayuda imaginarte otras cosas que
podrían encajar en la misma catergoría, y luego construir una tabla con los
conceptos.</p></blockquote>

<!-- more -->


<blockquote><p>El Principio de Sustitución de Liskov también aplica a los tipos dinámicos (o
<em>duck types</em>). Las violaciones de Liskov fuerzan a los que envían mensajes a
tener conocimiento sobre varios tipos devueltos, y tratar con ellos de forma
distinta o convertirlos en algo consistente.</p></blockquote>

<!-- more -->


<blockquote><p>No todos los condicionales son malos en la Programación Orientada a Objectos,
hay un lugar para ellos. Algún objeto, en algún lugar, debe elegir qué objetos
crear para las composiciones, y eso normalmente involucra condicionales.</p></blockquote>

<!-- more -->


<blockquote><p>Tener un <strong>data clump</strong> significa normalmente que estás necesitando un
concepto. Cuando esta acumulación se envía como un conjunto de parámetros, el
método que recibe el <em>clump</em> se puede ver inundado con facilidad con lógica
para gestionarlo. Alguna de esta lógica inevitablemente acabará duplicándose en
distintos lugares. Si dos cosas aparecen siempre juntas, es una señal de que
esa pareja representa un concepto más profundo y que necesitamos darle un
nombre.</p></blockquote>

<!-- more -->


<blockquote><p>Los programadores añaden líneas en blanco para acentuar cambios en la temática.
La presencia de múltiples temas sugiere la existencia de múltiples
responsabilidades, lo que hace el código más difícil de entender y leer,
mientras que hace más fácil causar daños cuando haya que hacer algún cambio.</p></blockquote>

<!-- more -->


<blockquote><p>El truco para avanzar usando cambios de una sola línea es alterar temporalmente
la factoría para tolerar varios tipos de entrada. A veces, a la hora de cambiar
condicionnales con polimorfismo, hay momentos en los que algún código debe
soportar varios tipos, hasta que todo el código está adaptado. Especialemente,
si vamos haciendo cambios de una sóla línea</p></blockquote>

<!-- more -->


<blockquote><p>Corregir violaciones de Liskov es importante, porque en lenguajes orientados a
objetos (sobretodo los tipados dinámicamente), se basan en la confianza
explícita en los contratos implícitos entre los objetos. Se trabaja muy bien
con objetos de confianza, porque siempre se comportan como se espera de ellos.
Los objetos que a veces fallan en responder a un mensaje que les envías, o que
ocasionalmente devuelven algo que no esperas, son un dolor, y requieren que los
objetos que les llamen deban conocer demasiadas cosas.</p></blockquote>

<h2>Recursos relacionados</h2>

<ul>
<li>El libro en sí: <a href="https://www.sandimetz.com/99bottles">99 bottles of OOP</a></li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/99-bottles-by-sandi-katrina.notes.markdown">Notas sobre 99 bottles of OOP</a></li>
<li>Nuevo libro, <a href="foo/bar/bar/foo.html">Refactoring to patterns</a>, de Joshua Kerievsky, donde habla de
<em>Gradual Cutover Refactoring</em></li>
<li>Las autoras: <a href="https://www.sandimetz.com/">Sandi Metz</a> y <a href="http://www.kytrinyx.com/">Katrina Owen</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The nature of software developent]]></title>
    <link href="http://rchavarria.github.io/blog/2017/03/05/the-nature-of-software-developent/"/>
    <updated>2017-03-05T16:06:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/03/05/the-nature-of-software-developent</id>
    <content type="html"><![CDATA[<h5>de Ron Jeffries</h5>

<p><img class="left" src="https://imagery.pragprog.com/products/363/rjnsd.jpg?1409862136" width="260" height="392" title="The nature of software development" ></p>

<h2>Por qué lo he leído</h2>

<p>Como casi todos los libros, por recomendación. Ví que lo recomendaba
<a href="https://carlosbuenosvinos.com/">Carlos Buenosvinos</a>, y no pude resistirme. Además, el autor es una leyenda
viva del desarrollo del software y del manifiesto Agile, así que tenía que ser
un libro de aúpa.</p>

<p>¿Un libro que trata sobre la <strong>naturaleza</strong> de la profesión a la que te
dedicas? A leerlo casi, casi, sin pensarlo.</p>

<!-- more -->


<h2>Qué esperaba y qué encontré</h2>

<p>Esperaba un libro largo, pesado. Tipo como una biblia o enciclopedia. Un
compendio de mejores prácticas, de leyes no escritas, los 101 mandamientos del
desarrollo del sofware.</p>

<p>De eso nada. <a href="https://pragprog.com/book/rjnsd/the-nature-of-software-development">The nature of sofware development</a> es un libro que se lee con una
facilidad pasmosa. Es increíble como <a href="http://ronjeffries.com/">Ron Jeffries</a> simplifica hasta los
conceptos más complejos de explicar. Hace que el proceso de desarrollo que él
explica parezca el único que debe existir, el natural, al que se debería tender
si dejáramos que las fuerzas actuaran solas (tipo naturaleza, no sé si se me
entiende la metáfora).</p>

<p>Es un libro relativamente corto, con muchas (y muy buenas) ilustraciones.
Dividido en capìtulos digeribles muy fácilmente. Un lenguaje llano, sencillo,
pero preciso.</p>

<h2>Conclusiones</h2>

<p>Por supuesto que es un libro donde se describe muchas mejores prácticas. A mí
me parece que describe el ideal de cómo se debería desarrollar un proyecto
software. Casi tan bueno, que me parece un sueño.</p>

<p>Es un libro que recomendaría leer a todo aquel que su trabajo esté relacionado
con cualquier fase en el desarrollo del software: diseño, programador, dueño de
producto,...</p>

<h2>Qué he aprendido</h2>

<blockquote><p>Las cosas van mejor si cada funcionalidad, también llamada <em>historia</em>, sólo
tardamos <strong>dos o tres</strong> días en implementarla.</p></blockquote>

<p>Coincido totalmente con esa visión. La sufro cada día. Si algo dentro del
equipo nos lleva más de 2/3 días, comenzamos a perder el foco, empiezan a
aparecer pequeñas tareas (pues ya que...) que nos hacen desviarnos del objetivo
inicial. Y al final, se hace muy difícil dar una historia por zanjada. Si
dividimos el trabajo en pequeñas historias entregables y que podamos
materializar en menos de 3 días, todo va mejor la mayor parte del tiempo.</p>

<blockquote><p>Para obtener la mejor calidad, un progreso continuado y una gran
predictabilidad, los tests y las refactorizaciones son la mejor forma
conocida de trabajar.</p></blockquote>

<!-- split -->


<blockquote><p>Necesitamos un progreso constante, regular e ininterrumpido. Para mantener un
progreso ininterrumpido, necesitamos un diseño claro y limpio todo el tiempo.
Y para conseguirlo, necesitamos refactorizar nuestro código.</p></blockquote>

<p>Dos grandes pilares del desarrollo: <strong>tests</strong> y <strong>refactorizaciones</strong></p>

<h2>Frases que quiero recordar</h2>

<blockquote><p>Valor es lo que uno quiere</p></blockquote>

<!-- split -->


<blockquote><p>Un experto excelentemente remunerado no debería ser remunerado solamente
porque es un experto. Debería ser excelentemente remunerado por ayudar a
otras personas a que se conviertan en expertos.</p></blockquote>

<!-- split -->


<blockquote><p>El estilo de <em>funcionalidad a funcionalidad</em> incluye un ciclo completo de
desarrollo en cada iteración: requisitos, diseño, codificación y testeo.</p></blockquote>

<!-- split -->


<blockquote><p>Podemos construir todo el diseño primero, o podemos construir cada
funcionalidad completamente de una en una, cada una con su base. Lo que no
podemos hacer es construir toda la base al principio, así como tampoco
podemos construir todas las funcionalidades al principio. Es de lejos mucho
más seguro construir una versión simple pero funcional de cada funcionalidad
primero.</p></blockquote>

<!-- split -->


<blockquote><p>Trabajamos incrementalmente. Necesitamos un buen diseño relativamente pronto,
pero solo necesitamos un <strong>pequeño</strong> buen diseño.</p></blockquote>

<!-- split -->


<blockquote><p>Toma cada posible idea como una posible forma de comenzar a hacer cosas
durante un tiempo. Luego, haz tuyo el proceso, y construye tus propias ideas.
¡Pero mantenlo simple!</p></blockquote>

<!-- split -->


<blockquote><p>Nuestro trabajo no es ceñirnos al plan, es ir corrigiendo el curso para
obtener el mejor resultado, no llegar a algún punto fijo.</p></blockquote>

<!-- split -->


<blockquote><p>Lo hacemos mejor no cuando predecimos cuándo habremos terminado, si no cuando
elegimos cuándo está terminado (pero es que debemos mantenernos siempre en un
estado de <em>terminado</em> de forma constante)</p></blockquote>

<!-- split -->


<blockquote><p>La palabra refactorizar se refiere al proceso simple y regular de mantener el
código limpio. Cuando la carretera se convierte en un camino intrincado, lo
enderezamos refactorizando el código.</p></blockquote>

<h2>Referencias</h2>

<ul>
<li><a href="https://vimeo.com/79106557">The fundamental theorem of Agile Software Development</a>, de J.B.Rainsberger</li>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/the-nature-of-software-development-by-ron-jeffries.markdown">Notas sobre The nature of Software development</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Practical Vim]]></title>
    <link href="http://rchavarria.github.io/blog/2016/07/17/practical-vim/"/>
    <updated>2016-07-17T23:15:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/07/17/practical-vim</id>
    <content type="html"><![CDATA[<h6>de Drew Neil</h6>

<h3>Por qué lo he leído</h3>

<p><img class="left" src="https://raw.githubusercontent.com/rchavarria/blog-post-incubator/master/published-book-notes/img/practical-vim.jpg"></p>

<p>Hace un tiempo decidí que quería <a href="http://rchavarria.github.io/blog/2014/10/11/aprendiendo-vim/">aprender a utilizar Vim</a>. Entre los muchos
recursos para aprender se encontraba este libro, pero encontré más prácticos
una serie de videos. Pero más adelante, escuchando el podcast <a href="http://giantrobots.fm/">Giant Robots</a>,
hablaron de este libro, y cuando recibes varias señales, quiere decir algo.</p>

<!-- more -->


<h3>De qué trata el libro</h3>

<p>El libro no es un manual desde cero. Tampoco es un manual avanzado. Es un
conjunto de trucos, de sugerencias, que trata de explicar y convencer al lector
de la filosofía y bondades del editor. Entre estos trucos encontrarás muchos
que te sean de utilidad, y otros tantos tan extraños que ni te molestarás en
entenderlos. Pero lo más importante es que describe una <em>forma de pensar en
Vim</em>. A la hora de editar ficheros de texto no hay una única forma de hacer las
cosas, ni tampoco una forma superior a otras alternativas, pero en Vim sí que
hay una filosofía, una idea de atacar cada edición. Este libro te sumerge en
ella.</p>

<h3>Conclusiones y valoración</h3>

<p>El libro es una maravilla. Está lleno de trucos. Muchos de ellos los conocía, y
otros ni siquiera sabía que existían. En cambio, otros, después de llevar un
tiempo usando Vim, tenía una ligera sospecha de que se podrían hacer, pero no
había invertido el tiempo en averiguar cómo.</p>

<p>Si tienes ganas de incarle el diente a un editor que sobrevive al paso del
tiempo, échale un vistazo al libro.</p>

<p>Debería echar un vistazo al proyecto de Mozilla <a href="https://github.com/mozilla/doctorjs">Doctor JS</a>, que contiene la
herramienta <code>jsctags</code>, para generar ficheros ctags de proyectos JavaScript.</p>

<h3>Frases que me gustaría recordar</h3>

<blockquote><p>La fórmula del punto: una pulsación de tecla para mover, una pulsación de
tecla para ejecutar la edición</p></blockquote>

<!-- -->


<blockquote><p>La estrategia óptima de edición es hacer que tanto el cambio como el
movimiento sean repetibles</p></blockquote>

<!-- -->


<blockquote><p>Podemos hacer que el comando deshacer opere en palabras, frases o párrafos
enteros solamente haciendo un uso corrrecto de la tecla <code>Esc</code></p></blockquote>

<!-- -->


<blockquote><p>La combinación de operadores con movimientos forman una especie de gramática.
Aprender nuevos movimientos y operadores is como aprender el vocabulario de
Vim. Si seguimos las reglas sencillas de la gramática, podremos expresar más
y mejores ideas según vaya creciendo nuestro vocabulario</p></blockquote>

<!-- -->


<blockquote><p>Una buena forma de trabajar con macros sería: normalizar la posición del
cursor, llegar hasta el objetivo con un movimiento repetible, hacer que la
macro aborte cuando el movimiento falle y no encuentre el objetivo</p></blockquote>

<!-- -->


<blockquote><p>La sintaxis para definir un rango en los Ex commands es muy flexible. Se
pueden mezclar números de línea, marcas y patrones de búsqueda. Y se puede
aplicar un offset a cada uno de ellos</p></blockquote>

<!-- -->


<blockquote><p>Intenta crear el hábito de crear una marca global (<code>m{capital letter}</code>) antes
de usar cualquier comando que interacciones con la lista de arreglos rápidos,
lista de buffers o lista de argumentos</p></blockquote>

<!-- -->


<blockquote><p>Para editar una macro grabada en el registro <code>q</code>, simplemente podemos pegar
el contenido de dicho registro con <code>"qy</code>, editar la línea y modificar el
registro <code>q</code> con <code>"qy$</code></p></blockquote>

<h3>Qué he aprendido</h3>

<p>Hay toda una serie de nuevos comandos, combinaciones de ellos y herramientas
que todavía no conocía o que he encontrado muy útiles:</p>

<ul>
<li><code>~</code>: intercambia el carácter actual de mayúsculas a minúsculas y viceversa</li>
<li><code>g~</code>, <code>gu</code>, <code>gU</code>: intercambia mayúsculas/minúsculas en la selección, pasa a minúsculas, pasa a mayúsculas, respectivamente.</li>
<li><code>&lt;C-h&gt;</code>, <code>&lt;C-w&gt;</code>, <code>&lt;C-u&gt;</code>: en modo inserción o modo comando, borra hacia atrás un carácter, una palabra o la línea completa, respectivamente.</li>
<li><code>&lt;C-r&gt;{register}</code>: en modo inserción, inserta el texto desde el registro <code>register</code></li>
<li><code>&lt;C-r&gt;&lt;C-p&gt;{register}</code>: idem, pero más inteligentemente, ya que arregla cualquier error de indentación por descuido</li>
<li><code>&lt;C-v&gt;{code}</code>: en modo inserción, inserta un carácter especial por su código <code>code</code></li>
<li><code>R</code>: nos lleva del modo normal al <em>modo de reemplazo</em>, donde cada carácter insertado reemplaza a un carácter existente</li>
<li><code>v</code>, <code>V</code>, <code>&lt;C-v&gt;</code>: entra en los distintos modos visuales: de carácter, de línea o de bloque.</li>
<li><code>o</code>: dentro del modo visual, la selección tiene dos extremos, con este comando intercambiamos entre ellos, de forma que podemos expandir la selección hacia adelante o hacia atrás</li>
<li><code>.</code>, <code>%</code>: en el modo comando tienen significado especial cuando se especifica un rango. Significan la línea actual y todas las líneas, respectivamente.</li>
<li><code>:t</code>: comando para duplicar líneas. <code>:3t 5</code> copia la línea 3 y la pega en la 5. <code>:.+2t .</code> copia dos líneas más abajo y la pega en la línea actual</li>
<li><code>:m</code>: comando para mover líneas</li>
<li><code>@:</code>: repite el último Ex Command, lo cual es muy útil cuando estamos haciendo cambios en múltiples ficheros, o vamos recorriendo la lista de búferes</li>
<li>en modo comando, se pueden ejecutar comandos del modo normal, con el Ex Command <code>normal</code>. Por ejemplo, <code>:%normal A;</code> hace lo siguiente: <code>:</code> entramos en modo comando, <code>%</code> indica que afectará a todas las líneas del fichero, <code>normal</code> indica que introduciremos un comando del modo normal, <code>A;</code> es un comando del modo normal, y lo que hace es añadir al final de la línea el carácter <code>;</code>.</li>
<li><code>&lt;C-o&gt;</code>: vuelve atrás en la lista de saltos (cambios de buffer, grandes saltos de líneas, búsquedas,...)</li>
<li><code>&lt;Tab&gt;</code>, <code>&lt;C-n&gt;</code>, <code>&lt;Left&gt;</code> y <code>&lt;S-Tab&gt;</code>, <code>&lt;C-p&gt;</code>, <code>&lt;Right&gt;</code>: para movernos adelante y atrás durante el autocompletado</li>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code>: en modo comando, copia la palabra debajo del cursor y la pega en la línea de comandos</li>
<li><code>&lt;C-p&gt;</code>, <code>&lt;C-n&gt;</code>: después de entrar en el modo comando con <code>:</code> o <code>/</code>, podemos pulsarlos para ir hacia adelante o atrás en el historial de comandos o búsquedas</li>
<li><code>q/</code>: abre la ventana <em>línea de comandos</em> con el historial de búsquedas</li>
<li><code>q:</code>: abre la ventana <em>línea de comandos</em> con el historial de comandos</li>
<li><code>&lt;C-f&gt;</code>: en modo comando, cambia a la ventana de línea de comandos</li>
<li><code>:read !{shell command}</code>: pone el resultado del comando shell en el buffer actual</li>
<li><code>:write !{shell command}</code>: usa el contenido del buffer actual como entrada para el comando shell</li>
<li><code>:bnext</code>, <code>:bprevious</code>, <code>:bfirst</code>, <code>:blast</code>: para moverse por los buffers</li>
<li><code>:edit {path to a dir}</code>: abre el contenido del directorio en un buffer, de forma que podemos navegar el sistema de ficheros sin necesidad de ningún plugin. <code>.</code> significa el actual directorio de trabajo. <code>:explore</code> o <code>:E</code> hace lo mismo. <code>:Sexplore</code> divide los buffers horizontalmente, <code>:Vexplore</code> divide los buffers verticalmente</li>
<li>igual que existen <code>w</code>, <code>b</code>, <code>e</code> y <code>ge</code> (mueve al final de la palabra anterior), existen <code>W</code>, <code>B</code>, <code>E</code> y <code>gE</code> para hacerlo con PALABRAS, no con palabras</li>
<li><code>is</code>, <code>as</code>, <code>ip</code>, <code>ap</code>: son movimientos (que se pueden usar con los comandos <code>d</code>, <code>c</code>, <code>y</code>,...) que engloban la actual frase (sentencia) o párrafo</li>
<li><code>&lt;C-o&gt;</code>, <code>&lt;C-i&gt;</code>: para movernos adelante y atrás en los saltos que vamos dando</li>
<li><code>:changes</code>: muestra el historial de cambios</li>
<li><code>g;</code>, <code>g,</code>: para movernos adelante y atrás por el historial de cambios</li>
<li><code>gi</code>: vuelve al último punto donde abandonamos el modo de inserción, entrando en dicho modo</li>
<li><code>"_d{motion}</code>: borra lo indicado pero no copia el contenido en ningún sitio (bueno, sí, en el registro <code>_</code>, pero éste no guarda el contenido). Si no se indica nada, los comandos <code>x</code>, <code>s</code>, <code>d</code> y <code>c</code> modifican el registro sin nombre, con lo que pueden eliminar el contenido que hayamos copiado con <code>y</code>.</li>
<li>el registro de copiado es el <code>0</code>, y éste no es modificado nunca por los comandos <code>x</code>, <code>s</code>, <code>d</code> y <code>c</code>.</li>
<li>si al copiar o borrar nombramos un registro con mayúsculas, el contenido se añadirá a lo que contenga el registro</li>
<li><code>\v</code>: activa la magia en los patrones de búsqueda. Hace que todos los carácteres excepto los alfanuméricos y <code>_</code> tengan un significado especial</li>
<li><code>:%s///gn</code>: cuenta las ocurrencias del patrón actual de búsqueda</li>
<li>flags del comando de sustitución: <code>g</code> reemplaza todas las ocurrencias en una línea, no solo la primera; <code>c</code> pide confirmación, <code>n</code> cuenta las ocurrencias, <code>&amp;</code> reusa los últimos flags</li>
<li><code>:%s//\=@0/g</code>: sustituye todas las ocurrencias (flag <code>g</code>) de todas las filas (rango <code>%</code>) del último patrón buscado (<code>//</code>) con el contenido del registro <code>0</code> (<code>\=</code> evalúa una expresión, <code>@0</code> accede al registro <code>0</code>)</li>
<li><code>&amp;</code>: repite los cambios hechos por el último comando de sustitución <code>:s/pattern/.../</code></li>
<li><code>g&amp;</code>: repite el último comando de sustitución en todo el fichero</li>
<li><code>:vimgrep {pattern} {file pattern}</code>: busca el patrón en la lista de ficheros y rellena la lista <em>quickfix</em>. Luego podemos pasar el resultado a la lista de argumentos con el plugin <em>qargs</em></li>
<li><code>:global/{pattern}/{command}</code> o <code>:g</code>: permite ejecutar un comando en cada línea que cumpla con el patrón</li>
<li><code>&lt;C-]&gt;</code>: mover hasta la definición de la palabra clave (tag) donde se encuentra el cursor</li>
<li><code>&lt;C-t&gt;</code>: vuelve atrás en la última tag visitada</li>
<li><code>:copen</code>, <code>:cclose</code>: abre/cierra la ventana de lista <em>quickfix</em></li>
<li><code>:cnext</code>, <code>:cprevious</code>, <code>:cfirst</code>, <code>:clast</code>: para moverse por los marcadores de la lista quickfix</li>
<li><code>:colder</code>, <code>:cnewer</code>: para pasar de listas quickfix más nuevas a las más viejas y viceversa</li>
</ul>


<h3>Recursos relacionados</h3>

<ul>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/practical-vim-by-drew-neil.markdown">Notas tomadas sobre Practical Vim</a>, y en <a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/practical-vim-by-drew-neil.en.markdown">inglés</a> también</li>
<li>Debería echar un vistazo al proyecto de Mozilla <a href="https://github.com/mozilla/doctorjs">Doctor JS</a>, que contiene la
herramienta <code>jsctags</code>, para generar ficheros ctags de proyectos JavaScript.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Software Craftsman]]></title>
    <link href="http://rchavarria.github.io/blog/2016/03/15/the-software-craftsman/"/>
    <updated>2016-03-15T22:08:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2016/03/15/the-software-craftsman</id>
    <content type="html"><![CDATA[<h6>de Sandro Mancuso</h6>

<p><img class="left" src="http://www.informit.com/ShowCover.aspx?isbn=0134052501" width="230" height="295" title="The Software Craftsman" ></p>

<h3>Por qué lo he leído</h3>

<p>Me encanta programar, me encanta escribir software, escribir código. Me encanta
resolver problemas, puzles. Me encanta la tecnología. Y me encanta hacer las
cosas bien, poner cariño en lo que hago. La ideología de Software Craftsmanship
va de todo esto. Y me gusta la metáfora. Mi padre es carpintero, artesano, y me
gustaría poner el mismo cuidado en mi trabajo que él pone en el suyo. La
excelencia técnica es lo que más me gusta del desarrollo software.</p>

<!-- more -->


<h3>Qué esperaba</h3>

<p>Me esperaba un libro donde se hablara de buenas prácticas, de ningún lenguaje
de programación en particular, si no de todos en general. De qué significa ser
un artesano, de dedicar tu vida a una profesión, de hacer lo que te gusta, de
pasión, de profesionalidad.</p>

<p>Esperaba consejos sobre qué hacer, qué no hacer, a quién considerar un modelo.
¿Una guía paso a paso de cómo ser considerado un craftsman? Nooo, pero sí
muchas acciones que me acercaría a ello.</p>

<h3>Qué encontré</h3>

<p>Todo eso y más. Aparte de todo lo esperado, Sandro tiene muchísimas
<em>batallitas</em> que contar. No solamente encontré conceptos ampliamente aceptados,
también encontré multitud de experiencias personales de una persona que ha
trabajado y trabaja muy duro para hacer de la profesión una profesión mucho
mejor.</p>

<p>Un capítulo interesantísimo es el que trata sobre la historia del Software
Craftsmanship.</p>

<h3>Conclusiones</h3>

<p>Sandro ha escrito un libro espectacular y soberbio. El libro cubre el concepto
de Craftsmanship de arriba a abajo y está ejemplificado con experiencias
personales. El libro está recomendado por muchísimo profesionales muy valorados
en la industria del software, y con razón. Es un placer leerlo.</p>

<p>De acuerdo, el tema me interesa, y me apasiona, así que yo encuentro normal que
el libro me haya encantado. Lo recomendaría a todos aquellos que estén
preocupados por escribir software de calidad, para aquellos que les preocupe
los aspectos técnicos del desarrollo del software.</p>

<h3>Qué he aprendido</h3>

<p>Escribir temas técnicos en tu blog ayudarán a quien venga después de ti. Porque
encontrarán los conceptos descritos con los mismos ojos que tienen ellos ahora.
Incluso si programadores más experimentados han escrito sobre el tema
anteriormente, siempre merece la pena escribir sobre lo que estamos aprendiendo
en este momento.</p>

<p>Es muy fácil decir que un software está muy mal escrito. Es más fácil quejarse,
o incluso reírse del autor. Pero la pregunta es: eres lo suficientemente bueno
como para hacerlo mejor?</p>

<p>¿Qué motiva al trabajor del conocimiento? <strong>Autonomía</strong>, <strong>maestría</strong> y
<strong>propósito</strong>.</p>

<h3>Frases que me gustaría recordar</h3>

<blockquote><p>Sin excelencia técnica, cualquier proyecto software será una experiencia
dolorosa, frustrantte y cara.</p></blockquote>

<!-- -->


<blockquote><p>Las metodologías ágiles ayudan a las empresas a hacer lo correcto, mientras
que Software Craftsmanship ayuda a los programadores y empresas a hacer las
cosas de la forma correcta.</p></blockquote>

<!-- -->


<blockquote><p>Software Craftsmanship es poner toda la responsabilidad, profesionalidad,
pragmatismo y orgullo de vuelta al desarrollo de software.</p></blockquote>

<!-- -->


<blockquote><p>Descubrimiento deliberado: hay que intentar expandir el conocimiento que
tenemos en lo que estemos trabajando, aunque creamos que lo conocemos siempre
habrá algún asunto que podemos explorar. Debemos exponernos constantemente a
situaciones donde podamos aprender algo nuevo acerca del contexto en el que
estamos.</p></blockquote>

<!-- -->


<blockquote><p>Incluso teniendo tiempo, algunos programadores deciden no automatizar sus
tests. <strong>Esto es ser egocéntrico</strong>. Sólo piensa en sus tareas, no en el resto
de la gente involucrada en el proyecto y todo el tiempo que les consumirá no
tener tests.</p></blockquote>

<!-- -->


<blockquote><p>Un código limpio y mantenible permite a los programadores ir rápido y reducir
las probabilidades de introducir bugs.</p></blockquote>

<!-- -->


<blockquote><p>¿Qué motiva al trabajor del conocimiento? Autonomía, maestría y propósito.</p></blockquote>

<!-- -->


<blockquote><p>En lugar de decir a los demás qué hacer, los software craftsmen se sientan y
trabajan con otros desarrolladores, compartiendo su conocimiento, experiencia
y pasión. Los software craftsman están deseando compartir las cosas que hacen
para mejorar ellos mismos.</p></blockquote>

<!-- -->


<blockquote><p>Ser buenos en lo que hacemos, ser capaces de comunicarlo claramente, y lo más
importante, ser capaces de generar confianza, son habilidades esenciales para
cualquier desarrollador que esté dispuesto a liderar cambios.</p></blockquote>

<!-- -->


<blockquote><p>Lo que distingue a grandes programadores de los mediocres es cómo hacen que
el software funcione, no si el software funciona o no, si no el cómo.</p></blockquote>

<!-- -->


<blockquote><p>Sobre craftsmanship y pragmatismo: TDD no hace que los programadores vayan
más lentos. Escribir el código no es el cuello de botella. Lo que sí que lo
es es aprender y dominar una nueva habilidad, práctica o tecnología.</p></blockquote>

<!-- -->


<blockquote><p>No tengas miedo de ser <em>viejo</em> y seguir programando. No tengas miedo de hacer
lo que te gusta.</p></blockquote>

<!-- -->


<blockquote><p>Para muchos programadores, buscar un trabajo es solo una forma de vender sus
habilidades al mejor postor. Para profesionales que están interesados en una
carrera larga y próspera, un trabajo es algo más que eso. Es una inversión
constante en sus carreras. Aparte de las cosas por las que se nos paga,
deberíamos invertir toda nuestra dedicación, pasión, compromiso y
conocimiento que adquirimos fuera del trabajo en hacer nuestro actual entorno
de trabajo un lugar mejor.</p></blockquote>

<!-- -->


<h3>Recursos relacionados</h3>

<ul>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/the-software-craftsman-by-sandro-mancuso.markdown">Notas tomadas sobre The Software Craftsman</a></li>
<li>Charla de Sandro Mancuso, <a href="https://vimeo.com/167722761">The long road</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
