<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: technical talks | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/technical-talks/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2015-11-01T23:28:12+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Effective learning for programmers]]></title>
    <link href="http://rchavarria.github.io/blog/2015/10/18/charla-tecnica-effective-learning-for-programmers/"/>
    <updated>2015-10-18T18:46:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/10/18/charla-tecnica-effective-learning-for-programmers</id>
    <content type="html"><![CDATA[<p>Me gustaría compartir una charla de <a href="http://akaptur.com/">Allison Kaptur</a>, en un grupo de usuarios
de Python de Nueva Zelanda, titulada <a href="https://www.youtube.com/embed/Mcc6JEhDSpo">Effective learning for programmers</a>,
donde habla acerca de encontrar ciertas estrategias para el aprendizaje.</p>

<iframe width="420"
        height="315"
        src="https://www.youtube.com/embed/Mcc6JEhDSpo"
        frameborder="0"
        allowfullscreen></iframe>




<!-- more -->


<h2>Notas tomadas</h2>

<p>La charla consta de dos partes: mentalidad (<em>mindset</em>) y estrategias</p>

<h3>Mentalidad</h3>

<p>Allison habla de dos tipos:</p>

<ol>
<li><strong>Mentalidad de crecimiento</strong>: la inteligencia es algo que se puede trabajar y
desarrollar con <strong>esfuerzo</strong></li>
<li><strong>Mentalidad fija</strong>: la inteligencia es la que es y no puede ir a más, la
inteligencia es fija, y cada uno tiene una cierta cantidad de ella</li>
</ol>


<p>La diferencia fundamental radica en que quien posee una mentalidad de
crecimiento, piensa que si algo no es fácil, puede trabajar duro para
aprenderlo. Mientras que quien posee una mentalidad fija, piensa que si algo es
fácil, se trata de una cualidad con la que ha nacido, que es de lo suyo.</p>

<p>Alabanzas contraproducentes: ante alabanzas de un trabajo realizado, los de
mentalidad fija se contentan, mientras que los de mentalidad de crecimiento se
sienten animados para superarse a sí mismos.</p>

<p>Respuesta a la confusión: los de mentalidad fija se quedan bloqueados, y los de
mentalidad de crecimiento se esfuerzan en entender la parte complicada, hasta
que superan el obstáculo.</p>

<p><strong>Está claro que los desarrolladores necesitamos una mentalidad de
crecimiento</strong>. Pero, ¿se puede cambiar una mentalidad fija?</p>

<ol>
<li>Reformula las alabanzas: cuando alaben tu trabajo: "eres un máquina",... te
dices a tí internamente: "no soy un máquina, he trabajado duro para llegar
hasta aquí"</li>
<li>Reformula los fallos</li>
<li>Celebra los desafíos: cuando te toca arreglar un bug, decirte a tí mismo:
"genial! que se prepare ese bug, porque le voy a patear el culo"</li>
<li>Pregunta sobre el proceso seguido: pregunta siempre, "¿cómo has hecho eso?",
"¿cómo funciona eso?", muestra curiosidad por cómo se hacen las cosas,
aprende de los que más saben</li>
</ol>


<h3>Estrategias</h3>

<p>El aprendizaje es una habilidad adquirida, por lo que se puede mejorar
practicando:</p>

<ol>
<li>Recuperación con esfuerzo (<em>effortful retrieval</em>): aprender mediante
preguntas que te obligan a encontrar una respuesta. Es maś efectivo que una
relectura, incluso mejor que una relectura de las notas que has tomado en una
clase. La relectura te da la ilusión de que ya te sabes la lección.</li>
<li>Práctica espaciada (<em>spaced practice</em>): es mejor que una práctica masiva. La
práctica debe ser espaciada en el tiempo, variada y que mezcle conceptos de
todo el proceso de aprendizaje. Es mejor un curso de 1h durante 5 días que uno
de 5 horas en un día.</li>
<li>Dificultad y errores: cierta dificultad suele ser lo deseable. Cometer
errores suele ser también recomendable durante el aprendizaje.</li>
</ol>


<h4>Implementando <em>recuperación con esfuerzo</em></h4>

<ul>
<li>Las tarjetas de conceptos (<em>flashcards</em>) es un ejemplo de esto, pero quizá no
es la mejor forma de implementarlo</li>
<li>Cuando no sabes a ciencia cierta algo, intenta adivinarlo. Por ejemplo, los
argumentos de un comando, o intentar deducir algún aspecto de la lección que
estas estudiando</li>
<li>Intentar adivinar cual es la causa de un bug antes siquiera de empezar a
solucionarlo</li>
<li>Cuando te preguntan por algún concepto que te suena, pero no lo conoces en
profundidad, puedes intentar deducir de qué trata y así confirmar tus
suposiciones</li>
</ul>


<h4>Implementando <em>práctica espaciada</em></h4>

<ul>
<li>Trabajar en tus proyectos personales los fines de semana. Así cuando vayas a
comenzar el sábado, debes recordar lo que trabajaste hace un tiempo. Eso
ayuda al aprendizaje.</li>
</ul>


<h4>Implementando <em>dificultad y errores</em></h4>

<ul>
<li>La dificultad vienen implícita en muchos de nuestros aprendizajes, así que no
hace falta que hagamos algo extra para ello</li>
<li>Para descubrir errores: intentar buscar un feedback rápido, revisiones de
código, post-mortems,...</li>
<li>Generar un entorno donde los pequeños errores no tienen consecuencias, o que
cuando tú sepas algo que tus compañeros no saben, no te burles de ellos</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: All the little things]]></title>
    <link href="http://rchavarria.github.io/blog/2015/10/18/charla-tecnica-all-the-little-things/"/>
    <updated>2015-10-18T18:40:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/10/18/charla-tecnica-all-the-little-things</id>
    <content type="html"><![CDATA[<p>A través del blog <a href="http://garajeando.blogspot.com.es/2015/08/interesting-talk-all-little-things.html">Garajeando</a> llegué a esta charla de <a href="http://www.sandimetz.com">Sandi Metz</a> que se
titula <a href="https://www.youtube.com/watch?v=8bZh5LMaSmE">All the little things</a>. Sandi Metz es autora del libro
<a href="http://www.sandimetz.com/products">Practical Object Oriented Design in Ruby</a> y ya he visto algunas de sus charlas, por lo
que la calidad estaba asegurada. Sandi es muy defensora de la OOP y es una
profesional excelente.</p>

<p>La charla trata de una refactorización siguiendo la kata <a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">The Gilded Rose</a>. La
refactorización parte de un método gigante lleno de <code>if</code>s y lleva el código
hacia clases pequeñas, métodos pequeños.</p>

<!-- more -->




<iframe width="560"
        height="315"
        src="https://www.youtube.com/embed/8bZh5LMaSmE"
        frameborder="0"
        allowfullscreen></iframe>


<h2>Notas tomadas de la charla</h2>

<blockquote><p>Es preferible algo de duplicación a una mala abstracción</p></blockquote>

<p>La duplicación es fácil de detectar y de eliminar llegado el caso. Una mala
abstracción al arrastraremos toda la vida del proyecto.</p>

<p>Unos días después, Sandi publicó un <a href="http://us3.campaign-archive2.com/?u=1090565ccff48ac602d0a84b4&amp;id=92902a19e4&amp;e=072f6853e8">artículo en forma de newsletter</a>
explicando algo más esta frase, porque parece que creó confusión o al menos,
causó reacciones que hicieron pensar a Sandi que la gente no entendió realmente
lo que ella quería transmitir.</p>

<p>La idea principal de ese artículo es que una vez identificada una mala
abstracción en el código (le pasan parámetros y hay <code>if</code>s y más <code>if</code>s), es
recomendable recrear la duplicación en el código y dejar que él mismo nos
indique nuevas abstracciones.</p>

<blockquote><p>Que tu objetivo sea llegar a Open/Closed</p></blockquote>

<p>Uno de los principios de la Programación Orientada a Objectos, es el
Open/Closed Principle. Que para añadir nueva funcionalidad, no tengas que
modificar código existente (abierto a extensión, cerrado a modificación). Lo
ideal es que toda la aplicación siguiera este principio, no vas a llegar nunca,
pero cuanto más lo sigas, más fácil será añadir nueva funcionalidad sin romper
la existente.</p>

<blockquote><p>Crea cosas pequeñas</p></blockquote>

<p>Clases pequeñas, métodos pequeños,...</p>

<blockquote><p>Refactoriza basándote en la complejidad, mediante la complejidad</p></blockquote>

<p>Uno de los objetivos de las refactorizaciones es hacer el código más sencillo.
Puedes utilizar métricas de complejidad para hacer un seguimiento de la
refactorización. En pasos intermedios, ésta puede crecer, pero debes tener
confianza en que la refactorización dará sus frutos y conseguirás un código más
sencillo y limpio.</p>

<blockquote><p>Refactoriza hacia la simplicidad</p>

<p>La herencia no siempre es mala</p></blockquote>

<p>Se habla mucho de composición en lugar de herencia, pero para Sandi hay una
ocasión, donde si se dan las siguientes circunstancias, la herencia es la mejor
solución:</p>

<ol>
<li>La jerarquía no es profunda ni ancha, es poco profunda y estrecha (no
involucra muchas clases hijas)</li>
<li>Las subclases son hojas dentro de tu árbol de clases, las subclases están en
los extremos de tu árbol de clases, no entre medias</li>
<li>Las subclases usan todo el código de la clase padre</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Follow my leader]]></title>
    <link href="http://rchavarria.github.io/blog/2015/10/04/charla-tecnica-follow-my-leader/"/>
    <updated>2015-10-04T15:21:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/10/04/charla-tecnica-follow-my-leader</id>
    <content type="html"><![CDATA[<p>Estas notas podrían encajar perfectamente en el post que voy actualizando
regularmente <a href="/blog/2014/10/11/aprendiendo-vim/">Aprendiendo Vim</a>, pero creo que esta la charla de Drew Neail se
desmarca ya un poco del proceso de aprendizaje. En esta charla no se busca
enseñar nuevos comandos de Vim, si no que se trata más de un tema cultural
acerca del editor. Drew trata de animar a la gente a que busque nuevas
combinaciones de teclas que se conviertan en nuevos comandos y de esta forma
hacer Vim más potente todavía.</p>

<!-- more -->


<h2>Notas tomadas de la charla <a href="https://vimeo.com/85343734">Follow my leader</a></h2>

<iframe src="https://player.vimeo.com/video/85343734"
        width="500"
        height="281"
        frameborder="0"
        webkitallowfullscreen mozallowfullscreen allowfullscreen>
</iframe>


<p><em><a href="https://vimeo.com/85343734">Follow my leader</a>, por <a href="http://drewneil.com/">Drew Neil</a>, en un encuentro del grupo local
<a href="https://vimeo.com/vimlondon">Vim London</a></em></p>

<ul>
<li><code>let mapleader = ","</code> para mapear <code>,</code> como tecla <code>&lt;leader&gt;</code> en Vim. Otra
tecla muy común para utilizarla como <code>&lt;leader&gt;</code> es la barra espaciadora.</li>
<li><code>nnoremap &lt;leader&gt;&lt;space&gt; :noh&lt;cr&gt;</code> : remapea la secuencia de teclas
<code>&lt;leader&gt;&lt;space&gt;</code> para que se ejecute el comando <code>:nohlsearch</code>, que desactiva
el resaltado de términos de búsqueda.</li>
<li>La tecla <code>&lt;leader&gt;</code> te permite crear mapeos personalizados, es donde los
usuarios pueden crear sus mapeos sin interferir con Vim</li>
<li>En lugar de usar <code>leader</code>, algunos plugins, como los que escribe <a href="http://tpo.pe/">Tim Pope</a>
siguen otro patrón. hay teclas que son <em>operadores</em>, por ejemplo la <strong>d</strong>
para borrar, o la <strong>y</strong> para copiar. a estos operadores le puede seguir el
mismo operador o una movimiento. Teclas que producen un movimiento son <strong>j</strong>
para ir hacia abajo, <strong>$</strong> para ir al final de la línea, ... Pero, qué pasa si
despues de un operador pulsamos una tecla de <em>no movimiento</em>? No pasa nada. Y
ahí están las combinaciones de teclas dsiponibles para tus plugins.</li>
<li>En la imagen de la <a href="http://www.viemu.com/vi-vim-cheat-sheet.gif">chuleta de Vim</a>, los naranjas son operadores, los
verdes movimientos y los amarillos son comandos.</li>
</ul>


<p><img class="center" src="/images/2015/tiny-vi-vim-cheat-sheet.gif"></p>

<ul>
<li>El plugin <a href="https://github.com/tpope/vim-unimpaired">unimpaired.vim</a> añade mapeos como <code>con</code> para habilitar/deshabilitar los
nuḿeros de línea, o <code>cos</code> para habilitar/deshabilitar el chequeo ortográfico.
Son <code>c</code> + <code>o</code> + otras teclas</li>
<li>También hay disponibles combinaciones como operador + operador : <code>d</code> + <code>c</code></li>
<li>Los <em>text objects</em> (<code>i</code> y <code>a</code>) también tienen vacantes.</li>
<li>Los <em>namespaced mappings</em> también tienen vacantes. Por ejemplo, <code>g</code> es como
un prefijo para muchos mapeos. <code>z</code> es otro, y <code>[</code> y <code>]</code> son más.</li>
<li><code>:help g</code> te muestra todos los mapeos que siguen a <code>g</code>. Te puede servir para
ver huecos donde poner tus mapeos</li>
<li>Comando inútiles, hay algunos comandos que no usa nadie. Sobreescríbelos. Por
ejemplo, <code>g</code> + <code>s</code>.</li>
<li>Sobreescribir, sobrecargar comandos que ya existen, vamos, ampliar los
existentes.</li>
</ul>


<h2>Conclusiones</h2>

<p>Como puedes ver, el editor Vim es todo un mundo de posibilidades. Hay veces que
abruma, pero hay tanta gente apasionada por él que está claro que algo debe de
tener. Esta charla es una muestra de las posibilidades de personalización que
esta herramienta ofrece. Drew nos abre las puertas a un mundo nuevo de posibles
comandos.</p>

<p>Si te gusta Vim, y no conoces el plugin <a href="https://github.com/tpope/vim-unimpaired">unimpaired.vim</a>, échale un vistazo. Sin
duda es uno de los imprescindibles, como tantos otros de Tim Pope.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Workflows of refactoring]]></title>
    <link href="http://rchavarria.github.io/blog/2015/09/13/charla-tecnica-workflows-refactoring/"/>
    <updated>2015-09-13T10:08:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/09/13/charla-tecnica-workflows-refactoring</id>
    <content type="html"><![CDATA[<p>Esta semana el post trata sobre las notas que he tomado de una charla técnica
titulada <a href="https://www.youtube.com/watch?v=vqEg37e4Mkw">Workflows of refactoring</a>. El autor de la charla, hablando de
<em>refactoring</em>, no podría ser otro que <a href="http://www.martinfowler.com/">Martin Fowler</a>. En la charla, Martin
comienza hablando de distintos modos de trabajar, dependiendo de la situación,
por ejemplo, nos encontraremos añadiendo funcionalidad o limpiando el código.
Después, Martin describe distintos tipos de refactorizaciones, más allá del
típico paso en TDD o de la refactorización cambiando unos cuantos nombres a las
variables.</p>

<!-- more -->




<iframe width="560"
        height="315"
        src="https://www.youtube.com/embed/vqEg37e4Mkw"
        frameborder="0"
        allowfullscreen></iframe>


<h2>Notas tomadas</h2>

<blockquote><p>La primera vez que la gente escucha hablar de <em>refactoring</em> es cuando oye hablar
del ciclo de TDD: red > green > refactor.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p>¿Por qué separar los dos pasos que incluyen el código en TDD? ¿Uno para
escribir el código y otro para refactorizar? Puede que esté hecho para los
programadores menos experimentados y para los impacientes, para aquellos que
antes de nada quieren tener algo funcionando. Kent Beck hablaba de dos modos
de trabajar, dos sombreros: añadiendo funcionalidad y modo mantenimiento
(refactorizando). Se puede cambiar entre ellos, pero no se puede andar
mezclándolos.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p>Otros modos, otros sombreros: mejoras de rendimiento, donde el rendimiento
prima sobre la legibilidad; experimentos (donde el resultado va a ser descartado).</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p><strong>TDD refactoring</strong>: el refactoring que pasa cuando estás haciendo TDD, o tienes
una batería de tests en la que apoyarte</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p><strong>Litter-pickup refactoring</strong>: similar a la regla del Boy Scout. Se trata de que
tienes que trabajar con una base de código que no está escrita como a tí te gustaría
(aunque lo más probable es que hayas sido tú quien la haya escrito). Vas navegando
por el código, y de repente ves algún detalle que no te encaja. Paras todo, y lo
arreglas. En definitiva, como el Boy Scout, dejas el campo un poquito mejor de lo
que te lo encontraste. No quieres pasar mucho tiempo limpiándolo, pero sí dejarlo
un poquito mejor.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p>Cuando encuentras alguna pieza de código en la que tienes que invertir cierto
tiempo entendiendo qué es lo que hace. Cuando terminas entendiéndolo, ¿qué
haces? ¿Lo dejas como está? ¿Y si la próxima vez vuelves a perder tanto tiempo?
Tendrás que refactorizarlo. <strong>Comprehension refactoring</strong>.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p>Hay situaciones en las que después de un tiempo, vuelves a ver código y piensas:
"hey! Ahora conozco una nueva y mejor forma de hacer esto". Esto tiene mucho que
ver con el <em>diseño evolutivo</em>. Por ejemplo, refactorizar un poquito antes de
añadir una nueva funcionalidad. Normalmente, el refactoring es beneficioso en el
largo y medio plazo. Este en concreto, es beneficioso para la tarea en la que
estás trabajando en este mismo momento.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p><strong>Planned refactoring</strong>. Un buen equipo necesitaría poco de este tipo de
refactoring. Para el resto de mortales, un poco de refactorizaciones planificadas
no hace daño.</p></blockquote>

<!-- comment to separate ideas -->


<blockquote><p><strong>Long-term refactoring</strong>. Por ejemplo, cuando tienes un montón de módulos que
tienen dependencias caóticas. En lugar de parar el desarrollo y dedicar 2 o 3
semanas refactorizando todo esto, ¿qué tal si vas refactorizando poco a poco,
sin romper nada, gradualmente,... hasta que lo consigas? Quizá no tengas del
todo claro cómo llegar al final, pero si vas poco a poco, lo más seguro es que
tarde o temprano encuentres el camino.</p></blockquote>

<h2>Conclusión</h2>

<p>Me parece una charla interesantísima, recomendada 100%. Y no sólo echarle un
vistazo por encima, sino profundizar en los conceptos que Martin Fowler expone.
La charla es la keynote de una conferencia sobre Programación Orientada a
Objectos bastante conocida, así que tiene todas las papeletas de ser un
recurso muy útil.</p>

<p>No estoy seguro, pero tiene pinta de que todos estos conceptos y nombres que
Martin da a los distintos tipos de refactorizaciones los vamos a ir viendo y
desarrollando en años venideros.</p>

<p>Así que ya sabes, haz un hueco en la agenda, y ¡a visualizar la charla!</p>
]]></content>
  </entry>
  
</feed>
