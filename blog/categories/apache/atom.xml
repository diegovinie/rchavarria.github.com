<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apache | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/apache/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2013-09-26T09:29:14+02:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Uso de JPA, hibernate y derby]]></title>
    <link href="http://rchavarria.github.io/blog/2011/05/19/uso-de-jpa-hibernate-y-derby/"/>
    <updated>2011-05-19T09:44:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2011/05/19/uso-de-jpa-hibernate-y-derby</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
  <p>Este post pertenece a mi antiguo blog en <a href="http://rchavarria.wordpress.com">wordpress</a>, pero decidí pasarme a github:pages por las siguientes <a href="http://rchavarria.github.io/blog/2012/12/03/por-que-cambie-mi-blog-en-wordpress-com">razones</a></p>
</div>


<p>Tengo una pequeña aplicación en la que uso Apache Derby como base de datos para guardar los datos.</p>

<p>Hasta ahora, estaba utilizando el patrón DAO para guardar los datos que quería hacer persistentes en la aplicación. Cada clase DAO se encargaba de crear, borrar, editar y actualizar un tipo de datos. Estas operaciones las hacía mediante SQL puro y duro. No es que el modelo de datos que utilizo sea muy complicado, pero es tedioso editar consultas SQL para cada tipo de dato que quieres persistir.</p>

<p>Así pues, decidí que debería utilizar algo un poco más elaborado. Java dispone de la Java Persistence API, así que, ¿porqué no usarla? Y este post describe los primeros pasos a dar para utilizar JPA en una aplicación.</p>

<!-- more -->


<p>JPA es una definición, por sí sola no hace nada, necesita de una implementación para realizar realmente el trabajo. Existen varias implementaciones (ver <a title="Comparativa implementaciones JPA" href="http://terrazadearavaca.blogspot.com/2008/12/jpa-implementations-comparison.html">comparativa</a>). De todas ellas he elegido Hibernate. Puede que no sea la mejor, puede que no sea la más rápida o la más eficiente, pero creo que es la más conocida y la referencia para el resto de implementaciones.</p>

<h2>El ejemplo, paso a paso</h2>


<p>Nuestro ejemplo va a consistir en algo muy (pero que muy) sencillo, pero que nos va a permitir aprender cómo configurar hibernate con nuestra base de datos derby. Nuestros datos a guardar van a ser objetos de la clase Person, que va a tener un nombre. No va a haber relaciones con ningún otro objeto, así que sólo exisitirá una tabla en la base de datos. Más sencillo, imposible.</p>

<h3>Datos que serán persistentes</h3>


<p>Como ya hemos visto, sólo vamos a persistir objetos de la clase Person, la cual tendrá un campo id, que funcionará como la clave principal de la tabla, y un campo name, el nombre de la persona. A continuación vemos el código de esta clase:
{% codeblock Definir persistencia de datos %}
package es.rct.jpa.model;</p>

<p>import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;</p>

<p>@Entity
public class Person {</p>

<pre><code>@Id
@GeneratedValue
private long id;
private String name;

public void setName(final String name) {this.name = name;}
public String getName() {return name;}
public void setId(final long id) {this.id = id;}
public long getId() {return id;}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>De esta clase vamos a destacar 3 anotaciones, pertenecientes a JPA. Las podemos encontrar en el paquete javax.persistence:</p>

<ul>
    <li>Entity: indica que esta clase es una entidad, lo cual significa que esta clase tiene correspondencia con una tabla en la base de datos.</li>
    <li>Id: indica qué campo de la clase va a ser utilizado como clave primaria de la tabla representada por la entidad.</li>
    <li>GeneratedValue: indica que la clave va a ser generada automáticamente por el motor de persistencia (hibernate)</li>
</ul>




<h3>Dependencias de Maven</h3>


<p>Para poder usar Derby como base de datos y Hibernate como implementación de JPA, debemos incluir las siguientes dependencias en nuestro fichero pom.xml de configuración de maven:</p>

<script src="http://gist.github.com/4194334.js"></script>


<p>Las versiones de las dependencias pueden variar. Aquí aparecen las que yo personalmente he utilizado.</p>

<h3>Configurar JPA / Hibernate / Derby</h3>


<p>Para configurar JPA, debemos escribir la configuracion en un fichero llamado persistence.xml,
en un directory META-INF, accesible desde el directorio de trabajo de nuestra aplicación.
Yo lo he creado en src/main/resources/META-INF/persistence.xml, ya que maven empaqueta el
contenido del directorio src/main/resources en el jar de la aplicación, con lo que tenemos
el resultado deseado.</p>

<p>El contenido del fichero de configuración JPA es el siguiente:</p>

<script src="http://gist.github.com/4194389.js"></script>


<p>De este fichero xml podemos destacar las siguientes etiquetas:</p>

<ul>
    <li>persistence-unit, atributo name: define una unidad de persistencia, es obligatorio darle un nombre, para poder crear un EntityManager en nuestra aplicación. El EntityManager es el encargado de manejar la persistencia de nuestros datos.</li>
    <li>provider: aquí indicamos que queremos usar Hibernate como implementación de JPA</li>
    <li>class: debe existir una etiqueta class por cada clase que queramos persistir, es decir, una por cada entidad que formará nuestra unidad de persistencia.</li>
    <li>Dentro de las etiquetas properties, definimos propiedades propietarias de la implementación JPA. De entre ellas cabe destacar:</li>
</ul>


<ol>
    <li>hibernate.connection.url: define la URL de conexión a la base de datos. Aquí estamos configurando Derby como base de datos. Estamos creando una base de datos llamada "testing-jpa" en memoria (no en disco).</li>
    <li>hibernate.dialect: configuramos Hibernate para que "hable" con Derby</li>
</ol>




<h3>Crear un test para probar el funcionamiento</h3>


<p>Ahora sólo queda crear nuestro código para almacenar algunos objetos del tipo Person.</p>

<p>Primero, debemos crear un objeto EntityManager, que manejará todo lo relacionado con la persistencia: transacciones, guardar datos, actualizarlos, borrarlos, etc.</p>

<p>{% codeblock %}
EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;test-jpa&quot;);
EntityManager em = emf.createEntityManager();
{% endcodeblock %}</p>

<p>Una vez terminemos de utilizar nuestro EntityManager, debemos cerrarlo:</p>

<p>{% codeblock %}
em.close();
emf.close();
{% endcodeblock %}</p>

<p>Ahora ya disponemos de un objeto "em" para poder persistir objetos de tipo Person:</p>

<p>{% codeblock %}
private void insertSomeData() {</p>

<pre><code>Person p = new Person();
p.setName(&amp;quot;person 01&amp;quot;);
Person p1 = new Person();
p1.setName(&amp;quot;person 02&amp;quot;);

em.getTransaction().begin();
em.persist(p);
em.persist(p1);
em.getTransaction().commit();
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Para poder guardar los datos en base de datos, debemos arrancar una transacción, llamar al método "persist" y terminar la transacción. Si queremos indicar que ha habido un error durante la transacción, y no queremos llevarla a cabo, llamaríamos al método "rollback" en lugar del método "commit".</p>

<p>Para comprobar que realmente hemos almacenado los objetos en la base de datos, sólo tenemos que buscarlos por identificador. Ya que sólo hemos almacenado 2 objetos, y son los 2 primeros, los ids serán 1 y 2 respectivamente:</p>

<p>{% codeblock Insertar datos %}
private void listInsertedData() {</p>

<pre><code>em.getTransaction().begin();
for (long i = 1; i &amp;lt;= 2; i++) {
    Person pFinded = em.find(Person.class, new Long(i));
    System.out.println(&amp;quot;Id: &amp;quot; + i + &amp;quot;, name: &amp;quot; + pFinded.getName());
}
em.getTransaction().commit();
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>Código fuente del ejemplo</h2>


<p>Puedes descargar/ver el código fuente en este repositorio de github: <a title="Repositorio github con la solucion" href="https://github.com/rchavarria/JPAHibernateDerby">https://github.com/rchavarria/JPAHibernateDerby</a></p>

<h2>Referencias</h2>


<p>Si quieres profundizar en el tema, aquí dejo unos enlaces que me han sido de gran ayuda.</p>

<ol>
<li>
<a href="http://www.davidmarco.es/blog/entrada.php?id=144">Excelente tutorial de JPA</a>
</li>
<li>
<a href="http://wiki.apache.org/db-derby/InMemoryBackEndPrimer">Configuración de Derby para trabajar en memoria</a>
</li>
<li>
<a href="http://eskatos.wordpress.com/2009/10/26/unit-test-jpa-entities-with-in-memory-derby">Configuración de JPA para usar Hibernate</a>
</li>
<li>
<a href="http://docs.jboss.org/hibernate/entitymanager/3.5/reference/en/html_single/#architecture-javase">Hibernate en entornos JavaSE</a>
</li>
<li>
<a href="http://terrazadearavaca.blogspot.com/2008/12/jpa-implementations-comparison.html">Comparativa de implementaciones de JPA</a>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Usar apache derby como base de datos]]></title>
    <link href="http://rchavarria.github.io/blog/2010/06/24/usar-apache-derby-como-base-de-datos/"/>
    <updated>2010-06-24T09:44:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2010/06/24/usar-apache-derby-como-base-de-datos</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
  <p>Este post pertenece a mi antiguo blog en <a href="http://rchavarria.wordpress.com">wordpress</a>, pero decidí pasarme a github:pages por las siguientes <a href="http://rchavarria.github.io/blog/2012/12/03/por-que-cambie-mi-blog-en-wordpress-com">razones</a></p>
</div>


<p>En este post vamos a aprender a usar <a href="http://db.apache.org/derby/">Apache Derby</a> como base de datos para nuestra aplicación Java. Seguiremos paso por paso un ejemplo de uso muy sencillo.</p>

<!-- more -->




<h2>Instalación</h2>


<p>Lo primero que deberemos hacer es descargar la última versión de Apache Derby: <a href="http://db.apache.org/derby/derby_downloads.html">página de descarga</a>. La descarga recomendada sería la distribución binaria, que incluye las librerías, documentación y herramientas de ayuda.</p>

<p>Acto seguido descomprimimos la distribución a un directorio de nuestra elección, por ejemplo:</p>

<pre>C:\Archivos de programa\Java\derby-10.6
</pre>


<p>Para poder usar derby, deberemos configurar nuestro entorno, es decir, deberemos establecer ciertas variables de entorno con los valores adecuados para poder ejecutar derby en nuestro PC. Suponiendo que vamos a usar Windows como sistema operativo, deberemos establecer las siguientes variables de entorno:</p>

<pre>set DERBY_HOME=C:\Archivos de programa\Java\derby-10.6
set PATH=%DERBY_HOME%\bin;%PATH%
</pre>


<p>De esta forma conseguiremos tener accesibles los ejecutables de las herramientas proporcionadas por derby.</p>

<p>A partir de ahora, para poder utilizar derby en nuestros programas Java, sólo será necesario tener accesible la librería <em>derby.jar</em> en el classpath de nuestro programa.</p>

<h2>Código de ejemplo</h2>


<p>De acuerdo, ya sabemos lo que tenemos que hacer para poder usar derby. Pero, ¿cómo lo usamos?. A continuación vamos a estudiar varios fragmentos de código que nos permitirán crear una base de datos, crear una sencilla tabla en nuestra base de datos, insertar datos y realizar consultas. Para ello se presupone un conocimiento básico de lenguaje SQL. Si quieres aprender un poco más sobre él puedes aprender un poco en <a href="http://www.w3schools.com/sql/">SQL Tutorial de W3C</a>.</p>

<h3>Crear una base de datos</h3>


<p>{% codeblock Crear una base de datos programáticamente %}</p>

<p>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;</p>

<p>public class CreateDataBase {</p>

<p>  public static void main(String[] args) {</p>

<pre><code>String driver = &amp;quot;org.apache.derby.jdbc.EmbeddedDriver&amp;quot;;
String dbName = &amp;quot;/DerbyDB/ExampleDB&amp;quot;;
String dbParam = &amp;quot;create=true&amp;quot;; //la base de datos se creará si no existe todavía
String connectionURL = &amp;quot;jdbc:derby:&amp;quot; + dbName + &amp;quot;;&amp;quot; + dbParam;
Connection conn = null;

try{
  Class.forName(driver);
} catch(java.lang.ClassNotFoundException e) {
  e.printStackTrace();
}

try {
  conn = DriverManager.getConnection(connectionURL);

  Statement st = conn.createStatement();
  String sqlCreateTableUsers =
         &amp;quot;CREATE TABLE users ( &amp;quot; +
         &amp;quot;FirstName VARCHAR(20) NOT NULL, &amp;quot; +
         &amp;quot;LastName VARCHAR(20) NOT NULL, &amp;quot; +
         &amp;quot;idUser INTEGER NOT NULL CONSTRAINT idUser_PK PRIMARY KEY &amp;quot; +
         &amp;quot;)&amp;quot;;
  // la sentencia SQL crea una tabla con 3 campos
  st.execute(sqlCreateTableUsers);

  System.out.println(&amp;quot;La base de datos '&amp;quot; + dbName + &amp;quot;' se ha creado correctamente&amp;quot;);
}  catch (Throwable e)  {
  System.out.println(&amp;quot;Error al crear la base de datos '&amp;quot; + dbName + &amp;quot;'&amp;quot;);
  e.printStackTrace();
} finally {
  try { conn.close(); }
  catch (Throwable t){}
}
</code></pre>

<p>  }
}</p>

<p>{% endcodeblock %}</p>

<p>Para ejecutar scripts SQL y realizar otras consultas, derby proporciona la herramienta <em>ij</em>, el uso de la cual lo podemos aprender de la siguiente guía: <a href="http://db.apache.org/derby/docs/10.6/getstart/">getting started with derby 10.6 (inglés)</a>.
Como el nombre de la base de datos es <em>/DerbyDB/ExampleDB</em>, la base de datos será creada en el directorio</p>

<pre>C:\DerbyDB\ExampleDB</pre>


<h3>Insertar datos</h3>


<p>Con el siguiente código seremos capaces de introducir datos en nuestra tabla:</p>

<p>{% codeblock Insertar datos %}</p>

<p>String driver = &quot;org.apache.derby.jdbc.EmbeddedDriver&quot;;
String dbName = &quot;/DerbyDB/ExampleDB&quot;;
String connectionURL = &quot;jdbc:derby:&quot; + dbName;
Connection conn = null;</p>

<p>try{
  Class.forName(driver);
} catch(java.lang.ClassNotFoundException e) {
  e.printStackTrace();
}</p>

<p>try {
  conn = DriverManager.getConnection(connectionURL);</p>

<p>  Statement st = conn.createStatement();
  st.executeUpdate(&quot;INSERT INTO users VALUES('Jose', 'Olmedo', 1)&quot;);
  st.executeUpdate(&quot;INSERT INTO users VALUES('Maria', 'Hoz', 2)&quot;);</p>

<p>  System.out.println(&quot;Se han insertado dos registros&quot;);
} catch (Throwable e)  {
  System.out.println(&quot;Ha fallado la insercion de dos registros&quot;);
  e.printStackTrace();
} finally {
  try { conn.close(); }
  catch (Throwable t){}
}</p>

<p>{% endcodeblock %}</p>

<h3>Realizar consultas</h3>


<p>Con el siguiente código, realizamos una consulta a nuestra tabla y mostramos por consola la información en ella almacenada:</p>

<p>{% codeblock Realizar consultas %}</p>

<p>String driver = &quot;org.apache.derby.jdbc.EmbeddedDriver&quot;;
String dbName = &quot;/DerbyDB/ExampleDB&quot;;
String connectionURL = &quot;jdbc:derby:&quot; + dbName;
Connection conn = null;</p>

<p>try{
  Class.forName(driver);
} catch(java.lang.ClassNotFoundException e) {
  e.printStackTrace();
}</p>

<p>try {
  conn = DriverManager.getConnection(connectionURL);</p>

<p>  Statement st = conn.createStatement();
  ResultSet rs=st.executeQuery(&quot;SELECT * FROM users&quot;);
  while (rs.next()){</p>

<pre><code>Integer idUser = rs.getInt(&amp;quot;idUser&amp;quot;);
String first = rs.getString(&amp;quot;FirstName&amp;quot;);
String last = rs.getString(&amp;quot;LastName&amp;quot;);
System.out.println(idUser + &amp;quot; se llama: &amp;quot; + first + &amp;quot; &amp;quot; + last);
</code></pre>

<p>  }
  rs.close();
} catch (Throwable e)  {
  System.out.println(&quot;Ha fallado la consulta de datos&quot;);
  e.printStackTrace();
} finally {
  try { conn.close(); }
  catch (Throwable t){}
}</p>

<p>{% endcodeblock %}</p>

<p>Espero que este post os sirva para poder utilizar derby como base de datos.</p>

<div id="_mcePaste" style="overflow:hidden;position:absolute;left:-10000px;top:1232px;width:1px;height:1px;"><!--[if gte mso 9]&gt;  Normal 0 21   false false false        MicrosoftInternetExplorer4  &lt;![endif]--><!--[if gte mso 9]&gt;   &lt;![endif]--><!--  /* Style Definitions */  p.MsoNormal, li.MsoNormal, div.MsoNormal  {mso-style-parent:"";   margin:0cm;   margin-bottom:.0001pt;  mso-pagination:widow-orphan;  font-size:12.0pt;   font-family:"Times New Roman";  mso-fareast-font-family:"Times New Roman";} a:link, span.MsoHyperlink   {color:blue;  text-decoration:underline;  text-underline:single;} a:visited, span.MsoHyperlinkFollowed  {color:purple;  text-decoration:underline;  text-underline:single;} @page Section1  {size:612.0pt 792.0pt;  margin:70.85pt 3.0cm 70.85pt 3.0cm;   mso-header-margin:36.0pt;   mso-footer-margin:36.0pt;   mso-paper-source:0;} div.Section1   {page:Section1;} --><!--[if gte mso 10]&gt; &lt;!   /* Style Definitions */  table.MsoNormalTable   {mso-style-name:&quot;Tabla normal&quot;;   mso-tstyle-rowband-size:0;  mso-tstyle-colband-size:0;  mso-style-noshow:yes;   mso-style-parent:&quot;&quot;;  mso-padding-alt:0cm 5.4pt 0cm 5.4pt;  mso-para-margin:0cm;  mso-para-margin-bottom:.0001pt;   mso-pagination:widow-orphan;  font-size:10.0pt;   font-family:&quot;Times New Roman&quot;;  mso-ansi-language:#0400;  mso-fareast-language:#0400;   mso-bidi-language:#0400;} --> <!--[endif]-->
<p class="MsoNormal">Para ejecutar scripts sql y realizar otras consultas contra una bbdd derby, existe la herramienta ij. El uso de esta herramienta lo podemos aprender de la siguiente guía: <a href="http://db.apache.org/derby/docs/10.6/getstart/">getting started with derby 10.6 (ingles)</a>.</p>

</div>

]]></content>
  </entry>
  
</feed>
