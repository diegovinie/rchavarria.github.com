<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2015-11-01T23:28:12+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Formatear y parsear enumerados en Java con valores personalizados]]></title>
    <link href="http://rchavarria.github.io/blog/2013/01/22/formatear-y-parsear-enumerados-en-java-con-valores-personalizados/"/>
    <updated>2013-01-22T13:17:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2013/01/22/formatear-y-parsear-enumerados-en-java-con-valores-personalizados</id>
    <content type="html"><![CDATA[<p>A partir de la versión 1.5 de Java, nos encontramos con un tipo de datos, un tipo
especial de clases podríamos decir, los enumerados. Los tipos enumerados sirven para
acotar los posibles valores que puede tomar una variable o tipo de objeto. Java
proporciona un método para transformar un enumerado en cadena, <code>name()</code>, y un método
estático para convertir una cadena en uno de los valores del enumerado,
<code>valueOf(String)</code>. Pero estos métodos son un poco limitados, ya que no nos permiten
personalizar los valores a los cuales son transformados los enumerados.</p>

<!-- more -->


<p>Partiremos del siguiente código describiendo tres valores en un enumerado:</p>

<p>``` java
public enum States {</p>

<pre><code>EVERYTHING_IS_OK,
SOMETHING_WENT_WRONG,
TOTAL_FAILURE;
</code></pre>

<p>}
```</p>

<p>Así, sin más, podemos obtener la representación en <code>String</code> de <code>States.TOTAL_FAILURE</code>
simplemente llamando al método <code>States.TOTAL_FAILURE.name()</code>. De la misma forma, usando
la llamada <code>States.valueOf("EVERYTHING_IS_OK")</code> es fácil imaginar qué valor del enumerado
obtendremos.</p>

<p>Pero, y si en lugar de esa representación a <code>String</code>, ¿queremos definir la nuestra
propia?. Por ejemplo, siguiendo la siguiente tabla:</p>

<ul>
<li>EVERYTHING_IS_OK &rarr; green</li>
<li>SOMETHING_WENT_WRONG &rarr; yellow</li>
<li>TOTAL_FAILURE &rarr; red</li>
</ul>


<h2>Formatear a cadena</h2>

<p>Formatear es sencillo, y directo. Podemos declarar un campo <code>value</code> donde almacenar el
valor al cual queremos transformar el enumerado, y podemos sobreescribir el método
<code>toString()</code> de la siguiente manera:</p>

<p>``` java
public enum States {</p>

<pre><code>EVERYTHING_IS_OK("green"),
SOMETHING_WENT_WRONG("yellow"),
TOTAL_FAILURE("red");

private String value;

private States(String value) {
    this.value = value;
}

public String toString() {
    return value;
}
</code></pre>

<p>}
```</p>

<h2>Parsear desde una cadena</h2>

<p>El problema viene cuando queremos obtener un valor del enumerado a partir de un <code>String</code>.
Supongamos que la transformación la vamos a hacer en un método estático, que por contraste
con el anterior método llamaremos <code>fromString</code>. Veamos qué opciones tenemos, de menos a
más apropiadas:</p>

<h3>Sentencias if</h3>

<p>La primera solución que le viene a uno a la cabeza es usar sentencias <code>if</code>.</p>

<p>``` java
[...]
public static States fromString(String fromValue) {</p>

<pre><code>if("green".equals(fromValue)) {
    return EVERYTHING_IS_OK;
} else if("yellow".equals(fromValue)) {
    return SOMETHING_WENT_WRONG;
} else if("red".equals(fromValue)) {
    return TOTAL_FAILURE;
}
throw new IllegalArgumentException("Wrong value: " + fromValue);
</code></pre>

<p>}
[...]
```</p>

<p>No hay mucho que decir aquí, simplemente que se debería evitar a toda costa esta solución.</p>

<h3>Bucle for</h3>

<p>Otra solución, un poco más elegante, pero básicamente siguiendo la misma filosofía, podría
ser utilizar un bucle para recorrer los posibles valores del enumerado:</p>

<p>```
[...]
public static States fromString(String fromValue) {</p>

<pre><code>for(States state : values()) {
    if(state.value.equals(fromValue)) {
        return state;
    }
}
throw new IllegalArgumentException("Wrong value: " + fromValue);
</code></pre>

<p>}
[...]
```</p>

<p>Esta solución es un poquito mejor, ya que si modificamos los valores posibles del enumerado,
no es necesario que modifiquemos este método.</p>

<h3>Prealmacenamiento de los valores en un Map</h3>

<p>Existe una solución que no involucra el uso de sentencias <code>if</code>, lo cual es muy positivo, ya
que estamos evitando la posibilidad de error, ya que no tendremos que formular una condición.</p>

<p>Esta solución la encontré en un hilo el de Stack Overflow <a href="http://stackoverflow.com/questions/1080904/how-can-i-lookup-a-java-enum-from-its-string-value">how can I lookup a Java enum
from its string value?</a>.
Lo que pretende esta solución es crear una estructura de datos, y cuando se quiera transformar
un <code>String</code> en un valor del enumerado, simplemente se consulte esa estructura de datos.</p>

<p>La estructura de datos será un <code>Map</code> estático, que se rellenará en un bloque estático y
consultaremos en nuestro método <code>fromString</code>.</p>

<p>```
[...]
private static Map&lt;String, States> dictionary;
static {</p>

<pre><code>dictionary = new HashMap&lt;String, States&gt;();
for(States state : values()) {
    dictionary.put(state.value; state);
}
</code></pre>

<p>}
[...]
public static States fromString(String fromValue) {</p>

<pre><code>States state = dictionary.get(fromValue);
if(state == null) {
    throw new IllegalArgumentException("Wrong value: " + fromValue);
}
return state;
</code></pre>

<p>}
[...]
```</p>

<h2>Peligros de esta última solución</h2>

<p>En Stack Overflow, un comentario a la respuesta donde encontré la solución sugiere que esta solución
puede causar problemas debido al classloader.</p>

<p>Pero he investigado un poco el tema, y parece que el comentario es erróneo, al menos para el
uso de los enumerados que estoy exponiendo aquí. Según el
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#d5e12253">ejemplo 8.9.2-1 de la especificación del java</a>,
primero se inicializan los valores del enumerado, luego la variable estática y finalmente
se ejecuta el bloque de código estático, estando ya todos los valores del enumerado
inicializados.</p>

<p>Aquí os dejo unos cuantos enlaces a que confirman que la última solución es correcta:</p>

<ul>
<li><a href="http://blog.deepincode.com/2006/12/bootstrapping-static-fields-within-enums">Bootstrapping static fields within enums</a> y en enlace encontrado en ese mismo post: <a href="http://blog.deepincode.com/2006/11/type-safe-enumerations-in-java-50">Type Safe Enumerations in Java 5.0</a> (buscar al final de este último post).</li>
<li>Otro hilo de Stack Overflow, <a href="http://stackoverflow.com/questions/6827987/when-are-these-class-and-subclass-static-blocks-executed-for-an-enum">When are these class and subclass static blocks executed (for an Enum)?</a> que me lleva al recurso definitivo:</li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#d5e12253">Java Language Specification - Example 8.9.2-1</a>: Si la documentación de Oracle sobre java es errónea, apaga y vámonos.</li>
</ul>


<h2>Otras soluciones</h2>

<p>Por supuesto que existen otras soluciones, quizá mejores que la última que propongo, pero
no he querido hacer más largo este post y he querido centrarme en proponer una alternativa
a los métodos <code>.name()</code> y <code>.valueOf()</code>, pertenecientes al propio enumerado.</p>

<p>Es por esto por lo que he descartado usar clases externas para formatear o parsear el
enumerado, lo cual me habría hecho llegar a otras soluciones bien distintas. Pero si crees
que tu solución es muchísimo mejor que ésta, déjame un comentario, será bienvenido.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactorizacion: inserta un m&eacute;todo ajeno]]></title>
    <link href="http://rchavarria.github.io/blog/2012/02/14/refactorizacion-inserta-un-metodo-ajeno/"/>
    <updated>2012-02-14T02:14:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2012/02/14/refactorizacion-inserta-un-metodo-ajeno</id>
    <content type="html"><![CDATA[<p>En este post voy a describir una de las muchas refactorizaciones que describe Martin Fowler en su libro <a href="http://martinfowler.com/refactoring/">Refactoring: improving the design of existing code</a> (<a href="http://rchavarria.github.io/blog/2012/01/25/refactoring-improving-the-design-of-existing-code/">mis impresiones sobre el libro</a>). He escogido la refactorización de <a href="http://martinfowler.com/refactoring/catalog/introduceForeignMethod.html">insertar método ajeno</a> por ser una de las que, aun siendo sencilla, no había sido consciente de utilizarla hasta leer el libro.</p>

<!-- more -->




<h3>Descripción</h3>


<p>La refactorización consiste en crear un método en una clase (clase cliente) cuando en realidad ese método debería pertenecer a otra clase (clase servidor). De ahí el nombre de método ajeno (traducción libre de foreign method)</p>

<h3>Por qué es necesaria</h3>


<p>Esta refactorización aparece ante la necesidad de crear un método en la clase servidor, pero es imposible cambiar el código fuente de la misma.</p>

<h3>Cómo llevar a cabo la refactorización</h3>


<p>Lo primero es crear un método en la clase cliente que haga lo que necesitamos que haga la clase servidora. El primer parámetro de este método será un objeto de la clase servidora. En caso de necesitar algún parámetro más, éstos serían los parámetros en caso de que el método existiera en la clase servidora.</p>

<p>El objetivo de crear un nuevo método es el de poder reutilizar el código y evitar duplicidades. De esta forma podremos retutilizar el código del nuevo método, y en el caso de que en un futuro podamos cambiar el código fuente de la clase servidora, ese cambio será menos doloroso.</p>

<p>Martin Fowler aconseja comentar el método como <code>método ajeno</code>, para poder encontrar métodos candiatos a mover a sus clases correspondientes. En mi opinión, no creo que esto ayude demasiado a la hora de mantener el código, pero tampoco lo veo perjudicial. Así que aquí, que cada cual siga sus preferencias.</p>

<h3>Código de ejemplo</h3>


<p>Partimos del siguiente código de ejemplo, es un ejemplo muy sencillo pero espero que ilustre el caso lo suficientemente bien como para comprender la refactorización:</p>

<p>```
// ...
Date nextDay = new Date(previousDay.getYear(),</p>

<pre><code>                    previousDay.getMonth(), 
                    previousDay.getDate() + 1);
</code></pre>

<p>```</p>

<p>Como vemos, nuestro código necesita varios datos de la clase servidora (Date, objeto previousDay). Si la clase Date tuviera un método nextDay, o similar, nuestro código quedaría realmente simple. Pero no lo tiene, y lo pero de todo es que tampoco tenemos la posibilidad de modificar Date para incorporarle ese método.</p>

<p>Está bien, creemos pues nuestro método ajeno:</p>

<p>```
Date nextDay = nextDay(previousDay);
// ...
// foreign method
private Date nextDay(Date aDay) {</p>

<pre><code>return new Date(aDay.getYear(), 
                aDay.getMonth(), 
                aDay.getDate() + 1);
</code></pre>

<p>}
```</p>

<p>Sí, el código es prácticamente el mismo, pero ahora tenemos un método, la principal forma de reutilizar código. En el caso de poder modificar la clase Date, sería trivial mover este método a esa clase. De hecho, <a href="http://martinfowler.com/refactoring/catalog/moveMethod.html">mover método</a>, es una de las primeras refactorizaciones (y más básicas) explicadas por Martin Fowler en <a href="http://martinfowler.com/refactoring/">Refactoring</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TibrvException[error=901,message=Library not found: tibrvj]]]></title>
    <link href="http://rchavarria.github.io/blog/2012/01/13/tibrvexception-error-901-message-library-not-found-tibrvj/"/>
    <updated>2012-01-13T13:01:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2012/01/13/tibrvexception-error-901-message-library-not-found-tibrvj</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
  <p>Este post pertenece a mi antiguo blog en <a href="http://rchavarria.wordpress.com">wordpress</a>, pero decidí pasarme a github:pages por las siguientes <a href="http://rchavarria.github.io/blog/2012/12/03/por-que-cambie-mi-blog-en-wordpress-com">razones</a></p>
</div>




<p>Actualmente, en el trabajo estamos utilizando TIBCO Rendezvous como herramienta de mensajería entre nuestras aplicaciones java, y recientemente me he encontrado con un problema. En este post voy a hablar de dicho problema, así que si no te interesa el tema, ya has terminado de leer el artículo :-)</p>




<!-- more -->




<h2>Problema</h2>




<p>El problema es el siguiente: no soy capaz de que nuestras aplicaciones carguen la librería para poder comunicarse. Más concretamente, estoy obteniendo la siguiente excepción:</p>


<p>```
[...]
Caused by: TibrvException[error=901,message=Library not found: tibrvj]</p>

<pre><code>at com.tibco.tibrv.Tibrv.loadLib(Tibrv.java:474)
at com.tibco.tibrv.Tibrv.open(Tibrv.java:275)
</code></pre>

<p>[...]
```</p>

<p>Antes de nada, voy a contextualizar este error:<br />
El entorno de trabajo es un Windows 7, con procesador Inter de 64 bits, la versión de Tibco Rendezvous es la 8.2 y tengo instalada una JDK de java versión 1.6.0_17.</p>


<p>Googleando el error no llego a ninguna solución en concreto, sólo conversaciónes acerca del classpath de la aplicación. Pero me he dado cuenta de que se deben dar unas condiciones:</p>

<ul>
<li>El fichero <code>tibrvj.jar</code> debe estar accesible en el classpath de la aplicación</li>
<li>La variable de entorno <code>PATH</code> debe contener (entre otros) este valor: <code>%TIBRV_HOME%\bin</code>. Siendo <code>TIBRV_HOME</code> el directorio de instalación de Tibco Rendezvous, por ejemplo y en mi caso es: <code>"C:\tibco\tibrv\8.2"</code></li>
</ul>


<p>Cumplo todas estas condiciones, pero sigo teniendo el error.</p>


<p>La excepción salta cuando en mi aplicación intento cargar la librería Tibrv mediante el código: <code>Tibrv.open(Tibrv.IMPL_NATIVE);</code></p>

<p>Como no puedo ver el código interno de la implementación de Tibco, intento cargar la librería al más bajo nivel, mediante: <code>System.loadLibrary("tibrvj");</code></p>

<p>La librería debería cargar, ya que previamente he comprobado que el fichero <code>tibrvj.dll</code> está accesible a la aplicación, ya que ese fichero está localizado en el directorio <code>%TIBRV_HOME%\bin</code>, incluido en la variable de entorno <code>PATH</code>, y lo puedo comprobar dentro de mi aplicación java leyendo el valor de la variable de sistema <code>java.library.path</code>.</p>


<p>Al ejecutar el código <code>System.loadLibrary("tibrvj");</code> obtengo la siguiente excepción:</p>


<p>```
[...]
Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: C:\TIBCO\tibrv\8.2\bin\tibrvj.dll: Can't load AMD 64-bit .dll on a IA 32-bit platform</p>

<pre><code>at java.lang.ClassLoader$NativeLibrary.load(Native Method)
at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1758)
at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1683)
at java.lang.Runtime.loadLibrary0(Runtime.java:823)
at java.lang.System.loadLibrary(System.java:1028)
</code></pre>

<p>[...]
```</p>

<p>Bueno, ya tengo una pista. Resulta que estoy intentando cargar una librería desarrollada para 64bits en una plataforma (java, supongo) que es de 32bits. Luego, voy a comprobar mi versión instalada de java y si no es de 64bits tendré que instalar una de 64bits.</p>


<p>Compruebo mi versión de java:</p>


<p><code>
C:\&amp;gt;java -version
java version &amp;quot;1.6.0_17&amp;quot;
Java(TM) SE Runtime Environment (build 1.6.0_17-b04)
Java HotSpot(TM) Client VM (build 14.3-b01, mixed mode, sharing)
</code></p>

<p><strong>(FAIL)</strong> No indica nada de que sea java de 64bits, por lo que supongo que será de 32.</p>


<h2>Solución</h2>


<p>Descargo la última versión de java 1.6 de 64bits, la instalo y vuelvo a comprobar la versión instalada:</p>


<p><code>
C:\&amp;gt;java -version
java version &amp;quot;1.6.0_29&amp;quot;
Java(TM) SE Runtime Environment (build 1.6.0_29-b11)
Java HotSpot(TM) 64-Bit Server VM (build 20.4-b02, mixed mode)
</code></p>

<p>Bien! ya tengo instalada una versión de java de 64bits.</p>




<p>Pruebo mi aplicación, ..., FUNCIONA!</p>




<h2>Conclusión</h2>




<p>Todas las soluciones que encontré se centraban solamente en corregir las variables de entorno <code>PATH</code> y <code>CLASSPATH</code>, pero estas soluciones no eran suficientes para mí. Al menos, al acotar el problema mucho más y llegando al un nivel más bajo de abstracción obtuve una pista que me indicó que debería asegurarme de usar una versión de 64bits de java. Una vez instalada la versión correcta del JDK/JRE de java, todo funcionó.</p>


<p>Espero que esta información sea de utilidad a todos aquellos que tienen el problema de encontrarse con la excepción: <code>TibrvException[error=901,message=Library not found: tibrvj]</code></p>

<p>El código completo usado para demostrar este error se puede encontrar aquí:</p>


<p>```
import com.tibco.tibrv.Tibrv;
import com.tibco.tibrv.TibrvException;</p>

<p>public class TibrvLoaderTest {</p>

<pre><code>public static void main(String[] args) {
    new TibrvLoaderTest().start();
}
private void start() {
    printClasspath();
    printLibraryPath();
    testLoadLibrary();
    openTibrvjLibrary();
}
private void printClasspath() {
    String cp = System.getProperty(&amp;quot;java.class.path&amp;quot;);
    for(String cpElement : cp.split(&amp;quot;;&amp;quot;)){
        System.out.println(&amp;quot;Classpath element: &amp;quot; + cpElement);
    }
}
private void printLibraryPath() {
    String lp = System.getProperty(&amp;quot;java.library.path&amp;quot;);
    for(String lpElement : lp.split(&amp;quot;;&amp;quot;)){
        System.out.println(&amp;quot;Library path element: &amp;quot; + lpElement);
    }
}
private void testLoadLibrary() {
    System.loadLibrary(&amp;quot;tibrvj&amp;quot;);
}
private void openTibrvjLibrary() {
    try {
        Tibrv.open(Tibrv.IMPL_NATIVE);
    } catch (TibrvException e) {
        throw new RuntimeException(&amp;quot;Can't load Tibrv&amp;quot;, e);
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lista de logros para ser mejor programador]]></title>
    <link href="http://rchavarria.github.io/blog/2011/09/08/lista-logros-mejor-programador/"/>
    <updated>2011-09-08T09:08:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2011/09/08/lista-logros-mejor-programador</id>
    <content type="html"><![CDATA[<div style="margin:2%; padding:2%; background-color:#E0E0E0; ">
  <p>Este post pertenece a mi antiguo blog en <a href="http://rchavarria.wordpress.com">wordpress</a>, pero decidí pasarme a github:pages por las siguientes <a href="http://rchavarria.github.io/blog/2012/12/03/por-que-cambie-mi-blog-en-wordpress-com">razones</a></p>
</div>


<p>Me he permitido copiar el título del post del blog donde encontré la idea para escribir el mío propio: <a title="Lista de logros para ser mejor programador" href="http://kinisoftware.com/blog/2011/08/17/lista-de-logros-para-ser-un-mejor-programador/">Lista de logros para ser mejor programador</a> (que a su vez fue inspirado por <a href="http://jasonrudolph.com/blog/2011/08/09/programming-achievements-how-to-level-up-as-a-developer/">Jason Rudolph</a>) y espero que la palabra se extienda y poco a poco se cree toda una marea de programadores que queremos mejorar.</p>

<!-- more -->


<p>La idea original es hacer públicos una serie de logros que se quieren conseguir como programador. Yo he hecho lo propio y he comenzado haciendo un fork del gist original de Jason: <a title="https://gist.github.com/1189847" href="https://gist.github.com/1189847">https://gist.github.com/1189847</a></p>

<p>Me gusta mucho la idea de exponer, de publicar las metas que uno quiere conseguir. Eso hace que te esfuerces más por llegar a ellas, por hacerlas realidad. Espero que hacerlas públicas me ayude, y también que inspire a otros profesionales del desarrollo del software para tomar iniciativas similares.</p>

<p>Yo en particular no estoy de acuerdo con todas las metas de Jason, por lo que iré modificando mi gist con mis propias metas. Puede que no sean tan ambiciosas como las de Jason, puede que sean menos concretas. Pero serán las mías.</p>

<p>Como bonus, me gustaría compartir un enlace relacionado con el aprendizaje perpetuo. En <a href="http://www.etnassoft.com/2011/07/14/tu-no-sabes-programar/">Tú no sabes programar</a> encontré varios de las metas con las que empezar a personalizar mi gist de logros para ser mejor desarrollador: patrones y principios de diseño, metodologías y disciplinas de desarrollo, herramientas, ...</p>

<h3>Enlaces relacionados:</h3>




<ul>
    <li><a href="http://jasonrudolph.com/blog/2011/08/09/programming-achievements-how-to-level-up-as-a-developer/">Post original</a></li>
    <li><a href="https://gist.github.com/1133830">Gist original</a></li>
    <li><a href="http://kinisoftware.com/blog/2011/08/17/lista-de-logros-para-ser-un-mejor-programador/">Post inspirador</a></li>
    <li><a href="https://gist.github.com/1189847">Mi propio gist</a></li>
    <li><a href="http://www.etnassoft.com/2011/07/14/tu-no-sabes-programar/">Material para aprender</a></li>
</ul>




<h3>¿Qué es un gist?</h3>




<div>Traducción libre de la página de <a href="https://gists.github.com">gists de github</a>:</div>




<blockquote>
<div>Gist es una forma sencilla de compartir con otros pequeños archivos de ejemplo. Todos los gists son repositorios git, por lo que son automáticamente versionados, pueden ser duplicados y usados como un repositorio git.</div></blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Heisenbugs]]></title>
    <link href="http://rchavarria.github.io/blog/2011/02/24/heisengugs/"/>
    <updated>2011-02-24T02:24:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2011/02/24/heisengugs</id>
    <content type="html"><![CDATA[<blockquote>¡Bien! Ya tengo mi nueva funcionalidad implementada. La aplicación va a ser de lo mejorcito con lo que acabo de desarrollar. Llevo depurando este código toda la tarde. ¿Qué puede fallar? He recorrido instrucción por instrucción y todo se ejecuta según lo previsto.

Lanzo la aplicación ...

¡WTF! ¡Un null pointer! ¡No puede ser! si lo he depurado miles de veces.</blockquote>


<p>¿Nunca os habéis encontrado con un error de este tipo?</p>

<!-- more -->


<p>Yo muchas veces, pero no se me había ocurrido ponerle nombre. Hace poco, mientras leía <a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">Java concurrency in practice</a> de Brian Goetz (y otros autores) encontré el nombre, y me gustó tanto que decidí escribir sobre ello. Mucho tiempo después aquí está la entrada.</p>

<p>El nombre en cuestión es <strong>heisenbug. </strong>Me gustó mucho porque mezcla con sentido del humor los conceptos de <em>bug</em> (estoy hablando de un error en una aplicación, ¿recuerdas?) y <em> Heisenberg</em>. La mezcla de este segundo concepto es lo que me hizo gracia: se refiere a un bug que aparentemente no somos capaces de reproducirlo, por lo que no podemos conocer dónde se está produciendo, es decir, su <em>posición. </em>Es similar al <a title="principio de incertidumbre" href="http://es.wikipedia.org/wiki/Relaci%C3%B3n_de_indeterminaci%C3%B3n_de_Heisenberg">principio de incertidumbre</a> de <a title="Werner Heisenberg" href="http://es.wikipedia.org/wiki/Werner_Heisenberg">Werner Heisenberg</a>, que en palabras llanas dice:</p>

<blockquote>No se puede determinar, en términos de la física clásica, simultáneamente y con precisión arbitraria, ciertos pares de variables físicas, como son, por ejemplo, la posición y el momento lineal de una partícula (digamos un electrón).</blockquote>


<p>En realidad, el problema siempre ha estado ahí, pero no se dieron las condiciones adecuadas para que el error <em>apareciera</em>, es decir, no hemos sido capaces de conocer su <em>posición</em>.</p>

<p>No viene a cuento, pero <a href="http://www.microsiervos.com">Microsiervos </a>lleva una temporada publicando términos que podrían incluirse en un <em><a href="http://www.microsiervos.com/archivo/microciervadas-varias/geekccionario-04.html">geekcionario</a></em>, entre los cuales podría encajar <em>heisenbug.</em></p>

<p>Nota: Los autores de <em>Java concurrency in practice</em> son: Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, Doug Lea.</p>
]]></content>
  </entry>
  
</feed>
