<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: learning | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/learning/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2018-01-17T22:33:23+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir: undécimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/10/30/elixir-undecimo-asalto/"/>
    <updated>2017-10-30T21:06:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/10/30/elixir-undecimo-asalto</id>
    <content type="html"><![CDATA[<p>Nos acercamos al final y en este asalto aprenderemos qué son las <a href="https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html">Aplicaciones
OTP</a>, aunque en realidad ya hemos estado usando algunas. Aprenderemos cómo
<code>mix</code> facilita mucho la tarea y cómo esta herramienta nos permite empaquetar
nuestra aplicación para ser distribuida. Aprenderemos a definir el punto de
entrada de ejecución y cómo pasar parámetros iniciales. Las aplicaciones, junto
con los servidores y supervisores OTP hacen de este framework una herramienta
potentísima para desarrollar aplicaciones.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/fingers.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/9cXZUG">Asaltos</a> de <a href="https://www.flickr.com/photos/antoniobugarin/">Antonio Bugarin</a>, <a href="https://creativecommons.org/licenses/by/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Aplicaciones OTP</h4>

<p>Una <em>aplicación</em> en el mundo Elixir no es lo que normalmente conocemos como
tal. El término viene del mundo Erlang, y con <em>aplicación</em> se refieren más a lo
que comúnmente conocemos como componente, o servicio (¿microservicio podría
valer aquí?, probablemente). Una aplicación OTP en Elixir es como un servicio
del que puede depender de otros servicios, y que puede arrancar servidores y
supervisores.</p>

<p>Por lo general, las aplicaciones son dependencias de los programas que estamos
desarrollando. Pero otras aplicaciones residen en la parte más alta del árbol
de procesos, y éstas están diseñadas para ejecutarse directamente.</p>

<p><strong>El fichero de configuración de la aplicación</strong></p>

<p>La herramienta <code>mix</code> crea un fichero llamado <code>&lt;tu-aplicacion&gt;.app</code>. Este
fichero es la especificación de la aplicación, y contiene información que se
suele escribir en <code>mix.exs</code> e información de la compilación de nuestro código.
Cuando se lanza la aplicación, este fichero es consultado para saber cómo
cargarla y arrancarla.</p>

<p><strong>Creando una aplicación OTP</strong></p>

<p>En realidad ya hemos creado varias. Por ejemplo, el programa <em>Sequence</em>, de la
ronda anterior, lo ejecutábamos como si fuera una aplicación OTP. Cuando
creamos un nuevo proyecto con <code>mix</code>, éste añade un supervisor por defecto e
información en <code>mix.exs</code> para poder ejecutar el proyecto como una aplicación.
Más concretamente, <code>mix</code> crea la función <code>application</code>:</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] }
</code></pre>

<p>  ]
end
```</p>

<p>El código anterior indica que el módulo principal se llama <code>Sequence</code>. OTP
asume que dicho módulo implementa una función llamada <code>start</code> (porque Elixir
define un <em>behaviour</em> <code>Application</code> que deben implementar las aplicaciones OTP
para ser consideradas como tal), a la cual le va a pasar el parámetro indicado
en la tupla (en este caso un array vacío). Si la tupla hubiera sido <code>{
Sequence, 1234 }</code> el parámetro pasado a la función <code>start</code> hubiera sido <code>1234</code>.</p>

<p>Esto es lo relativo a la opción <code>mod:</code>. Pero a la hora de configurar una
aplicación existe otra opción: <code>registered:</code>. Esta opción lista los nombres que
nuestra aplicación va a registrar. Podemos usar esto si queremos que dichos
nombres sean únicos entre todas las aplicaciones cargadas en el nodo o cluster:</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] },
registered: [
  Sequence.Server,
  "Any other name"
]
</code></pre>

<p>  ]
end
```</p>

<p>Ahora podemos ejecutar el comando <code>mix compile</code> para generar el fichero <code>.app</code>.
Este fichero se almacena en la ruta nada intuitiva de
<code>_build/dev/lib/sequence/ebin</code>. Este fichero define una tupla Erlang que define
la aplicación. <code>mix</code> ha añadido automáticamente los módulos de los que consta
la aplicación y las aplicaciones de las que depende, por ejemplo <code>kernel</code>,
<code>stdlib</code> o <code>elixir</code>.</p>

<p>A la hora de pasar parámetros de inicialización a las aplicaciones existe otra
posibilidad. La opción <code>env</code>, que acepta una lista de palabras clave (<em>keyword
list</em>)</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] },
env: [ initial_number: 12334 ],
registered: [...]
</code></pre>

<p>  ]
end
```</p>

<p>Para después recuperar ese valor con <code>Application.get_env</code>:</p>

<p>```
defmodule Sequence do
  use Application
  def start(<em>type, </em>args) do</p>

<pre><code>initial_number = Application.get_env(:sequence, :initial_number)
#...
</code></pre>

<p>```</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-11/stack">Ejercicio 1</a>: convierte tu servidor <code>Stack</code> en una aplicación OTP</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/sequence">Ejercicio 2</a>: hasta ahora no hemos testeado para nada ninguna aplicación.
Mira a ver qué puedes hacer. Testear un server no parece algo muy sencillo,
no parece que se pueda ejecutar a la primera, porque el server debería estar
ejecutándose para poder <em>funcionar</em>. Pero Elixir está muy enfocado a los tests
automáticos, así que algo debe de existir.</p></li>
</ul>


<p><strong>Resultados</strong></p>

<p>Y tanto que existe. Encontré el artículo <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html#testing-a-genserver">cómo se testea un <code>GenServer</code></a>, en la
documentación oficial: básicamente, en el <em>set up</em> de los tests, se levanta el
server. Luego, se puede llamar a la API del servidor tranquilamente. Al
parecer, si el proyecto está configurado como una aplicación, <code>mix</code> arranca la
aplicación, por lo que no hace falta levantar el server en el <em>set up</em>. Lo
malo, que no se puede inicializar con ningún valor de test.</p>

<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: décimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/06/07/elixir-decimo-asalto/"/>
    <updated>2017-06-07T21:29:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/06/07/elixir-decimo-asalto</id>
    <content type="html"><![CDATA[<p>En este asalto aprenderemos qué son los <a href="https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html">Supervisores OTP</a> y cómo se puede
crear una estructura jerárquica de ellos de forma que monitoricen nuestros
procesos y sean capaz de arrancar nuevos procesos en caso de que alguno de
ellos falle. También veremos cómo unos procesos sirven de ayuda para guardar el
estado de aquellos procesos que necesitan ser tolerantes a fallos.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/darth-grader.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/pxJ3o5">Darth Grader</a> de <a href="https://www.flickr.com/photos/jdhancock/">JD Hancock</a>, <a href="https://creativecommons.org/licenses/by/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Supervisores OTP</h4>

<p>La forma de hacer las cosas en Elixir es no preocuparse mucho por el código que
falla, si no asegurarse de que la aplicación en general sigue corriendo. Suena
contradictorio, pero no lo es. En Elixir los procesos son muy pequeñitos, por
lo que si uno de ellos falla, casi todo el sistema sigue funcionando. Al
contrario que en otros lenguajes, donde el lanzamiento de una excepción puede
hacer que todo el servidor sufra. <strong>En el mundo OTP, los supervisores son
quienes monitorizan y recuperan esos procesos fallidos</strong>.</p>

<p>Un supervisor en Elixir tiene un único propósito: manejar uno o más <em>workers</em>
(otro tipo de procesos). La forma de funcionar es darle una lista de procesos e
indicarle qué hacer con cada uno de ellos en caso de que falle. La forma más
fácil de crear un supervisor es crear un nuevo proyecto con <code>mix</code> y usar el
flag <code>--sup</code>.</p>

<p>```
defmodule Sequence do
  use Application
  def start(<em>type, </em>args) do</p>

<pre><code>import Supervisor.Spec, warn: false
children = [
  worker(Sequence.Worker, [arg1, arg2, arg3])
]
opts = [strategy: :one_for_one, name: Sequence.Supervisor]

# create the supervisor with a list of workers and some options
Supervisor.start_link(children, opts)
</code></pre>

<p>  end
end
```</p>

<h4>Gestionando el estado del servidor entre reinicios</h4>

<p>Como se puede comprobar al jugar con el supervisor y el servidor creados en el
[Ejercio 01], el servidor es reiniciado, pero no mantiene el estado anterior al
fallo, si no que siempre se reinicia con el estado inicial, indicado a la hora
de crear el supervisor. Esto se puede mejorar.</p>

<p>La forma de mantener el estado es almacenándolo fuera del proceso servidor.
Esto se hace mediante un nuevo <em>worker</em>, un nuevo servidor, al que se le llama
<em>stash</em>. Nuestro servidor almacenará su estado actual en ese <em>stash worker</em>. El
<em>stash worker</em> debe ser monitorizado por un supervisor diferente, por lo que
tenemos que crear un arbol de supervisores. En este árbol, nuestro <em>worker</em>
principal debe conocer el PID del <em>stash</em>, con lo que la forma de crear el
árbol cambia ligeramente de la forma que hemos visto anteriormente.</p>

<p><img class="center" src="/images/2017/supervisor-tree.png"></p>

<p>La aplicación funcionaría de la siguiente forma:</p>

<ol>
<li>Primero, arrancamos el supervisor raíz del árbol, pasándole el valor inicial
que será el estado inicial del sistema</li>
<li>Este supervisor arranca el <em>stash worker</em>, pasando el valor inicial (porque
este worker almacenará el estado del sistema) y arranca un sub-supervisor,
pasándole el PID del stash</li>
<li>El sub-supervisor arranca el worker principal, el que contiene la lógica,
quien incrementa el valor inicial con el que arrancamos el sistema</li>
<li>El worker principal, nada más arrancar, consulta al stash worker el estado
actual, y es con ese estado con el que va a trabajar</li>
<li>Si el worker principal falla por cualquier causa, debe enviar su estado al
stash worker, para que lo almacene</li>
<li>El sub-supervisor detectará que el proceso a muerto y reiniciará de nuevo el
worker principal, que leerá el estado del worker que murió del stash worker</li>
</ol>


<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/stack">Ejercicio 1</a>: añade un supervisor a la aplicación anterior que implementaba
una pila de enteros</li>
</ul>


<p><strong>Resultado</strong></p>

<p>Increíble, increíble que sea tan fácil. Lo primero, el supervisor arranca él
solito y levanta el servidor él solito también. Super cómodo. Luego, captura
los errores y levanta de nuevo el servidor sin que nosotros tengamos que hacer
nada más. Para hacer fallar a la pila, se podía hacer con un
<code>Stack.Server.push -1</code>. El supervisor captura el fallo, y rearranca el
servidor.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/sequence">Ejercicio 2</a>: vuelve a crear una aplicación similar a la anterior, pero
creando un árbol de supervisores, y un stash worker, de forma que cuando el
worker principal falle, el estado sea guardado. Comprueba que el sistema
mantiene el estado cuando el worker principal falla</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: noveno asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/01/29/elixir-noveno-asalto/"/>
    <updated>2017-01-29T17:19:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/01/29/elixir-noveno-asalto</id>
    <content type="html"><![CDATA[<p>En el <a href="/blog/2016/12/31/elixir-octavo-asalto/">asalto anterior</a> aprendimos un par de conceptos básicos sobre los nodos.
En este asalto aprenderemos sobre servidores OTP: qué son, para qué sirven, por
qué son útiles y cómo implementarlos fácilmente.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/us-air-force.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/R7mJ4M">160324-F-XK483-042</a> de <a href="https://www.flickr.com/photos/usairforce/">US Air Force</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/">CC BY NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Servidores OTP</h4>

<p>OTP (<strong>O</strong>pen <strong>T</strong>elecom <strong>P</strong>latform) se presenta como la solución a todos
tus problemas de escalabilidad y concurrencia. No es así, pero ayuda mucho.
Ayuda en temas como descubrimiento de aplicaciones, gestión y detección de
fallos, actualización de código en caliente y estructura del servidor.</p>

<p>OTP define un sistema como una jerarquía de <strong>aplicaciones</strong>. Una aplicación
consiste en uno o varios <strong>procesos</strong>. Cada uno de estos procesos implementa
un <strong>comportamiento</strong>. Existen <a href="http://rubenfa.github.io/2016-11-30-behaviours-en-elixir">comportamientos</a> para servidores, gestores de
eventos, máquinas de estado finitas, ...</p>

<p>Lo implementado en ejercicios anteriores sigue un patrón con el que se podría
implementar casi todos los servidores. Por eso, OTP proporciona un mecanismo
para liberarnos de escribir el código más tedioso. La librería ofrece unas
funciones a modo de <em>callbacks</em> que irá llamando dependiendo de la situación.</p>

<h4>Implementar un servidor OTP</h4>

<p>```
defmodule Sequence.Server do
  use GenServer</p>

<p>  def handle_call(:next_number, _from, current_number) do</p>

<pre><code>{ :reply, current_number, current_number + 1 }
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>use GenServer</code> indica a Elixir que vamos a usar este comportamiento. Así, este
módulo representa un servidor OTP.</p>

<p>Uno de los callbacks proporcionados por <code>GenServer</code> es <code>handle_call</code>. Tiene 3
parametros: acción, PID del origen de la petición y el estado actual del
servidor. Tiene que responder con una tupla con tres parámetros también: la
respuesta, el valor retornado y el estado del servidor a usar en la siguiente
llamada.</p>

<p>Para llamar a este servidor, entramos en <code>iex</code>. Arrancamos el servidor,
indicando el módulo y el estado inicial (similar a <code>spawn_link</code>).</p>

<p><code>
promtp$ iex -S mix
iex&gt; { :ok, pid } = GenServer.start_link(Sequence.Server, 100)
iex&gt; GenServer.call(pid, :next_number)
100
iex&gt; GenServer.call(pid, :next_number)
101
iex&gt; GenServer.call(pid, :next_number)
102
</code></p>

<h4>Servidores que no tienen que devolver un resultado</h4>

<p>En ocasiones no necesitamos que el servidor retorne un resultado. En estos
casos, para llamar al servidor emplearemos <code>GenServer.cast</code>, y para manejar
esas peticiones, nuestro servidor debe implementar el callback <code>handle_cast</code>.</p>

<h4>Callbacks de GenServer</h4>

<p>GenServer es un protocolo de OTP. OTP asume que este protocolo define 6
callbacks. Elixir proporciona una implementación por defecto para cada uno de
ellos en GenServer, por eso no tenemos que implementarlos nosotros. Los 6
callbacks son: <code>init(start_arguments)</code>, <code>handle_call(request, from, state)</code>,
<code>handle_cast(request, state)</code>, <code>handle_info(info, state)</code>,
<code>terminate(reason, state)</code>, <code>code_change(from_version, state, extra)</code> y
<code>format_status(reason, [ pdict, state ])</code>.</p>

<h4>Nombrado de procesos</h4>

<p>En lugar de usar el PID para referenciar a procesos de nuestro servidor,
podemos hacerlo a través de nombres. Para ello, se debe utilizar la opción
<code>name:</code> a la hora de crear el servidor:</p>

<p><code>
iex&gt; { :ok, pid } = GenServer.start_link(Sequence.Server, 100, name: :seq)
iex&gt; GenServer.call(:seq, :next_number)
100
iex&gt; GenServer.call(:seq, :next_number)
101
iex&gt; GenServer.call(:seq, :next_number)
102
iex&gt; :sys.get_status :seq
</code></p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack">Ejercicio 01</a>: crear un server que implemente una pila. Se
inicializará con unos cuantos valores en la pila. Cada petición <em>pop</em>
devolverá un elemento de la pila. Cuando la pila esté vacía, fallará.
Implementado en el proyecto <code>mix</code>: <code>code/round-09/stack</code>.</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack2">Ejercicio 02</a>: ampliar el servidor anterior, de forma que se puedan
añadir elementos a la pila con la operación <code>:push</code> a través de peticiones
<em>cast</em>. Implementado en el proyecto <code>mix</code>: <code>code/round-09/stack2</code>.</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack3">Ejercicio 03</a>: dar un nombre al servidor anterior, de forma que se le
pueda llamar sin necesidad de saber el PID. También, crear un API en la pila
de forma que los clientes no tengan que llamar a <code>GenServer</code> para usarla.
Simplemente serán unas funciones que envolverán las llamadas a <code>GenServer</code>.
Implementado en otro proyecto <code>mix</code>, en <code>code/round-09/stack3</code>.</p></li>
<li><p>Ejercicio 04: implementar el callback <code>GenServer.terminate/2</code> para
comprobar distintas formas de terminar el servidor: un callback lanza una
excepción, una llamada a <code>Kernel.exit/1</code>, se detecta que un proceso ha tenido
un error,...</p></li>
</ul>


<p><strong>Resultado</strong></p>

<p>No he obtenido nada en claro. Tendría que profundizar en la documentación de
<a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html#c:terminate/2"><code>GenServer.terminate/2</code></a>,
que parece bastante espesa por cierto. Pero no está garantizado que se llame a
<code>terminate</code>, con lo que no sé si estoy provocando correctamente los errores.</p>

<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>

<h2>Referencias</h2>

<ul>
<li>Proceso de <a href="/blog/2016/01/17/aprendiendo-elixir/">aprendizaje de Elixir</a></li>
<li>Artículo sobre <a href="http://rubenfa.github.io/2016-11-30-behaviours-en-elixir">comportamientos</a> (<em>behaviours</em>) en Elixir</li>
<li>Artículo sobre <a href="http://rubenfa.github.io/2017-01-25-protocols-en-elixir">protocolos</a> en Elixir</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: octavo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/12/31/elixir-octavo-asalto/"/>
    <updated>2016-12-31T19:13:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2016/12/31/elixir-octavo-asalto</id>
    <content type="html"><![CDATA[<p>Último post del año, que no de la serie sobre aprender <a href="http://elixir-lang.org/">Elixir</a>. Este asalto va de nodos, PIDs y un poquito (muy poco) de entrada/salida.</p>

<p>Aprenderemos qué es un nodo, cómo crear nuevos nodos y cómo comunicarlos a un nivel muy básico. Y algo muy interesante, cómo hacer que un nodo ejecute una función a nuestro antojo.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2016/risk.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/3pUVs">Risk</a> de <a href="https://www.flickr.com/photos/benstephenson/">Ben Stephenson</a>, <a href="https://creativecommons.org/licenses/by/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Nodos - La clave para los servicios distribuidos</h4>

<p>Un <strong>nodo</strong> no es más que una instancia de la máquina virtual de Erlang
ejecutándose. Es como un sistema operativo completo, y ofrece servicios como
tal a procesos locales o remotos.</p>

<h5>Nombres de nodos</h5>

<p>En <code>iex</code>, podemos saber el nombre del nodo actual con <code>Node.self</code>:</p>

<p><code>
iex&gt; Node.self
:"rchavarria@localhost"
</code></p>

<p>Podemos dar un nombre al nodo al iniciar <code>iex</code>:</p>

<p><code>
$ iex -name foobar@localhost
iex(foobar@localhost)&gt; Node.self
:"foobar@localhost"
</code></p>

<p>Si te fijas, el valor devuelto por <code>Node.self</code> tiene los dos puntos delante,
como si fuera un <code>Atom</code>. Y es que en Elixir, los nombres de los nodos son
tratados como <code>Atom</code>s, lo que hace super sencillo referenciar nodos en el
código.</p>

<p>También, podemos saber qué nodos conoce un nodo al que estemos conectados:</p>

<p>```
iex(node_two)> Node.list
[]</p>

<h1>y al conectarnos a un nodo, aparecerá como conectado</h1>

<p>iex(node_two)> Node.connect :"node_one@localhost"
true
iex(node_two)> Node.list
[ :"node_one@localhost" ]
```</p>

<p>Podemos ejecutar una función en un nodo remoto:</p>

<p><code>
iex(node_one)&gt; func = fn -&gt; IO.puts "Hello, I'm in #{inspect Node.self}"
iex(node_one)&gt; Node.spawn( :"node_two@localhost", func )
Hello, I'm in :"node_two@localhost"
</code></p>

<p><code>Node.spawn</code> es impresionante. Podemos ejecutar una función en otro nodo
fácilmente. Pero aunque se ejecute en <code>node_two</code>, hereda lo que se llama <em>group
leader</em>, con lo que es capaz de mostrar mensajes por consola en <code>node_one</code> (en
lugar del dos, que es donde se ejecuta).</p>

<p>Además de poder dar un nombre a un nodo, podemos establecer su <em>cookie</em>. La
cookie de un node no es más que un token, y se utiliza para permitir que los
nodos se conecten entre sí. Nodos con la misma cookie se pueden conectar. Si es
distinta, los nodos rechazarán la conexión. Las cookies se mandan en texto
plano, así que cuidado con las conexiones a través de internet.</p>

<h5>Nombrando tus procesos</h5>

<p>Cada proceso se identifica con un PID. Un PID está compuesto por tres números,
aunque sólo contiene dos campos: el número de nodo (<code>0</code> si el nodo es el local)
y el número de proceso en sí. Este número de proceso está compuesto por sus
bits más y menos representativos (de ahí que veamos tres números en un PID como
éste <code>#PID&lt;0.71.0&gt;</code>). El id de node es el id del nodo donde <em>vive</em> el proceso.</p>

<h4>Entrada/salida, PIDs y Nodos</h4>

<p>La entrada/salida en la máquina virtual de Erlang se hace a través de
servidores de entrada/salida. Elixir y Erlang proporcionan librerías para no
tener que lidiar con ellos, ya que son a muy bajo nivel.</p>

<p>En Elixir, se identifica un fichero por el PID del proceso del servidor de
entrada/salida que lo está manejando.</p>

<p>Por ejemplo, la función <code>IO.puts</code> utiliza el PID devuelto por
<code>:erlang.group_leader()</code> como valor por defecto para enviar una cadena al
proceso que la muestra por consola: <code>send :erlang.group_leader(), str</code> podría
ser el código equivalente.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li>Ejercicio 1: en el código del servidor de ticks (<a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-08/ticker.ex">ticker.ex</a>), el autor habla
de que el tick se envía cada 2 segundos más o menos.  Pero el timeout está
puesto a 2 segundos exactos. ¿Por qué habla de <em>más o menos</em>?</li>
</ul>


<p><strong>Respuesta</strong></p>

<p>El timeout es de justo 2 segundos, pero el timeout solo saltará si no se
registra ningún cliente en esos 2 segundos. Si un cliente se registra (digamos
en el momento 1.55 segundos) no saltará el timeout hasta los 3.55 segundos
siguientes (1.55 segundos que pasaron desde el anterior tick hasta el registro
del último cliente más 2 segundos del timeout normal).</p>

<ul>
<li><p>Ejercicio 2: modificar el servidor de ticks para que mande solo un
tick cada vez, de forma circular, a cada uno de los clientes registrados (el
primer tick al primer cliente, el segundo tick al segundo cliente
registrado,...). El programa deberá lidiar con nuevos clientes registrados.</p></li>
<li><p>Ejercicio 3: reimplementar el servidor de ticks, pero esta vez
debe ser circular, de forma que el cliente 1 mande un tick al cliente 2.
Pasados 2 segundos, el cliente 2 mandará un tick al 3. Y así hasta el último, el cual
enviará un tick al 1. Y vuelta a empezar. El problema está en cómo añadir
clientes al círculo (o <em>ring</em>) y quién tiene la responsabilidad de actualizar
ese círculo de clientes.</p></li>
</ul>


<p><strong>Respuesta</strong></p>

<p>Me costó un tiempo dar con la solución al ejercicio (<a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-08/ring_ticker.ex">ring_ticker.ex</a>). Puede
que el <em>ring</em> lo tenga que gestionar el servidor central. De otra forma, los
clientes perderán el timeout del <code>receive</code> y se volverán un poco locos.</p>

<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: séptimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto/"/>
    <updated>2016-09-18T16:20:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto</id>
    <content type="html"><![CDATA[<p>El aprendizaje va avanzando, ya vamos por el séptimo asalto. Éste trata sobre
cómo <a href="http://elixir-lang.org/">Elixir</a> maneja múltiples procesos, por lo que trataremos algún tema de
concurrencia. También veremos algunas cosas básicas sobre cómo monitorizar los
procesos de los que consta nuestra aplicación.</p>

<p>Sin olvidar del método de aprendizaje con el que <a href="/blog/2016/01/17/aprendiendo-elixir/">comenzé</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/you-gotta-fight-for-your-right-to-eat.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/4rvPED">You gotta fight for your right to... eat</a> de <a href="https://www.flickr.com/photos/r2wk/">ldjpg</a>, <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">CC BY NC ND 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Trabajando con múltiples procesos</strong></p>

<p>Elixir usa el <a href="https://en.wikipedia.org/wiki/Actor_model">modelo de actores</a> para gestionar la concurrencia.</p>

<p>Elixir se apoya en Erlang para gestionar los procesos, que no son los procesos
del sistema operativo.</p>

<p>Para crear un proceso, se hace con la llamada <code>spawn</code>. <code>spawn</code> puede crear un
proceso y ejecutar en él código que tengas en un módulo cualquiera. El proceso
puede empezar en cualquier momento (asíncrono total) y se utilizan mensajes
entre procesos para sincronizarlos.</p>

<p>Los mensajes no tienen por qué ser <code>Strings</code>, pueden ser de cualquier tipo
(generalmente tuplas o atoms). Los mensajes se mandan con <code>send</code>, y debes usar
un <code>PID</code> (devuelto por <code>spawn</code>).</p>

<p>El receptor, espera mensajes con <code>receive</code>. <code>receive</code> funciona como <code>case</code>: se
pueden poner varios casos, y el primero que coincida, se ejecuta.</p>

<p><code>receive</code> maneja sólo un mensaje. Si queremos recibir varios, debemos volver a
llamar al método que contiene el <code>receive</code>, de forma recursiva (y Elixir es muy
bueno con la recursividad). <code>receive</code> también acepta un parámetro, <code>after</code>,
para definir un timeout.</p>

<p>El autor dice que los procesos en Elixir son como los objetos en lenguajes
orientados a objectos, pero con mejor sentido del humor. El hecho es que son
muy livianos, y pueden mantener estado, así que podemos pensar en ellos como en
objetos de la programación orientada a objetos.</p>

<p><strong>Enlazar procesos</strong></p>

<p>Normalmente, un proceso no sabe cuando muere un proceso hijo. Debemos hacer
algo manualmente para que se notifique. Podemos crear procesos <em>enlazados</em>
(linked) con <code>spawn_link</code>. Por defecto, si un proceso hijo muere, mata al
proceso padre. Para controlar esto y poder escuchar el mensaje que lanza el
proceso hijo al morir, debemos <em>atrapar la salida</em> mediante
<code>Process.flag(:trap_exit, true)</code> justo antes de hacer <code>spawn_link</code>.</p>

<p>Dos procesos enlazados pueden comunicarse bidireccionalmente.</p>

<p>Elixir usa el framework OTP para construir árboles de procesos. OTP lleva mucho
tiempo en funcionamiento, y debemos confiar en que lo hace mucho mejor que
nosotros, por lo que lo usaremos prácticamente siempre. OTP incluye el concepto
de <em>Supervisor de procesos</em>. Más adelante estudiaremos temas relacionados con
OTP.</p>

<p><strong>Monitorizando procesos</strong></p>

<p>Si <code>spawn_link</code> permite comunicación bidireccional, <code>spawn_monitor</code> solo la
permite unidireccional. El proceso hijo puede notificar al padre, pero no al
revés.</p>

<p>```</p>

<h1>monitor devuelve el pid del proceso hijo y una referencia de la monitorización</h1>

<p>res = spawn_monitor(<module>, <function>, <params>)
IO.inspect res</p>

<h1>=> { #PID{3.3.3.3}, #Reference{1.2.3.4} }</h1>

<p>```</p>

<p>También se puede monitorizar un proceso existente con <code>Process.monitor</code>.</p>

<p>¿Cuándo utilizar cada uno? Depende de la utilidad. Si la muerte de un hijo
debería matar al padre, usa procesos enlazados. Si la muerte/fallo de un hijo
solamente debería notificar al padre, usa monitorización.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-01-round-07.exs">exercise-01-round-07.exs</a>: ejecutar el programa que pasa mensajes en cadena
de un proceso a otro hasta llegar al millón de procesos.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-02-round-07.exs">exercise-02-round-07.exs</a>: escribir un código que cree dos procesos, y que a
cada uno le mande un token (p.e.: "pepito" y "fulanito"), y que los procesos
lo devuelvan. En teoría, ¿es determinista el orden en el que se reciben las
respuestas? ¿Y en la práctica? En caso de que no, ¿cómo podría hacerse que
fuera determinista?.</li>
</ul>


<p><strong>Resultados</strong></p>

<p>Parece que sí es determinista (al menos con dos procesos). Depende del orden en
el que se creen los procesos, incluso si invertimos el orden en el que se
envían los tokens, el primer proceso creado es el primero en responder.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-03-round-07.exs">exercise-03-round-07.exs</a>: usa <code>spawn_link</code> para crear un proceso, el cual
envía un mensaje al padre y finaliza inmediatamente. Mientras, en el padre,
después de crear el proceso, espera 500ms y luego comienza a recibir todos los
mensajes que están esperando. Tracea todo lo que recibas. ¿Importa que no
estuvieras recibiendo notificaciones cuando el hijo terminó?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No recibe ningún mensaje, el hijo termina, terminando al padre durante la
espera.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-04-round-07.exs">exercise-04-round-07.exs</a>: repite el ejercicio anterior, pero en lugar de
terminar con <code>exit</code>, que el hijo lance una excepción. ¿qué diferencia notas?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No hay mucha difrencia. El padre sigue terminando, sin escuchar ningún mensaje.
Al menos, la excepción aparece por consola, mostrándose un error diciendo que
el proceso hijo (con su PID) ha lanzado una excepción. En el ejercicio
anterior, solamente aparecía que el proceso padre terminaba, nada más.</p>

<p>Usando <code>Process.flag(:trap_exit, true)</code>, el proceso padre recibe mensajes:</p>

<p>```
$ elixir -r exercise-03-round-07.exs -e "Exercise3.run"
Parent's PID #PID&lt;0.48.0>
PID's child #PID&lt;0.53.0>
Received: "Hello!"
Received: {:EXIT, #PID&lt;0.53.0>, :boom}</p>

<p>$ elixir -r exercise-04-round-07.exs -e "Exercise4.run"
Parent's PID #PID&lt;0.48.0>
Child's PID #PID&lt;0.53.0></p>

<p>22:46:14.313 [error] Process #PID&lt;0.53.0> raised an exception
** (RuntimeError) Child finished</p>

<pre><code>exercise-04-round-07.exs:19: Exercise4.child/1
</code></pre>

<p>Received: "Hello!"
Received: {:EXIT, #PID&lt;0.53.0>, %{RuntimeError{message: "Child finished"},
[{Exercise4, :child, 1, [file: 'exercise-04-round-07.exs', line: 19]}]}}
```</p>

<p>Las diferencias están en lo recibido en el mensaje de terminación del hijo. En
caso de <code>exit</code> se recibe <code>:EXIT</code>, un PID, y la causa de la salida. En el caso
de la excepción: <code>:EXIT</code>, un PID y la excepción, parece, porque tiene pinta de
pila de llamadas, con su módulo, función, parámetros,...</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-05-round-07.exs">exercise-05-round-07.exs</a>: repetir el ejercicio pero con <code>spawn_monitor</code>.</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No creo que lo esté haciendo bien. Se supone que monitorizando la comunicación
no es bidireccional, pero el padre recibe el mensaje que envía el hijo, así
como el mensaje que se envía al terminar o lanzar la excepción. La única
diferencia visible es que en lugar de recibir solamente un PID, se recibe un
PID y la referencia de monitorización.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-06-round-07.exs">exercise-06-round-07.exs</a>: escribir una función implementando <em>pararell
map</em>, que es como una función <code>map</code> pero cada elemento es procesado por un
proceso distinto. Preguntas: ¿por qué es necesario guardar en la variable <code>me</code>
el PID del proceso padre? Se debe utilizar <code>^pid</code> para recibir los resultados
en orden, pero... ¿qué pasa si se utiliza <code>_pid</code>? ¿cómo hacer para que falle:
esperas, aumentar número elementos, que la función que procesa cada elemento
sea más complicada,...?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>Aumentando el número de elementos afecta al orden en el que se reciben los
mensajes. También he conseguido recibir mensajes en orden distinto con el
siguiente código:</p>

<p><code>
Parallel.pmap 1..10, fn (i) -&gt;
  # la espera es más corta según el elemento `i` se va a haciendo mayor
  wait_up_to = round(10 / i)
  :timer.sleep(wait_up_to)
  i
end
  #=&gt; [ 7, 8, 9, 10, 5, 6, 3, 4, 2, 1 ]
</code></p>

<p>Volviendo a poner <code>^pid</code> el orden vuelve a ser correcto.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-07-round-07.exs">exercise-07-round-07.exs</a>: toma como referencia un planificador (servidor de
Fibonacci) de un ejercicio del libro y crea otro similar. Esta vez, se deben
contar las apariciones de la palabra <code>cat</code> en cada fichero que se encuentre en
un directorio dado. Cada fichero será procesado por un proceso distinto.
¿Podrías escribir el planificador de una forma más genérica?</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
</feed>
