<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: learning | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/learning/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2018-03-06T21:36:01+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir: duodécimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2018/02/18/elixir-duodecimo-asalto/"/>
    <updated>2018-02-18T22:08:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2018/02/18/elixir-duodecimo-asalto</id>
    <content type="html"><![CDATA[<p>Este será el último asalto relativo a <a href="http://elixir-lang.org/">Elixir</a> por ahora, y en él aprenderemos
qué son las <a href="https://hexdocs.pm/elixir/Task.html">Tasks</a> y los <a href="https://hexdocs.pm/elixir/Agent.html">Agents</a>, que se podrían traducir como <em>tareas</em> y
<em>agentes</em>.</p>

<p>Éstas serán las dos últimas abstracciones de Elixir que vamos a estudiar. No
son de tan bajo nivel como las primitivas <code>spawn</code>, <code>send</code> y <code>receive</code> que vimos
en el <a href="/blog/2016/09/18/elixir-septimo-asalto/">séptimo asalto</a> y tampoco son tan pesados como el <a href="http://erlang.org/doc/">framework OTP</a>.</p>

<p>Son un punto intermedio. Utilizan funcionalidades de OTP, pero nos aíslan de
muchos detalles, lo que hace que trabajar con procesos y procesos distribuidos
sea muchísimo más fácil.</p>

<p><img class="center" src="/images/2018/down-the-board.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/majY5a">Down the board</a> de <a href="https://www.flickr.com/photos/erinthomaswilson/">Erin</a>, <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">CC BY-NC-ND 2.0</a>
  </span>
</div>




<!-- more -->


<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Tareas</h4>

<p>Una tarea o <code>Task</code> es una función que se ejecuta en segundo plano. Existen dos
funciones principales: <code>async</code> y <code>await</code> y su forma de usarla sería la
siguiente:</p>

<p>```</p>

<h1>...</h1>

<h1>Realizar una computación que tarde mucho tiempo</h1>

<p>worker = Task.async(fn -> Fibonacci.of(200000) end)</p>

<h1>...</h1>

<h1>Obtener el valor devuelto por la función</h1>

<p>result = Task.await(worker)</p>

<h1>...</h1>

<p>```</p>

<p><code>async</code> crea un proceso separado que ejecuta la función. Devuelve un descriptor
del proceso o <em>worker</em>. <code>await</code> espera a que el proceso termine para recuperar
el valor devuelto por la función. En lugar de pasar una función, también
podemos pasar el nombre de un módulo, función y parámetros:
<code>Task.async(Fibonacci, :of, [ 200000 ])</code>.</p>

<p>Las <code>Task</code>s están implementadas como servidores OTP, por lo que podemos
incluirlas en nuestro árbol de supervisión de aplicaciones. Existen dos formas:</p>

<ol>
<li>Pasando la función a ejecutar a <code>Task.start_link</code> en lugar de llamar a
<code>Task.async</code> desde un proceso que ya esté supervisado</li>
<li>Creando un worker desde un supervisor:</li>
</ol>


<p><code>
import Supervisor.Spec
children = [
  worker(Task, [ fn -&gt; do_something_extraordinary() end ])
]
supervise children, strategy: :one_for_one
</code></p>

<h4>Agentes</h4>

<p>Un agente o <code>Agent</code> es un proceso también en segundo plano que mantiene un
estado. El estado puede ser accedido desde un proceso, nodo o múltiples nodos.</p>

<p>El estado inicial se toma desde una función que se le pasa a la hora de
arrancar el <code>Agent</code>.</p>

<p>Se utiliza <code>Agent.get</code> para obtener el estado. Hay que pasarle una función,
cuyo parámetro será el estado actual del <code>Agent</code>. El valor devuelto por
<code>Agent.get</code> es el valor devuelto por la función.</p>

<p>Se utiliza <code>Agent.update</code> para modificar el estado. También hay que pasar una
función. El valor devuelto por la función será el nuevo estado.</p>

<p>Veamos un ejemplo:</p>

<p>```</p>

<h1>count es el descriptor del Agent</h1>

<p>iex> { :ok, count } = Agent.start(fn -> 0 end)
{:ok, #PID&lt;0.69.0>}
iex> Agent.get(count, &amp;(&amp;1))
0            </p>

<h1>incrementa el en uno el estado</h1>

<p>iex> Agent.update(count, &amp;(&amp;1+1))
:ok          
iex> Agent.update(count, &amp;(&amp;1+1))
:ok          </p>

<h1>obtiene el estado actual</h1>

<p>iex> Agent.get(count, &amp;(&amp;1))
2
```</p>

<p>Los agentes son una abstracción especialmente pensada para almacenar el estado
de nuestros procesos. Por lo tanto, se recomienda no guardar el estado en
nuestros procesos, si no que los procesos que creemos nosotros usen un <code>Agent</code>
para almacenar. De esta forma, en caso de fallo en nuestro proceso, el estado
estará todavía disponible en el <code>Agent</code>, ya que es un proceso diferente al
nuestro.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: undécimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/10/30/elixir-undecimo-asalto/"/>
    <updated>2017-10-30T21:06:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/10/30/elixir-undecimo-asalto</id>
    <content type="html"><![CDATA[<p>Nos acercamos al final y en este asalto aprenderemos qué son las <a href="https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html">Aplicaciones
OTP</a>, aunque en realidad ya hemos estado usando algunas. Aprenderemos cómo
<code>mix</code> facilita mucho la tarea y cómo esta herramienta nos permite empaquetar
nuestra aplicación para ser distribuida. Aprenderemos a definir el punto de
entrada de ejecución y cómo pasar parámetros iniciales. Las aplicaciones, junto
con los servidores y supervisores OTP hacen de este framework una herramienta
potentísima para desarrollar aplicaciones.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/fingers.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/9cXZUG">Asaltos</a> de <a href="https://www.flickr.com/photos/antoniobugarin/">Antonio Bugarin</a>, <a href="https://creativecommons.org/licenses/by/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Aplicaciones OTP</h4>

<p>Una <em>aplicación</em> en el mundo Elixir no es lo que normalmente conocemos como
tal. El término viene del mundo Erlang, y con <em>aplicación</em> se refieren más a lo
que comúnmente conocemos como componente, o servicio (¿microservicio podría
valer aquí?, probablemente). Una aplicación OTP en Elixir es como un servicio
del que puede depender de otros servicios, y que puede arrancar servidores y
supervisores.</p>

<p>Por lo general, las aplicaciones son dependencias de los programas que estamos
desarrollando. Pero otras aplicaciones residen en la parte más alta del árbol
de procesos, y éstas están diseñadas para ejecutarse directamente.</p>

<p><strong>El fichero de configuración de la aplicación</strong></p>

<p>La herramienta <code>mix</code> crea un fichero llamado <code>&lt;tu-aplicacion&gt;.app</code>. Este
fichero es la especificación de la aplicación, y contiene información que se
suele escribir en <code>mix.exs</code> e información de la compilación de nuestro código.
Cuando se lanza la aplicación, este fichero es consultado para saber cómo
cargarla y arrancarla.</p>

<p><strong>Creando una aplicación OTP</strong></p>

<p>En realidad ya hemos creado varias. Por ejemplo, el programa <em>Sequence</em>, de la
ronda anterior, lo ejecutábamos como si fuera una aplicación OTP. Cuando
creamos un nuevo proyecto con <code>mix</code>, éste añade un supervisor por defecto e
información en <code>mix.exs</code> para poder ejecutar el proyecto como una aplicación.
Más concretamente, <code>mix</code> crea la función <code>application</code>:</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] }
</code></pre>

<p>  ]
end
```</p>

<p>El código anterior indica que el módulo principal se llama <code>Sequence</code>. OTP
asume que dicho módulo implementa una función llamada <code>start</code> (porque Elixir
define un <em>behaviour</em> <code>Application</code> que deben implementar las aplicaciones OTP
para ser consideradas como tal), a la cual le va a pasar el parámetro indicado
en la tupla (en este caso un array vacío). Si la tupla hubiera sido <code>{
Sequence, 1234 }</code> el parámetro pasado a la función <code>start</code> hubiera sido <code>1234</code>.</p>

<p>Esto es lo relativo a la opción <code>mod:</code>. Pero a la hora de configurar una
aplicación existe otra opción: <code>registered:</code>. Esta opción lista los nombres que
nuestra aplicación va a registrar. Podemos usar esto si queremos que dichos
nombres sean únicos entre todas las aplicaciones cargadas en el nodo o cluster:</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] },
registered: [
  Sequence.Server,
  "Any other name"
]
</code></pre>

<p>  ]
end
```</p>

<p>Ahora podemos ejecutar el comando <code>mix compile</code> para generar el fichero <code>.app</code>.
Este fichero se almacena en la ruta nada intuitiva de
<code>_build/dev/lib/sequence/ebin</code>. Este fichero define una tupla Erlang que define
la aplicación. <code>mix</code> ha añadido automáticamente los módulos de los que consta
la aplicación y las aplicaciones de las que depende, por ejemplo <code>kernel</code>,
<code>stdlib</code> o <code>elixir</code>.</p>

<p>A la hora de pasar parámetros de inicialización a las aplicaciones existe otra
posibilidad. La opción <code>env</code>, que acepta una lista de palabras clave (<em>keyword
list</em>)</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] },
env: [ initial_number: 12334 ],
registered: [...]
</code></pre>

<p>  ]
end
```</p>

<p>Para después recuperar ese valor con <code>Application.get_env</code>:</p>

<p>```
defmodule Sequence do
  use Application
  def start(<em>type, </em>args) do</p>

<pre><code>initial_number = Application.get_env(:sequence, :initial_number)
#...
</code></pre>

<p>```</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-11/stack">Ejercicio 1</a>: convierte tu servidor <code>Stack</code> en una aplicación OTP</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/sequence">Ejercicio 2</a>: hasta ahora no hemos testeado para nada ninguna aplicación.
Mira a ver qué puedes hacer. Testear un server no parece algo muy sencillo,
no parece que se pueda ejecutar a la primera, porque el server debería estar
ejecutándose para poder <em>funcionar</em>. Pero Elixir está muy enfocado a los tests
automáticos, así que algo debe de existir.</p></li>
</ul>


<p><strong>Resultados</strong></p>

<p>Y tanto que existe. Encontré el artículo <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html#testing-a-genserver">cómo se testea un <code>GenServer</code></a>, en la
documentación oficial: básicamente, en el <em>set up</em> de los tests, se levanta el
server. Luego, se puede llamar a la API del servidor tranquilamente. Al
parecer, si el proyecto está configurado como una aplicación, <code>mix</code> arranca la
aplicación, por lo que no hace falta levantar el server en el <em>set up</em>. Lo
malo, que no se puede inicializar con ningún valor de test.</p>

<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: décimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/06/07/elixir-decimo-asalto/"/>
    <updated>2017-06-07T21:29:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/06/07/elixir-decimo-asalto</id>
    <content type="html"><![CDATA[<p>En este asalto aprenderemos qué son los <a href="https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html">Supervisores OTP</a> y cómo se puede
crear una estructura jerárquica de ellos de forma que monitoricen nuestros
procesos y sean capaz de arrancar nuevos procesos en caso de que alguno de
ellos falle. También veremos cómo unos procesos sirven de ayuda para guardar el
estado de aquellos procesos que necesitan ser tolerantes a fallos.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/darth-grader.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/pxJ3o5">Darth Grader</a> de <a href="https://www.flickr.com/photos/jdhancock/">JD Hancock</a>, <a href="https://creativecommons.org/licenses/by/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Supervisores OTP</h4>

<p>La forma de hacer las cosas en Elixir es no preocuparse mucho por el código que
falla, si no asegurarse de que la aplicación en general sigue corriendo. Suena
contradictorio, pero no lo es. En Elixir los procesos son muy pequeñitos, por
lo que si uno de ellos falla, casi todo el sistema sigue funcionando. Al
contrario que en otros lenguajes, donde el lanzamiento de una excepción puede
hacer que todo el servidor sufra. <strong>En el mundo OTP, los supervisores son
quienes monitorizan y recuperan esos procesos fallidos</strong>.</p>

<p>Un supervisor en Elixir tiene un único propósito: manejar uno o más <em>workers</em>
(otro tipo de procesos). La forma de funcionar es darle una lista de procesos e
indicarle qué hacer con cada uno de ellos en caso de que falle. La forma más
fácil de crear un supervisor es crear un nuevo proyecto con <code>mix</code> y usar el
flag <code>--sup</code>.</p>

<p>```
defmodule Sequence do
  use Application
  def start(<em>type, </em>args) do</p>

<pre><code>import Supervisor.Spec, warn: false
children = [
  worker(Sequence.Worker, [arg1, arg2, arg3])
]
opts = [strategy: :one_for_one, name: Sequence.Supervisor]

# create the supervisor with a list of workers and some options
Supervisor.start_link(children, opts)
</code></pre>

<p>  end
end
```</p>

<h4>Gestionando el estado del servidor entre reinicios</h4>

<p>Como se puede comprobar al jugar con el supervisor y el servidor creados en el
[Ejercio 01], el servidor es reiniciado, pero no mantiene el estado anterior al
fallo, si no que siempre se reinicia con el estado inicial, indicado a la hora
de crear el supervisor. Esto se puede mejorar.</p>

<p>La forma de mantener el estado es almacenándolo fuera del proceso servidor.
Esto se hace mediante un nuevo <em>worker</em>, un nuevo servidor, al que se le llama
<em>stash</em>. Nuestro servidor almacenará su estado actual en ese <em>stash worker</em>. El
<em>stash worker</em> debe ser monitorizado por un supervisor diferente, por lo que
tenemos que crear un arbol de supervisores. En este árbol, nuestro <em>worker</em>
principal debe conocer el PID del <em>stash</em>, con lo que la forma de crear el
árbol cambia ligeramente de la forma que hemos visto anteriormente.</p>

<p><img class="center" src="/images/2017/supervisor-tree.png"></p>

<p>La aplicación funcionaría de la siguiente forma:</p>

<ol>
<li>Primero, arrancamos el supervisor raíz del árbol, pasándole el valor inicial
que será el estado inicial del sistema</li>
<li>Este supervisor arranca el <em>stash worker</em>, pasando el valor inicial (porque
este worker almacenará el estado del sistema) y arranca un sub-supervisor,
pasándole el PID del stash</li>
<li>El sub-supervisor arranca el worker principal, el que contiene la lógica,
quien incrementa el valor inicial con el que arrancamos el sistema</li>
<li>El worker principal, nada más arrancar, consulta al stash worker el estado
actual, y es con ese estado con el que va a trabajar</li>
<li>Si el worker principal falla por cualquier causa, debe enviar su estado al
stash worker, para que lo almacene</li>
<li>El sub-supervisor detectará que el proceso a muerto y reiniciará de nuevo el
worker principal, que leerá el estado del worker que murió del stash worker</li>
</ol>


<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/stack">Ejercicio 1</a>: añade un supervisor a la aplicación anterior que implementaba
una pila de enteros</li>
</ul>


<p><strong>Resultado</strong></p>

<p>Increíble, increíble que sea tan fácil. Lo primero, el supervisor arranca él
solito y levanta el servidor él solito también. Super cómodo. Luego, captura
los errores y levanta de nuevo el servidor sin que nosotros tengamos que hacer
nada más. Para hacer fallar a la pila, se podía hacer con un
<code>Stack.Server.push -1</code>. El supervisor captura el fallo, y rearranca el
servidor.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/sequence">Ejercicio 2</a>: vuelve a crear una aplicación similar a la anterior, pero
creando un árbol de supervisores, y un stash worker, de forma que cuando el
worker principal falle, el estado sea guardado. Comprueba que el sistema
mantiene el estado cuando el worker principal falla</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: noveno asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/01/29/elixir-noveno-asalto/"/>
    <updated>2017-01-29T17:19:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/01/29/elixir-noveno-asalto</id>
    <content type="html"><![CDATA[<p>En el <a href="/blog/2016/12/31/elixir-octavo-asalto/">asalto anterior</a> aprendimos un par de conceptos básicos sobre los nodos.
En este asalto aprenderemos sobre servidores OTP: qué son, para qué sirven, por
qué son útiles y cómo implementarlos fácilmente.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/us-air-force.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/R7mJ4M">160324-F-XK483-042</a> de <a href="https://www.flickr.com/photos/usairforce/">US Air Force</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/">CC BY NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Servidores OTP</h4>

<p>OTP (<strong>O</strong>pen <strong>T</strong>elecom <strong>P</strong>latform) se presenta como la solución a todos
tus problemas de escalabilidad y concurrencia. No es así, pero ayuda mucho.
Ayuda en temas como descubrimiento de aplicaciones, gestión y detección de
fallos, actualización de código en caliente y estructura del servidor.</p>

<p>OTP define un sistema como una jerarquía de <strong>aplicaciones</strong>. Una aplicación
consiste en uno o varios <strong>procesos</strong>. Cada uno de estos procesos implementa
un <strong>comportamiento</strong>. Existen <a href="http://rubenfa.github.io/2016-11-30-behaviours-en-elixir">comportamientos</a> para servidores, gestores de
eventos, máquinas de estado finitas, ...</p>

<p>Lo implementado en ejercicios anteriores sigue un patrón con el que se podría
implementar casi todos los servidores. Por eso, OTP proporciona un mecanismo
para liberarnos de escribir el código más tedioso. La librería ofrece unas
funciones a modo de <em>callbacks</em> que irá llamando dependiendo de la situación.</p>

<h4>Implementar un servidor OTP</h4>

<p>```
defmodule Sequence.Server do
  use GenServer</p>

<p>  def handle_call(:next_number, _from, current_number) do</p>

<pre><code>{ :reply, current_number, current_number + 1 }
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>use GenServer</code> indica a Elixir que vamos a usar este comportamiento. Así, este
módulo representa un servidor OTP.</p>

<p>Uno de los callbacks proporcionados por <code>GenServer</code> es <code>handle_call</code>. Tiene 3
parametros: acción, PID del origen de la petición y el estado actual del
servidor. Tiene que responder con una tupla con tres parámetros también: la
respuesta, el valor retornado y el estado del servidor a usar en la siguiente
llamada.</p>

<p>Para llamar a este servidor, entramos en <code>iex</code>. Arrancamos el servidor,
indicando el módulo y el estado inicial (similar a <code>spawn_link</code>).</p>

<p><code>
promtp$ iex -S mix
iex&gt; { :ok, pid } = GenServer.start_link(Sequence.Server, 100)
iex&gt; GenServer.call(pid, :next_number)
100
iex&gt; GenServer.call(pid, :next_number)
101
iex&gt; GenServer.call(pid, :next_number)
102
</code></p>

<h4>Servidores que no tienen que devolver un resultado</h4>

<p>En ocasiones no necesitamos que el servidor retorne un resultado. En estos
casos, para llamar al servidor emplearemos <code>GenServer.cast</code>, y para manejar
esas peticiones, nuestro servidor debe implementar el callback <code>handle_cast</code>.</p>

<h4>Callbacks de GenServer</h4>

<p>GenServer es un protocolo de OTP. OTP asume que este protocolo define 6
callbacks. Elixir proporciona una implementación por defecto para cada uno de
ellos en GenServer, por eso no tenemos que implementarlos nosotros. Los 6
callbacks son: <code>init(start_arguments)</code>, <code>handle_call(request, from, state)</code>,
<code>handle_cast(request, state)</code>, <code>handle_info(info, state)</code>,
<code>terminate(reason, state)</code>, <code>code_change(from_version, state, extra)</code> y
<code>format_status(reason, [ pdict, state ])</code>.</p>

<h4>Nombrado de procesos</h4>

<p>En lugar de usar el PID para referenciar a procesos de nuestro servidor,
podemos hacerlo a través de nombres. Para ello, se debe utilizar la opción
<code>name:</code> a la hora de crear el servidor:</p>

<p><code>
iex&gt; { :ok, pid } = GenServer.start_link(Sequence.Server, 100, name: :seq)
iex&gt; GenServer.call(:seq, :next_number)
100
iex&gt; GenServer.call(:seq, :next_number)
101
iex&gt; GenServer.call(:seq, :next_number)
102
iex&gt; :sys.get_status :seq
</code></p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack">Ejercicio 01</a>: crear un server que implemente una pila. Se
inicializará con unos cuantos valores en la pila. Cada petición <em>pop</em>
devolverá un elemento de la pila. Cuando la pila esté vacía, fallará.
Implementado en el proyecto <code>mix</code>: <code>code/round-09/stack</code>.</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack2">Ejercicio 02</a>: ampliar el servidor anterior, de forma que se puedan
añadir elementos a la pila con la operación <code>:push</code> a través de peticiones
<em>cast</em>. Implementado en el proyecto <code>mix</code>: <code>code/round-09/stack2</code>.</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack3">Ejercicio 03</a>: dar un nombre al servidor anterior, de forma que se le
pueda llamar sin necesidad de saber el PID. También, crear un API en la pila
de forma que los clientes no tengan que llamar a <code>GenServer</code> para usarla.
Simplemente serán unas funciones que envolverán las llamadas a <code>GenServer</code>.
Implementado en otro proyecto <code>mix</code>, en <code>code/round-09/stack3</code>.</p></li>
<li><p>Ejercicio 04: implementar el callback <code>GenServer.terminate/2</code> para
comprobar distintas formas de terminar el servidor: un callback lanza una
excepción, una llamada a <code>Kernel.exit/1</code>, se detecta que un proceso ha tenido
un error,...</p></li>
</ul>


<p><strong>Resultado</strong></p>

<p>No he obtenido nada en claro. Tendría que profundizar en la documentación de
<a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html#c:terminate/2"><code>GenServer.terminate/2</code></a>,
que parece bastante espesa por cierto. Pero no está garantizado que se llame a
<code>terminate</code>, con lo que no sé si estoy provocando correctamente los errores.</p>

<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>

<h2>Referencias</h2>

<ul>
<li>Proceso de <a href="/blog/2016/01/17/aprendiendo-elixir/">aprendizaje de Elixir</a></li>
<li>Artículo sobre <a href="http://rubenfa.github.io/2016-11-30-behaviours-en-elixir">comportamientos</a> (<em>behaviours</em>) en Elixir</li>
<li>Artículo sobre <a href="http://rubenfa.github.io/2017-01-25-protocols-en-elixir">protocolos</a> en Elixir</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: octavo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/12/31/elixir-octavo-asalto/"/>
    <updated>2016-12-31T19:13:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2016/12/31/elixir-octavo-asalto</id>
    <content type="html"><![CDATA[<p>Último post del año, que no de la serie sobre aprender <a href="http://elixir-lang.org/">Elixir</a>. Este asalto va de nodos, PIDs y un poquito (muy poco) de entrada/salida.</p>

<p>Aprenderemos qué es un nodo, cómo crear nuevos nodos y cómo comunicarlos a un nivel muy básico. Y algo muy interesante, cómo hacer que un nodo ejecute una función a nuestro antojo.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2016/risk.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/3pUVs">Risk</a> de <a href="https://www.flickr.com/photos/benstephenson/">Ben Stephenson</a>, <a href="https://creativecommons.org/licenses/by/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Nodos - La clave para los servicios distribuidos</h4>

<p>Un <strong>nodo</strong> no es más que una instancia de la máquina virtual de Erlang
ejecutándose. Es como un sistema operativo completo, y ofrece servicios como
tal a procesos locales o remotos.</p>

<h5>Nombres de nodos</h5>

<p>En <code>iex</code>, podemos saber el nombre del nodo actual con <code>Node.self</code>:</p>

<p><code>
iex&gt; Node.self
:"rchavarria@localhost"
</code></p>

<p>Podemos dar un nombre al nodo al iniciar <code>iex</code>:</p>

<p><code>
$ iex -name foobar@localhost
iex(foobar@localhost)&gt; Node.self
:"foobar@localhost"
</code></p>

<p>Si te fijas, el valor devuelto por <code>Node.self</code> tiene los dos puntos delante,
como si fuera un <code>Atom</code>. Y es que en Elixir, los nombres de los nodos son
tratados como <code>Atom</code>s, lo que hace super sencillo referenciar nodos en el
código.</p>

<p>También, podemos saber qué nodos conoce un nodo al que estemos conectados:</p>

<p>```
iex(node_two)> Node.list
[]</p>

<h1>y al conectarnos a un nodo, aparecerá como conectado</h1>

<p>iex(node_two)> Node.connect :"node_one@localhost"
true
iex(node_two)> Node.list
[ :"node_one@localhost" ]
```</p>

<p>Podemos ejecutar una función en un nodo remoto:</p>

<p><code>
iex(node_one)&gt; func = fn -&gt; IO.puts "Hello, I'm in #{inspect Node.self}"
iex(node_one)&gt; Node.spawn( :"node_two@localhost", func )
Hello, I'm in :"node_two@localhost"
</code></p>

<p><code>Node.spawn</code> es impresionante. Podemos ejecutar una función en otro nodo
fácilmente. Pero aunque se ejecute en <code>node_two</code>, hereda lo que se llama <em>group
leader</em>, con lo que es capaz de mostrar mensajes por consola en <code>node_one</code> (en
lugar del dos, que es donde se ejecuta).</p>

<p>Además de poder dar un nombre a un nodo, podemos establecer su <em>cookie</em>. La
cookie de un node no es más que un token, y se utiliza para permitir que los
nodos se conecten entre sí. Nodos con la misma cookie se pueden conectar. Si es
distinta, los nodos rechazarán la conexión. Las cookies se mandan en texto
plano, así que cuidado con las conexiones a través de internet.</p>

<h5>Nombrando tus procesos</h5>

<p>Cada proceso se identifica con un PID. Un PID está compuesto por tres números,
aunque sólo contiene dos campos: el número de nodo (<code>0</code> si el nodo es el local)
y el número de proceso en sí. Este número de proceso está compuesto por sus
bits más y menos representativos (de ahí que veamos tres números en un PID como
éste <code>#PID&lt;0.71.0&gt;</code>). El id de node es el id del nodo donde <em>vive</em> el proceso.</p>

<h4>Entrada/salida, PIDs y Nodos</h4>

<p>La entrada/salida en la máquina virtual de Erlang se hace a través de
servidores de entrada/salida. Elixir y Erlang proporcionan librerías para no
tener que lidiar con ellos, ya que son a muy bajo nivel.</p>

<p>En Elixir, se identifica un fichero por el PID del proceso del servidor de
entrada/salida que lo está manejando.</p>

<p>Por ejemplo, la función <code>IO.puts</code> utiliza el PID devuelto por
<code>:erlang.group_leader()</code> como valor por defecto para enviar una cadena al
proceso que la muestra por consola: <code>send :erlang.group_leader(), str</code> podría
ser el código equivalente.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li>Ejercicio 1: en el código del servidor de ticks (<a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-08/ticker.ex">ticker.ex</a>), el autor habla
de que el tick se envía cada 2 segundos más o menos.  Pero el timeout está
puesto a 2 segundos exactos. ¿Por qué habla de <em>más o menos</em>?</li>
</ul>


<p><strong>Respuesta</strong></p>

<p>El timeout es de justo 2 segundos, pero el timeout solo saltará si no se
registra ningún cliente en esos 2 segundos. Si un cliente se registra (digamos
en el momento 1.55 segundos) no saltará el timeout hasta los 3.55 segundos
siguientes (1.55 segundos que pasaron desde el anterior tick hasta el registro
del último cliente más 2 segundos del timeout normal).</p>

<ul>
<li><p>Ejercicio 2: modificar el servidor de ticks para que mande solo un
tick cada vez, de forma circular, a cada uno de los clientes registrados (el
primer tick al primer cliente, el segundo tick al segundo cliente
registrado,...). El programa deberá lidiar con nuevos clientes registrados.</p></li>
<li><p>Ejercicio 3: reimplementar el servidor de ticks, pero esta vez
debe ser circular, de forma que el cliente 1 mande un tick al cliente 2.
Pasados 2 segundos, el cliente 2 mandará un tick al 3. Y así hasta el último, el cual
enviará un tick al 1. Y vuelta a empezar. El problema está en cómo añadir
clientes al círculo (o <em>ring</em>) y quién tiene la responsabilidad de actualizar
ese círculo de clientes.</p></li>
</ul>


<p><strong>Respuesta</strong></p>

<p>Me costó un tiempo dar con la solución al ejercicio (<a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-08/ring_ticker.ex">ring_ticker.ex</a>). Puede
que el <em>ring</em> lo tenga que gestionar el servidor central. De otra forma, los
clientes perderán el timeout del <code>receive</code> y se volverán un poco locos.</p>

<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
</feed>
