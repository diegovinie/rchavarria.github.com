<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: learning | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/learning/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2015-11-29T22:54:32+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Se aceptan mejoras]]></title>
    <link href="http://rchavarria.github.io/blog/2015/11/22/se-aceptan-mejoras/"/>
    <updated>2015-11-22T22:27:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/11/22/se-aceptan-mejoras</id>
    <content type="html"><![CDATA[<p>Existe una cosa maravillosa en el mundo de open source, y es que personas que
ni siquiera sabes que existen, usan tu trabajo, lo mejoran con el suyo, y te lo
donan a tí para que otra gente se beneficie del trabajo de ambos.</p>

<p><img class="left" src="/images/2015/contribution.png"></p>

<p>Imagina que tienes una librería y tienes una base de usuarios. Ningún software
se adapta a todos sus usuarios, así que lo más seguro es que los usuarios de tu
librería encuentren algún detalle que no encaja a la perfección con sus
necesidades. ¿No sería incríble que tus propios usuarios mejoraran la librería y
te dieran su trabajo así como les das tú el tuyo? Pues eso es lo que pasa
precisamente con el open source.</p>

<p>Y algo parecido pasa cuando contribuyes a algún proyecto open source. Tus
contribuciones son usadas por los usuarios del proyecto. Y algunos de ellos
proponen nuevas mejoras al proyecto. Quizá algunas de estas mejoras sean sobre
el trabajo que tú has realizado. Gente que ni conoces está aportando su
experiencia para mejorar tu trabajo. Hay que ser muy tonto para no aprovechar
esta oportunidad para aprender.</p>

<!-- more -->


<p>Este artículo describe el proceso a seguir para aceptar mejoras en un proyecto
publicado en <a href="https://github.com/">Github</a>, donde [<code>git</code>] es usada como herramienta de control de
versiones. Estas mejoras son propuestas por usuarios externos al proyecto a
través de <a href="https://help.github.com/articles/using-pull-requests/">Pull Requests</a> (o también PR). Github te ayuda a la hora de
incorporar esas mejoras a tu proyecto, pero hacerlo así deja la historia de tu
control de versiones hecha unos zorros (en <a href="http://blog.differential.com/best-way-to-merge-a-github-pull-request/">Best way to merge a pull request</a>
lo cuentan más detalladamente).</p>

<p>Ésta es la secuencia de comandos mediante los cuales se incoroporarían los
cambios propuestos en un Pull Request con número <code>pr-number</code> desde una rama
creada por el autor llamada <code>user-working-branch</code>:</p>

<p>```
rchavarria@proyect$ git checkout master
rchavarria@proyect$ git fetch origin
rchavarria@proyect$ git reset --hard origin/master</p>

<p>rchavarria@proyect$ git fetch origin refs/pull/<pr-number>/head
rchavarria@proyect$ git checkout -b <user-working-branch> FETCH_HEAD
rchavarria@proyect$ git rebase master</p>

<p>rchavarria@proyect$ git checkout master
rchavarria@proyect$ git merge --no-ff <user-working-branch>
rchavarria@proyect$ git push origin master
```</p>

<h2>Limpiar el espacio de trabajo</h2>

<p><code>
rchavarria@proyect$ git checkout master
Already on 'master'
Your branch is up-to-date with 'origin/master'.
rchavarria@proyect$ git fetch origin
remote: Counting objects: 66, done.
remote: Compressing objects: 100% (43/43), done.
remote: Total 66 (delta 14), reused 6 (delta 6), pack-reused 17
Unpacking objects: 100% (66/66), done.
From https://github.com/exercism/xecmascript
   9b32d79..de450d0  master     -&gt; origin/master
 * [new branch]      new-exercise-raindrops -&gt; origin/new-exercise-raindrops
</code></p>

<p>Con estos comandos simplemente se cambia a la rama <code>master</code> y se descargan los
cambios que existan en el repositorio remoto (sin aplicar los cambios a ningún
archivo todavía). En este caso, el repositorio es uno de Github. En el código
anterior se puede ver cómo existe una nueva rama en remoto,
<code>new-exercise-raindrops</code>, que se corresponde con el Pull Request que vamos a
incorporar al repositorio.</p>

<p><code>
rchavarria@proyect$ git reset --hard origin/master
HEAD is now at de450d0 Merge pull request #78 from rchavarria/new-exercise-roman-numerals
</code></p>

<p>Este comando elimina cualquier cambio en local y lo sobreescribe exactamente
con los cambios que ha tomado del repositorio remoto. De esta forma <strong>se tiene
en local exactamente lo mismo que en remoto</strong>, y es un punto de partida seguro.</p>

<h2>Descargar las mejoras</h2>

<p>Anteriormente git ha avisado de que hay una nueva rama, un nuevo Pull Request.</p>

<p><code>
rchavarria@proyect$ git fetch origin refs/pull/80/head
From https://github.com/exercism/xecmascript
 * branch            refs/pull/80/head -&gt; FETCH_HEAD
</code></p>

<p>El anterior comando descarga los cambios contenido en el Pull Request con
número <code>&lt;pr-number&gt;</code>, que podría ser por ejemplo el <code>80</code>.</p>

<p><code>
rchavarria@proyect$ git checkout -b new-exercise-raindrops FETCH_HEAD
Switched to a new branch 'new-exercise-raindrops'
</code></p>

<p>Así, se crea una nueva rama, llamada <code>new-exercise-raindrops</code> que contiene los
cambios del Pull Request.</p>

<p>Y ahora llega un momento delicado. Se debe hacer que el commit por el que
comienza la rama recién creada sea el último commit que existía en <code>master</code>. De
esta forma se consigue que la historia del control de versiones sea la más
legible. En este punto es posible que se produzcan conflictos. Ese es otro tema
que daría para muchas explicaciones. Si se quiere profundizar, se puede echar
un vistazo a la propia [documentación de <code>git</code> sobre el comando <code>rebase</code>].</p>

<p><code>
rchavarria@proyect$ git rebase master
Current branch new-exercise-raindrops is up to date.
</code></p>

<p>Si no hay conflictos, perfecto, ya está.</p>

<h2>Comprobar las mejoras</h2>

<p>Ahora es el momento de hacer comprobaciones:</p>

<ul>
<li>Se deberían ejecutar los tests del proyecto</li>
<li>Chequear los cambios, comparándolos con versiones anteriores</li>
<li>Comprobar que se siguen las reglas de estilo en el código</li>
<li>En general, asegurarse de que el código a incorporar es un código con el que
estamos contentos</li>
</ul>


<p>En esta fase se pueden hacer nuevos cambios o pedir al programador que
contribuye que realice algunos cambios por sí mismo y que actualize el Pull
Request.</p>

<p><img class="center" src="/images/2015/github-diff.png"></p>

<h2>Incorporar los cambios</h2>

<p>Una vez está todo comprobado y se está de acuerdo con los cambios, ha llegado
la hora de incorporar los cambios a la rama <code>master</code> para que finalmente formen
parte del código del proyecto.</p>

<p><code>
rchavarria@proyect$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.
rchavarria@proyect$ git merge --no-ff new-exercise-raindrops
Merge made by the 'recursive' strategy.
 config.json                 |  3 ++-
 raindrops/example.js        | 17 +++++++++++++++++
 raindrops/gulpfile.js       | 42 ++++++++++++++++++++++++++++++++++++++++++
 raindrops/package.json      | 24 ++++++++++++++++++++++++
 raindrops/raindrops.spec.js | 38 ++++++++++++++++++++++++++++++++++++++
 5 files changed, 123 insertions(+), 1 deletion(-)
 create mode 100644 raindrops/example.js
 create mode 100644 raindrops/gulpfile.js
 create mode 100644 raindrops/package.json
 create mode 100644 raindrops/raindrops.spec.js
</code></p>

<p>Los comandos cambian el espacio de trabajo a la rama <code>master</code> e incorporan los
cambios a la misma. Se deberá proporcionar un mensaje para el commit que va a
generar <code>git merge</code>. Un ejemplo sería:</p>

<p>```
Merge pull request #80 from matthewmorgan/new-exercise-raindrops</p>

<p>Closes #80
```</p>

<p>Donde <code>80</code> es el número del Pull Request, <code>matthewmorgan</code> es el nombre del
programador que contribuye y <code>new-exercise-raindrops</code> es el nombre de la rama
que le dió el programador y el que se ha utilizado para la incorporación de los
cambios.</p>

<p>Finalmente, se suben los cambios al repositorio remoto y ...</p>

<p><code>
rchavarria@proyect$ git push origin master
Username for 'https://github.com': rchavarria
Password for 'https://rchavarria@github.com':
Counting objects: 1, done.
Writing objects: 100% (1/1), 273 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To https://github.com/exercism/xecmascript.git
   de450d0..eae366a  master -&gt; master
</code></p>

<p>... ¡magia!</p>

<p><img class="center" src="/images/2015/pull-request-merged.png"></p>

<h2>Referencias</h2>

<ul>
<li><a href="http://blog.differential.com/best-way-to-merge-a-github-pull-request/">Best way to merge a pull request</a></li>
<li><a href="https://www.youtube.com/watch?v=1ffBJ4sVUb4">Git for 4 and up</a></li>
<li><a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">Better commit messages</a></li>
<li><a href="https://www.youtube.com/watch?v=8YjSty6bfog">Do your commits suck?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aprendiendo Ionic 2]]></title>
    <link href="http://rchavarria.github.io/blog/2015/11/15/aprendiendo-ionic-2/"/>
    <updated>2015-11-15T22:49:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/11/15/aprendiendo-ionic-2</id>
    <content type="html"><![CDATA[<p>Recientemente se ha celebrado la conferencia <a href="http://angularconnect.com/">Angular Connect</a> en Londres,
donde se ha hablado mucho de <a href="https://angular.io/">Angular 2</a>, framework de desarrollo de
aplicaciones web en el que estoy muy interesado (de hecho estoy desarrollando
una pequeña aplicación para diversión de mi hijo, <a href="https://play.google.com/store/apps/details?id=es.rchavarria.englishbyeinar">English by Einar</a>). También
estoy enteresado en el framework <a href="http://ionicframework.com/">Ionic</a>, que aúna los proyectos de Angular y
<a href="http://cordova.apache.org/">Cordova</a> y que permite desarrollar aplicaciones para móviles con herramientas
de desarrollo web: HTML5, CSS3 y JavaScript.</p>

<p>En dicha conferencia se hizo público la versión alpha de <a href="http://ionicframework.com/docs/v2/">Ionic 2</a>, la versión
de Ionic que incluye la nueva versión de Angular. Ionic es un framework para
desarrollo de aplicaciones cliente móviles híbridas con tecnologías web y en su
versión 2 siguen con la filosofía de estar muy preocupados por el rendimiento.
En este post veremos lo realmente fácil que es comenzar a desarrollar con estas
herrmientas.</p>

<p><img class="center" src="/images/2015/ionic-framework.jpg" width="350" height="185" title="Ionic Framework" ></p>

<!-- more -->


<h2>Requisitos</h2>

<p>Ionic se apoya en Cordova y en las plataformas de desarrollo nativas
dependiendo de la plataforma móvil en la que estemos enfocados, normalmente
Android o iOS. Antes de comenzar a desarrollar con él deberemos actualizar a
las versiones más modernas posibles, ya que la versión alpha de Ionic 2
requiere de los últimos avances.</p>

<p>En mi caso particular, he necesitado actualizar mi SDK de Android para Linux:</p>

<p><code>
rchavarria@home$ ./AndroidSDK/tools/android sdk
</code></p>

<p>para abrir la interfaz gráfica y poder actualizar algunos paquetes del SDK.</p>

<p>Y también he necesitado actualizar las versiones de NodeJS (a través de <code>nvm</code>,
Node Version Manager), la herramienta <code>npm</code> y Cordova:</p>

<p><code>
rchavarria@home$ nvm install v5.0.0
rchavarria@home$ npm install -g npm
rchavarria@home$ npm install -g cordova@5.3.3
</code></p>

<p>Por último, instalar la versión alpha de Ionic 2. No temas, no hay peligro de
romper proyectos desarrollados con la versión 1 de Ionic.</p>

<p><code>
rchavarria@home$ npm install -g ionic@alpha
</code></p>

<h2>Creación del primer proyecto</h2>

<p>Para mi primer proyecto he usado una plantilla desarrollada por la gente de
Ionic, <a href="https://github.com/driftyco/ionic2-starter-tutorial">tutorial</a>. Estas plantillas permiten tener una aplicación muy básica
funcionando en unos minutos. Esta plantilla contiene un menú deslizante
lateral, pero hay otras muchas plantillas. Crear el proyecto es un simple
comando:</p>

<p><code>
rchavarria@home$ ionic start MyFirstIonic2Project tutorial --v2
</code></p>

<p>Este comando descarga la plantilla indicada, <code>tutorial</code>, instala dependencias
de NodeJS y nos deja el proyecto listo para ser ejecutado. De hecho, para poder
probarlo en un navegador, basta con escribir los comandos:</p>

<p><code>
rchavarria@home$ cd MyFirstIonic2Project
rchavarria@home$ ionic serve
</code></p>

<h2>Estructura del proyecto</h2>

<p>Prácticamente todos los ficheros de la aplicación están localizados en el
directorio <code>www</code>, como en todo proyecto de Cordova.</p>

<p>El punto de entrada principal es <code>www/index.html</code>. Como página principal, carga
los ficheros CSS, incluye los JavaScript y arranca la aplicación. Ionic busca
una etiqueta <code>ion-app</code> dentro de esta primera página HTML.</p>

<p>Todo el código JavaScript que se encuentra en el directorio <code>www/app</code> se
transpila a la versión correcta de JavaScript que soporte el navegador para el
que está dirigida la aplicación. En este directorio podremos encontrar código
tanto TypeScript como ECMAScript 2015.</p>

<p>En el archivo <code>www/app/app.js</code> podemos encontrar la entrada a nuestra
aplicación. Crea un component con el decorador <code>@App</code>, componente necesario
para toda aplicación Ionic.</p>

<p><code>
@App({
  templateUrl: 'app/app.html'
})
class MyApp {
//...
}
</code></p>

<p>El código de <code>@App</code> configura el archivo <code>www/app/app.html</code> como plantilla para
la aplicacion. Veámoslo:</p>

<p>```
<ion-menu [content]="content"></p>

<p>  <ion-content></p>

<pre><code>&lt;ion-list&gt;
  &lt;button ion-item *ng-for="#p of pages" (click)="openPage(p)"&gt;
  &lt;/button&gt;
&lt;/ion-list&gt;
</code></pre>

<p>  </ion-content></p>

<p></ion-menu></p>

<p><ion-nav id="nav" [root]="rootPage" #content swipe-back-enabled="false"></ion-nav>
```</p>

<p>Esta plantilla define un menu bajo la etiqueta <code>ion-menu</code>, y un componente de
navegación, <code>ion-nav</code>, ambos proporcionados por Ionic. <code>ion-menu</code> toma una
propiedad para mostrar un contenido, <code>content</code>, la cual se la podemos
proporcionar a través de la variable <code>#content</code> desde nuestro <code>ion-nav</code>.</p>

<p><code>ion-nav</code> define un <em>data binding</em> a la propiedad <code>root</code> del componente, igual
que <code>ion-menu</code> define un <em>data binding</em> a la propiedad <code>content</code> (en Angular 2,
los <em>data binding</em> son unidireccionales por defecto y se declaran mediante
corchetes en atributos de las etiquetas HTML). Cuando se cargue el controlador
de la navegación, el componente referenciado por la variable <code>rootPage</code> será
mostrada como la página principal de nuestra aplicación.</p>

<p>En <code>www/app/app.js</code>, el componente raiz de la aplicación, <code>MyApp</code>, especifica
dos propiedades: <code>pages</code> y <code>rootPage</code></p>

<p>```
import {App, IonicApp, IonicPlatform} from 'ionic/ionic';
import {HelloIonicPage} from './hello-ionic/hello-ionic';
import {ListPage} from './list/list';
// ...
class MyApp {
  constructor(app: IonicApp, platform: IonicPlatform) {</p>

<pre><code>// set up our app
// ...

// set our app's pages
this.pages = [
  { title: 'Hello Ionic', component: HelloIonicPage },
  { title: 'My First List', component: ListPage }
];

// make HelloIonicPage the root page
this.rootPage = HelloIonicPage;
</code></pre>

<p>  }
  // ...
}
```</p>

<h2>Cómo se crea un página</h2>

<p>El componente <code>HelloIonicPage</code> se define en el fichero
<code>www/hello-ionic/hello-ionic.js</code>. Contiene un decorador <code>@Page</code>, proporcionado
por Ionic, y su nombre lo dice todo. Este componente crea una página Ionic, que
consta de un componente y una vista de Angular 2.</p>

<p>```
import {Page, NavController} from 'ionic/ionic';</p>

<p>@Page({
  templateUrl: 'app/hello-ionic/hello-ionic.html'
})
export class HelloIonicPage {
  constructor(nav: NavController) {</p>

<pre><code>this.nav = nav;
</code></pre>

<p>  }
}
```</p>

<p>Cada página se compone de un componente JavaScript y de una plantilla HTML.
Veamos ésta última:</p>

<p>```
<ion-navbar *navbar>
  <a menu-toggle><icon menu /></a>
  <ion-title>Hello Ionic</ion-title>
</ion-navbar></p>

<p><ion-content>
  <h3>Welcome to your first Ionic app!</h3>
  <p></p>

<pre><code>...
</code></pre>

<p>  </p>
</ion-content>
```</p>

<p>La etiqueta <code>&lt;ion-navbar *navbar&gt;</code> funciona como configuración para la barra de navegación. Es quien incluye los botones a mostrar en dicha barra, así como el título.</p>

<h2>Navegando entre páginas</h2>

<p>La otra página, <code>ListPage</code>, contiene una lista de elementos que el usuario
puede tocar (o hacer click) para acceder a ellas. Dicha página está definida en
el archivo <code>www/app/list/list.js</code>.</p>

<p>```
import {IonicApp, Page, NavController, NavParams} from 'ionic/ionic';</p>

<p>@Page({
  templateUrl: 'app/list/list.html'
})
export class ListPage {
  constructor(app: IonicApp, nav: NavController, navParams: NavParams) {</p>

<pre><code>this.nav = nav;
// ...
</code></pre>

<p>   }</p>

<p>   itemTapped(event, item) {</p>

<pre><code> // ...
</code></pre>

<p>   }
}
```</p>

<p>La plantilla de esta página, definida en <code>www/app/list/list.html</code>, es quien
mostrará una lista de elementos. <code>*ng-for</code> es la sintaxis de Angular 2 para
reproducir la misma funcionalidad que <code>ng-repeat</code> en AngularJS. El manejador
del evento click se establece con <code>(click)=itemTapped(...)</code> (en Angular 2, se
utilizan los paréntesis en atributos de las etiquetas HTML para establecer los
manejadores de eventos). De esta forma, cada vez que el usuario toque/haga
click en un elemento, el método <code>itemTapped</code> será llamado.</p>

<p><code>
&lt;ion-item *ng-for="#item of items" (click)="itemTapped($event, item)"&gt;
</code></p>

<p>Para navegar a una nueva página, se puede usar el componente <code>NavController</code>,
también proporcionado por Ionic. Anteriormente, se ha almacenado una referencia
a dicho componente en el atributo <code>nav</code> de <code>ListPage</code>.</p>

<p>```
import {ItemDetailsPage} from '../item-details/item-details';
// ...
itemTapped(event, item) {
  this.nav.push(ItemDetailsPage, {</p>

<pre><code>item: item
</code></pre>

<p>  });
}
```</p>

<p>La navegación en Ionic funciona como una <em>pila</em> (o <em>stack</em>), donde podemos poner (<code>push</code>)
o quitar (<code>pop</code>) páginas de la pila.</p>

<h2>¿Y ahora qué?</h2>

<p>Ya tenemos una estructura muy básica para el proyecto, y ya sabemos cómo crear
páginas y cómo funciona la navegación en Ionic 2. El siguiente paso se me
ocurre que podría ser incluir las herramientas y la estrutura necesaria para
poder incluir tests en nuestro proyecto. Lo siento si te parece una lata, pero
creo que los tests son una herramienta imprescindible en cualquier proyecto,
sea de la embergadura que sea. Considero que los tests son básicos para tener
un mínimo de calidad en cualquier proyecto software.</p>

<h2>Referencias</h2>

<ul>
<li>Documentación sobre <a href="http://ionicframework.com/docs/v2/components">componentes de Ionic 2</a></li>
<li>Documentación sobre <a href="http://ionicframework.com/docs/v2/platform">el API de dispositivos de Ionic 2</a></li>
<li><a href="http://ionicframework.com/docs/v2/resources/">Recursos</a>, en general, de Ionic 2</li>
<li><a href="https://angular.io/docs/ts/latest/testing/">Tests en Angular 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Follow my leader]]></title>
    <link href="http://rchavarria.github.io/blog/2015/10/04/charla-tecnica-follow-my-leader/"/>
    <updated>2015-10-04T15:21:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/10/04/charla-tecnica-follow-my-leader</id>
    <content type="html"><![CDATA[<p>Estas notas podrían encajar perfectamente en el post que voy actualizando
regularmente <a href="/blog/2014/10/11/aprendiendo-vim/">Aprendiendo Vim</a>, pero creo que esta la charla de Drew Neail se
desmarca ya un poco del proceso de aprendizaje. En esta charla no se busca
enseñar nuevos comandos de Vim, si no que se trata más de un tema cultural
acerca del editor. Drew trata de animar a la gente a que busque nuevas
combinaciones de teclas que se conviertan en nuevos comandos y de esta forma
hacer Vim más potente todavía.</p>

<!-- more -->


<h2>Notas tomadas de la charla <a href="https://vimeo.com/85343734">Follow my leader</a></h2>

<iframe src="https://player.vimeo.com/video/85343734"
        width="500"
        height="281"
        frameborder="0"
        webkitallowfullscreen mozallowfullscreen allowfullscreen>
</iframe>


<p><em><a href="https://vimeo.com/85343734">Follow my leader</a>, por <a href="http://drewneil.com/">Drew Neil</a>, en un encuentro del grupo local
<a href="https://vimeo.com/vimlondon">Vim London</a></em></p>

<ul>
<li><code>let mapleader = ","</code> para mapear <code>,</code> como tecla <code>&lt;leader&gt;</code> en Vim. Otra
tecla muy común para utilizarla como <code>&lt;leader&gt;</code> es la barra espaciadora.</li>
<li><code>nnoremap &lt;leader&gt;&lt;space&gt; :noh&lt;cr&gt;</code> : remapea la secuencia de teclas
<code>&lt;leader&gt;&lt;space&gt;</code> para que se ejecute el comando <code>:nohlsearch</code>, que desactiva
el resaltado de términos de búsqueda.</li>
<li>La tecla <code>&lt;leader&gt;</code> te permite crear mapeos personalizados, es donde los
usuarios pueden crear sus mapeos sin interferir con Vim</li>
<li>En lugar de usar <code>leader</code>, algunos plugins, como los que escribe <a href="http://tpo.pe/">Tim Pope</a>
siguen otro patrón. hay teclas que son <em>operadores</em>, por ejemplo la <strong>d</strong>
para borrar, o la <strong>y</strong> para copiar. a estos operadores le puede seguir el
mismo operador o una movimiento. Teclas que producen un movimiento son <strong>j</strong>
para ir hacia abajo, <strong>$</strong> para ir al final de la línea, ... Pero, qué pasa si
despues de un operador pulsamos una tecla de <em>no movimiento</em>? No pasa nada. Y
ahí están las combinaciones de teclas dsiponibles para tus plugins.</li>
<li>En la imagen de la <a href="http://www.viemu.com/vi-vim-cheat-sheet.gif">chuleta de Vim</a>, los naranjas son operadores, los
verdes movimientos y los amarillos son comandos.</li>
</ul>


<p><img class="center" src="/images/2015/tiny-vi-vim-cheat-sheet.gif"></p>

<ul>
<li>El plugin <a href="https://github.com/tpope/vim-unimpaired">unimpaired.vim</a> añade mapeos como <code>con</code> para habilitar/deshabilitar los
nuḿeros de línea, o <code>cos</code> para habilitar/deshabilitar el chequeo ortográfico.
Son <code>c</code> + <code>o</code> + otras teclas</li>
<li>También hay disponibles combinaciones como operador + operador : <code>d</code> + <code>c</code></li>
<li>Los <em>text objects</em> (<code>i</code> y <code>a</code>) también tienen vacantes.</li>
<li>Los <em>namespaced mappings</em> también tienen vacantes. Por ejemplo, <code>g</code> es como
un prefijo para muchos mapeos. <code>z</code> es otro, y <code>[</code> y <code>]</code> son más.</li>
<li><code>:help g</code> te muestra todos los mapeos que siguen a <code>g</code>. Te puede servir para
ver huecos donde poner tus mapeos</li>
<li>Comando inútiles, hay algunos comandos que no usa nadie. Sobreescríbelos. Por
ejemplo, <code>g</code> + <code>s</code>.</li>
<li>Sobreescribir, sobrecargar comandos que ya existen, vamos, ampliar los
existentes.</li>
</ul>


<h2>Conclusiones</h2>

<p>Como puedes ver, el editor Vim es todo un mundo de posibilidades. Hay veces que
abruma, pero hay tanta gente apasionada por él que está claro que algo debe de
tener. Esta charla es una muestra de las posibilidades de personalización que
esta herramienta ofrece. Drew nos abre las puertas a un mundo nuevo de posibles
comandos.</p>

<p>Si te gusta Vim, y no conoces el plugin <a href="https://github.com/tpope/vim-unimpaired">unimpaired.vim</a>, échale un vistazo. Sin
duda es uno de los imprescindibles, como tantos otros de Tim Pope.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aprendiendo Vim]]></title>
    <link href="http://rchavarria.github.io/blog/2014/10/11/aprendiendo-vim/"/>
    <updated>2014-10-11T01:31:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2014/10/11/aprendiendo-vim</id>
    <content type="html"><![CDATA[<p>Hubo un momento en mi carrera profesional en la que un compañero me dió a conocer
<em>Vim</em>, el editor de código. Me pareció una herramienta arcaica, básica. Línea
de comandos, nada de modo gráfico. ¿Pero dónde estaba? ¿En los años 80?. Pero la
pasión con la que hablaba del editor mi picaba la curiosidad.</p>

<p>Luego, en años venideros, he visto y usado muchos editores de texto, de código
e incluso IDEs. Nunca me había atrevido a usar Vim, pero de vez en cuando
escuchaba (de la forma que se escucha en internet: twitter, blogs, ...) algunas
campanadas de que Vim era un súper editor.</p>

<p>Pero nunca me decidía a darle una oportunidad, hasta...</p>

<!-- more -->


<p>Hasta que cayó un post de <a href="http://elkarmadelteclado.com">Pablo Bernardo</a> en mi lector RSS:
<a href="http://elkarmadelteclado.com/asi-que-quieres-aprender-usar-vim/">Asi que quieres aprender a usar Vim</a>.</p>

<p>En este post, Pablo detalla toda una serie de recursos disponibles en <em>la nube</em>
y no sé porqué, pero me tocó la fibra sensible. Y decidí empezar por uno de los
videos.</p>

<p>El video en cuestión, es un hangout de LinuxIO, de <a href="http://www.desarrolloweb.com">Desarrollo Web</a>, y que se
titula "<a href="http://youtu.be/cpL32a_GP3k">El mítico editor Vim</a>". Este video fue el detonante de que decidiera
darle una oportunidad a Vim, una oportunidad seria. Así que decidí comenzar a
aprenderlo.</p>

<p>La idea es que este post no se acabe aquí, si no que vaya creciendo con el
tiempo, que vaya actualizandolo según voy consumiendo los recursos que indica
Pablo, y los que me encuentre por el camino. Para cada uno de ellos me gustaría
ir describiendo qué es lo que he aprendido de él.</p>

<p>De esta forma, según vaya pasando el tiempo, aquí tendré el camino recorrido,
y así otros podrán saber cómo lo recorrí para aprender Vim.</p>

<!--
LinuxIO, con @ktzar, que anima bastante https://www.youtube.com/watch?feature=player_embedded&v=cpL32a_GP3k

Segunda parte del LinuxIO: https://www.youtube.com/watch?feature=player_embedded&v=XvCD78eA46E

Un semi-dios del vim, Drew Neil : https://vimeo.com/53144573

Pagina de Drew Neil : http://drewneil.com/
Con enlaces a vimcasts, peer-to-peer.io, ...

Libros en open libra (no leidos) http://www.etnassoft.com/biblioteca/?search_term=VIM&books_category=libros_programacion&books_criteria=post_date_DESC&lang=all&since=all

Videos de Derek Wyatt : http://derekwyatt.org/vim/tutorials/

-->


<h2>El mítico editor Vim, #linuxIO</h2>

<p><a href="https://twitter.com/ktzar">Miguel Luis González</a> y <a href="https://twitter.com/voylinux">Pablo</a> nos presentan <a href="http://youtu.be/cpL32a_GP3k">El mítico editor Vim</a>. Miguel pone tanta pasión,
tanto conocimiento, que impresiona. Este es el video que me convenció. Y
éste es un resumen de lo que aprendí de él (y estoy poniendo en práctica escribiendo
este post :D ).</p>

<ul>
<li>Movimientos básicos: <code>h</code>, <code>j</code>, <code>k</code>, <code>l</code>. Nada de usar las flechas, ¡Cobarde!</li>
<li><code>i</code> para <strong>i</strong>nsertar</li>
<li><code>a</code> para <strong>a</strong>ñadir. Inserta, pero después de la posición del cursor</li>
<li><code>:o &lt;fichero&gt;</code> para abrir (<strong>o</strong>pen) un fichero</li>
<li><code>:q</code> para salir del Vim. <code>:q!</code> para salir ignorando los cambios</li>
<li><code>:w</code> para guardar (<strong>w</strong>rite)</li>
<li><code>u</code> para deshacer (<strong>u</strong>ndo)</li>
<li><code>CTRL + r</code> para rehacer</li>
<li><code>w</code> para mover el cursor a la siguiente palabra (<strong>w</strong>ord)</li>
<li><code>b</code> para mover el cursor a la palabra anterior (<strong>b</strong>efore)</li>
<li><code>e</code> para mover el cursor al final (<strong>e</strong>nd) de la siguiente palabra</li>
<li><code>x</code> para borrar un carácter</li>
<li><code>p</code> para <strong>p</strong>egar. <code>P</code> para hacerlo antes del cursor</li>
<li><code>r</code> para reemplazar un carácter</li>
<li><code>f&lt;carácter&gt;</code> para encontrar (<strong>f</strong>ind) el siguiente carácter en la línea</li>
<li><code>0</code> mover el cursor al inicio de la línea. <code>$</code> para ir al final</li>
<li><code>d</code> borrar (<strong>d</strong>elete). <code>dw</code> borra palabra. <code>dd</code> borra línea</li>
<li><code>c</code> para <strong>c</strong>ambiar. Por ejemplo, <code>cw</code> cambia una palabra. <code>cc</code> cambia una linea</li>
<li><code>y</code> para copiar (<strong>y</strong>ank). <code>yw</code> copia una palabra. <code>yy</code> una línea. <code>yf)</code> copia
hasta que encuentra el caracter <code>)</code> inclusive.</li>
<li><code>t&lt;carácter&gt;</code> para mover hasta (un<strong>t</strong>ill). <code>yt)</code> para copiar hasta el carácter
<code>)</code> sin copiar el carácter.</li>
<li><code>%</code> para mover el cursor al carácter complementario. Por ejemplo, si estamos en
un carácter <code>(</code>, nos mueve hasta el siguiente <code>)</code>. De <code>[</code> al <code>]</code>. ¿Lo pillas?</li>
</ul>


<h2>(12-10-2014) Vim sobre Linux, comandos avanzados y plugins</h2>

<p>Miguel y Pablo siguen hablando de Vim, de <a href="http://youtu.be/XvCD78eA46E">comandos avanzados y plugins</a>, temas más
avanzados que en el anterior vídeo, pero con el mismo tono alegre y pasión.
Esto es lo que aprendí en él:</p>

<ul>
<li><code>s</code> para sustituir un carácter. Borra el carácter donde está el cursor y entra
en modo edición.</li>
<li><code>C</code> para cambiar una línea entera.</li>
<li>Números como modificadores de comandos. Por ejemplo, <code>5dd</code> borra 5 líneas. <code>3yy</code>
copia 3 líneas.</li>
<li><code>/&lt;texto&gt;</code> para buscar la cadena de texto hacia adelante</li>
<li><code>n</code> para moverse a la siguiente (<strong>n</strong>ext) ocurrencia de la búsqueda. <code>N</code> para
moverse a la anterior.</li>
<li><code>?&lt;texto&gt;</code> para buscar la cadena de texto pero hacia atrás</li>
<li><code>*</code> entra en modo búsqueda, usando la palabra donde estamos como texto de búsqueda</li>
<li><em>Movimientos interiores</em>. <code>i</code> expande el cursor o la selección en el <strong>i</strong>nterior
de un texto encerrado entre dos comillas, o dos paréntesis, o dos llaves.
Por ejemplo, <code>ci'</code> <strong>c</strong>ambia el <strong>i</strong>nterior del texto entre comillas. <code>di(</code>
borra (<strong>d</strong>elete) el <strong>i</strong>nterior del texto entre paréntesis. <code>cit</code> <strong>c</strong>ambia
el <strong>i</strong>nterior del <strong>t</strong>ag HTML.</li>
<li><code>v</code> entra en modo <strong>v</strong>isual. <code>V</code> modo <strong>v</strong>isual línea a línea</li>
<li><code>CTRL + v</code> entra en modo <strong>v</strong>isual pero selecciona columnas</li>
<li><code>CTRL + p</code> autocompletado, buscando en palabras anteriores a la actual y en todos
los ficheros abiertos. <code>CTRL + n</code> muestra también una lista de posibles palabras
para autocompletar, pero dando preferencia a texto encontrado hacia abajo</li>
<li><code>%s/&lt;texto a buscar&gt;/&lt;texto a reemplazar&gt;/g</code> busca y reemplaza un texto por otro,
se puede hacer en todo el fichero o dentro de una zona seleccionada con <code>v</code></li>
<li><code>=</code> indenta un texto. <code>==</code> indenta una línea entera</li>
<li><code>&lt;</code> y <code>&gt;</code> aumentan o disminuyen la indentación de la línea</li>
<li><code>gg</code> mueve el cursor al inicio del fichero. <code>G</code> lo mueve al final del fichero</li>
<li><code>:!&lt;comando unix&gt;</code> ejecuta un comando unix. <code>%</code> se reemplaza por la ruta del
fichero actual. También puede actuar sobre regiones de selección visuales.
<code>:'&lt;, '&gt;!sort</code> ordena la selección visual</li>
<li><code>q&lt;tecla&gt;</code> comienza la grabación de una macro, almacenándola en <code>&lt;tecla&gt;</code>. Volver
a pulsar <code>q</code> para parar la grabación.</li>
<li><code>@&lt;tecla&gt;</code> ejecuta la macro almacenada en <code>&lt;tecla&gt;</code></li>
<li><code>@@</code> ejecuta la última macro</li>
<li><code>:split</code>, <code>:vsplit</code> para abrir varios ficheros y verlos simultáneamente</li>
<li><code>:buffer &lt;número&gt;</code> para abrir un buffer o nuevo fichero. Por ahora los buffers
es un tema algo complicado. Más adelante aprenderé más sobre ellos.</li>
</ul>


<p>Plugin <a href="http://vim.sourceforge.net/scripts/script.php?script_id=1658">NERDTree</a>.
Con <code>CTRL + w</code> se entra en un modo para poder moverse por las
ventanas (<strong>w</strong>indows). Se pueden utilizar las teclas de movimiento <code>h</code>, <code>j</code>, <code>k</code>, <code>l</code>
para moverse por los ficheros que muestra el plugin en forma de árbol.</p>

<p>Se puede utiliar Vim como una herramienta para comparar ficheros. El comando unix
<code>vimdiff</code> abre Vim con dos ficheros para compararlos.</p>

<p>Toda la configuración de Vim se guarda en el directorio <code>~/.vim</code>. Los plugins se
guardan en <code>~/.vim/plugin</code> y los ficheros de ayuda en <code>~/.vim/doc</code>. Configuraciones
de teclas, colores, indentación y otras se guardan en el fichero <code>~/.vimrc</code>.</p>

<p>Plugin <a href="https://wincent.com/products/command-t">Command-T</a>. Para abrir ficheros con
las teclas <code>CTRL + t</code>. Parecido a la misma funcionalidad de TextMate o Sublime. Al
parecer necesita Ruby, así que la instalación quizá no sea muy sencilla.</p>

<h2>(12-10-2014) Derek Wyatt: Basic movements II</h2>

<p>El primer video de Derek decidí saltármelo, ya que todos los comandos estarían
cubiertos con los videos de #LinuxIO. En el de <a href="http://vimeo.com/6185584">Movimientos básicos II</a>
aprendí lo siguiente:</p>

<ul>
<li><code>H</code> mueve el cursor a la cabecera (<strong>h</strong>ead) del texto que se muestra en pantalla</li>
<li><code>M</code> mueve el cursor a la parte <strong>m</strong>edia del texto en pantalla</li>
<li><code>L</code> mueve el cursor a la última (<strong>l</strong>ast) línea del texto en pantalla</li>
<li><code>&lt;número&gt;G</code> nos lleva a la línea número <code>&lt;número&gt;</code></li>
<li><code>#</code> busca la palabra sobre la que buscamos, pero hacia atrás. Es como el comando
que ya vi anteriormente <code>*</code></li>
<li><code>g*</code> busca el texto, como <code>*</code>, pero no tiene porqué ser la palabra completa</li>
</ul>


<h2>(12-10-2014) Derek Wyatt: Basic movements III</h2>

<p>En el video de <a href="http://vimeo.com/6216655">Movimientos básicos III</a> ya no podían quedar
muchos más movimientos que aprender, y la verdad es que los que aquí aparecen son ya
movimientos un poco más extraños, aunque no por eso dejan de ser útiles.</p>

<ul>
<li><code>:help motion.txt</code> para ver la ayuda sobre movimientos, para que no se olvide
ninguno</li>
<li><code>]]</code> mueve el cursor hasta el siguiente carácter <code>{</code> que exista en la columna 0.
Ideal para movernos por ficheros de código. Existen otras combinaciones, como
<code>[[</code>, <code>[]</code> y <code>][</code>, pero actuando sólo sobre la columna 0, no sé si les voy a sacar
mucho provecho.</li>
</ul>


<p>El plugin <a href="http://www.vim.org/scripts/script.php?script_id=39">matchit</a> amplía la
funcionalidad del comando <code>%</code> (que movía el cursor hasta el siguiente carácter
complementario: de <code>(</code> a <code>)</code>, de <code>[</code> a <code>]</code>, ...).</p>

<p><code>:help marks</code> para conocer acerca de marcadores. No los suelo utilizar en mi día
a día, pero no está de más saber que existen.</p>

<ul>
<li><code>m&lt;tecla&gt;</code> define un marcador en <code>&lt;tecla&gt;</code></li>
<li><code>'&lt;tecla&gt;</code> nos mueve al marcador definido en <code>&lt;tecla&gt;</code></li>
<li><code>''</code> nos lleva al último lugar donde editamos, ya que Vim almacena en <code>'</code> dicha
posición de forma automática</li>
</ul>


<h2>(13-10-2014) Derek Wyatt: basic editing I</h2>

<p>No es que aprendiera mucho en el video de <a href="http://vimeo.com/6329762">Edición básica</a> de
Derek, pero la mayoría de comandos ya estaban cubiertos con los videos de #LinuxIO.</p>

<ul>
<li><code>x</code> borra el carácter donde esta el cursor. <code>X</code> borra hacia atrás</li>
<li><code>r</code> <strong>r</strong>eemplaza un carácter. <code>R</code> <strong>r</strong>eemplaza varios carácteres, hasta que pulsemos <code>ESC</code>.
<code>5rx</code> reemplaza 5 caracteres por una <code>x</code>.</li>
</ul>


<p>El comando <code>:set cpoptions+=$</code> configura una funcionalidad adicional para el
comando <code>c</code> (<strong>c</strong>ambiar). Lo que hace es que aparezca el carácter <code>$</code> al
final del texto que se va a cambiar.</p>

<h2>(13-10-2104) Derek Wyatt: basic editing II</h2>

<p>No hay gran cosa que destacar en el video de
<a href="http://vimeo.com/6332848">Edición básica II</a>.</p>

<ul>
<li><code>F&lt;carácter&gt;</code> encontrar (<strong>f</strong>ind) un carácter hacia atrás</li>
<li><code>J</code> une (<strong>j</strong>oin) una línea con la inmediatamente inferior. <code>gj</code> une dos líneas
sin dejar ningún espacio en blanco.</li>
<li><code>gv</code> selecciona el último bloque visual</li>
</ul>


<h2>(13-10-2014) Derek Wyatt: working with many files I</h2>

<p>En el episodio de <a href="https://vimeo.com/6306508">Múltiples ficheros I</a> aprendí un
manejo básico de buffers, es decir, manejar varios ficheros a la vez.</p>

<ul>
<li><code>:e &lt;fichero&gt;</code> abre un buffer con ese <fichero></li>
<li><code>:ls</code> lista todos los buffers abiertos</li>
<li><code>:buffer &lt;número&gt;</code> cambia al buffer número <code>&lt;número&gt;</code>. <code>:b &lt;nombre&gt;</code> cambia al
buffer del fichero con el nombre <code>&lt;nombre&gt;</code>. <code>b#</code> cambia al buffer anterior.</li>
<li><code>:bdelete</code> o <code>bd</code> cierra el buffer abierto en ese momento</li>
<li><code>:%bd</code> cierra todos los buffers (<code>%</code> significa <em>todo el rango</em>)</li>
</ul>


<h2>(13-10-2014) Derek Wyatt: working with many files II</h2>

<p>El episodio de <a href="https://vimeo.com/6307101">Múltiples ficheros II</a> sigue enseñándome
a manejar varios buffers o ficheros a la vez.</p>

<ul>
<li><code>:wn</code> (<strong>w</strong>rite and move <strong>n</strong>ext), escribe el buffer actual y se mueve al
siguiente</li>
<li><code>:n</code> mueve al siguiente (<strong>n</strong>ext) buffer</li>
<li><code>:bufdo &lt;comando&gt;</code> ejecuta el comando en todos y cada uno de los buffers
abiertos</li>
<li><code>:wall</code> escribe todos (<strong>all</strong>) los buffers</li>
<li><code>:bfirst</code> se mueve al primer buffer. <code>:bn</code> se mueve al siguiente. <code>:bp</code> se
mueve al anterior (<strong>p</strong>revious)</li>
</ul>


<p>Todos estos comandos son potentes si se usa <strong>una sola sesión de Vim</strong>, y
son inútiles si tienes abiertos N Vims con N ficheros. Así que recuerda:
una sola sesión de Vim.</p>

<h2>(13-10-2014) Derek Wyatt: working with many files III</h2>

<p>En el <a href="https://vimeo.com/6342264">último episodio sobre múltiples ficheros</a>
hay más y más comandos que aprender, a cual más útil.</p>

<ul>
<li><code>CTRL-w o</code> te deja con sólo una ventana abierta</li>
<li><code>:split &lt;fichero&gt;</code>, <code>:sp &lt;fichero&gt;</code> divide la pantalla y abre una ventana debajo
de otra con el nuevo fichero</li>
<li><code>CTRL-w x</code> intercambia (e<strong>x</strong>change) dos ventanas</li>
<li><code>CTRL-w v</code> divide la pantalla en vertical, mostrando dos ventanas con el mismo
buffer. También se puede hacer con <code>:vsplit</code> o <code>:vsp</code></li>
<li><code>CTRL-w</code> seguido de <code>h</code>, <code>j</code>, <code>k</code> o <code>l</code> te permite moverte de ventana en ventana
igual que si lo estuvieras haciendo dentro de un fichero</li>
<li><code>CTRL-w</code> seguido de <code>H</code>, <code>J</code>, <code>K</code> o <code>L</code> mueve la ventana a la derecha, abajo,
arriba o a la derecha</li>
<li><code>CTRL-w p</code> mueve el cursor a la última ventana visitada</li>
<li><code>CTRL-w c</code> <strong>c</strong>ierra la ventana</li>
<li><p><code>CRTL-w</code> mueve el cursor a la siguiente ventana, de una en una, una especie de
<code>CTRL-TAB</code> o así</p></li>
<li><p><code>CTRL-w c</code> <strong>c</strong>ierra la ventana</p></li>
<li><code>CRTL-w</code> mueve el cursor a la siguiente ventana, de una en una, una especie de
<code>CTRL-TAB</code> o así</li>
</ul>


<h2>(14-10-2014) Derek Wyatt: how to use the help system</h2>

<p>Para aprender acerca de <a href="http://vimeo.com/7035132">cómo usar la ayuda</a> este
video es lo mejor, aquí va un resumen:</p>

<ul>
<li><code>:help</code> o <code>:h</code> abre una ventana como si fuera un buffer donde muestra la ayuda</li>
<li><code>CTRL+]</code> para seguir un hiperenlace de la ayuda (no se si funcionara con
teclado español). <code>CTRL+t</code> para volver hacia atrás</li>
<li><code>:help &lt;tag&gt;</code> abre la ayuda de una etiqueta. Las etiquetas tienen la forma
de <code>*:&lt;command&gt;*</code> en la ayuda.</li>
<li><code>:help &lt;function&gt;()</code> abre la ayuda de una función</li>
<li>the command <code>wildmenu</code> (o <code>wmnu</code>) habilita el autocompletado de comandos en
con <code>TAB</code>. Para activarla, escribir <code>:set wildmenu</code>. Para desactivarla
<code>:set nowildmenu</code></li>
<li><code>:helpgrep</code> (<code>:helpg</code>) busca un patrón en los ficheros de ayuda. Con el
filtro <code>[@xx]</code> busca sólo para el lenguaje <code>xx</code>. Para movernos por los resultados
se puede hacer con <code>:cn</code> (siguiente o <strong>n</strong>ext) o con <code>:cwin</code> nos abre una
ventana llamada <em>quickfix</em> (<code>:h quickfix</code> para saber más)</li>
</ul>


<h2>(23-10-2014) Derek Wyatt: Vim runtime y el fichero .vimrc</h2>

<p>Sigo aprendiendo Vim con este tío, esta vez sobre el
<a href="http://derekwyatt.org/vim/tutorials/intermediate/#vimrc">fichero de configuración .vimrc y el runtime</a>:</p>

<ul>
<li>El fichero <code>vimrc</code> se usa para configurar Vim cuando arranca</li>
<li>En Linux, el fichero <code>vimrc</code> se encuentra en <code>~/.vimrc</code></li>
<li>Puedes escribir los mismos comandos que en el modo comando, cuando empieza por <code>:</code></li>
<li>Echar un vistazo a MiniBufExplorer plugin</li>
<li><code>:h vimrc</code> para leer la ayuda</li>
<li><code>nnoremap</code> es un comando interesante para remapear ciertos comandos</li>
<li><code>:h 'runtimepath'</code> muestra la ayuda sobre vim runtime path</li>
<li><code>~/.vim/</code> es el runtime path por defecto en Linux. Ahí es donde irán instalados
los ficheros de ayuda, los plugins, los colores de syntaxis, ...</li>
<li><code>~/.vim/doc</code> es donde se guarda la ayuda</li>
<li><code>~/.vim/colors</code> es donde se guardan los esquemas de colores</li>
<li><code>~/.vim/plugin</code> es donde <em>viven</em> los plugins</li>
</ul>


<h2>(24-10-2014) Derek Wyatt: Vim modes introduction</h2>

<p>Los modos es la característica que diferencia a Vim (sobre todo de emacs, su eterno
enemigo), y ya iba siendo hora de apreder sobre ellos. Los modos de Vim son:
normal, visual, inserción, comando y ¿¡ejecución!?, así que aquí va una
<a href="http://derekwyatt.org/vim/tutorials/intermediate/#modes-intro">introducción a los modos de Vim</a>:</p>

<ul>
<li>modo <em>Normal</em>: donde puedes introducir los comandos del editor</li>
<li>modo <em>Visual</em>: como el modo normal, pero según te mueves por el fichero, el texto
se va resaltando, como si fuera una selección visual</li>
<li>modo <em>Inserción</em>: es el modo donde se introduce el texto</li>
<li>modo <em>Línea de comandos</em>: donde puedes introducir comandos en una línea abajo
del todo de la ventana de Vim. Los comandos comienzan con <code>:</code>, <code>/</code>, <code>?</code> o <code>!</code></li>
<li>Y hay otros modos menos usados, que más que modos distintos son como una
mezcla de varios de los básicos, como el modo <em>Inserción Normal</em>, que, estando
en el modo de inserción, te permite ejecutar un comando (uno sólo) y luego
vuelve a entrar en el modo de inserción.</li>
</ul>


<h2>(28-10-2014) Derek Wyatt: Insert mode</h2>

<p>En este video Derek profundiza en uno de los modos importantes de Vim, el
<a href="https://vimeo.com/7133419">modo de inserción</a>, en el cual podemos usar
autocompletado, indentar líneas y muchas cosas más.</p>

<ul>
<li><code>:help i_CTRL-A</code> muestra la ayuda para la combinación de teclas <code>CTRL a</code> pero
exclusivamente para el modo de inserción, de ahí el <code>i_</code></li>
<li><code>expandtab</code> es una opción que indica el número de espacios a insertar cuando
se presiona la tecla <code>TAB</code></li>
<li><code>CTRL w</code> borra la palabra anterior (si estamos en modo de inserción)</li>
<li><code>CTRL t</code> incrementa en uno la indentación</li>
<li><code>CTRL d</code> decrementa en uno la indentación</li>
<li><code>:help ins-special-special</code> muestra la ayuda de comandos en el modo inserción,
como por ejemplo <code>CTRL g j</code> para mover el cursor una línea abajo.</li>
<li><code>CTRL m</code>, <code>CTRL p</code> busca palabras para autocompletar buscando hacia abajo o
hacia arriba</li>
<li><code>CTRL x</code> + <code>CTRL l</code> autocompleta líneas enteras, es decir, en lugar de buscar
palabrejas, busca líneas completas.</li>
<li><code>CTRL x</code> + <code>CTRL f</code> autocompleta rutas de ficheros</li>
</ul>


<h2>(02-11-2014) Derek Wyatt: One Vim... just one</h2>

<p>Es cortito video acerca de <a href="http://vimeo.com/4446112">mantener una y solo una sesión de Vim</a>
se enfoca en solamente un comando de la shell:</p>

<pre><code>gvim --remote-silent
</code></pre>

<p>Este sencillo comando nos permite abrir varios ficheros en una única sesión
gráfica de vim.</p>

<p>Tal y como dicen los comentarios del vídeo, este comando solamente funciona por
defecto en la interfaz gráfica de Vim, no en la versión de Vim que se ejecuta
en la línea de comandos.</p>

<h2>(02-11-2014) Derek Wyatt: Destruction is good</h2>

<p>En este video Derek muestra cómo utilizar
<a href="http://vimeo.com/6110008">comandos destructivos para editar</a>
el contenido que queremos.</p>

<p>Comandos utilizados:</p>

<ul>
<li><code>:v/&lt;some pattern&gt;/&lt;some command&gt;</code>: es el comando <code>:vglobal</code> (usar <code>:help :vglobal</code>
para saber más). Este comando realiza acciones sobre líneas que NO cumplen el patrón
especificado.</li>
<li><code>:help :substitute</code> muestra ayuda del comando utilizado para sustituir unas cadenas
por otras.</li>
<li>Expresiones regulares, que son ya un problema en sí mismas y que darían para
mucho tiempo de aprendizaje.</li>
</ul>


<h2>(24-11-2014) Derek Wyatt: Using a Vim macro to edit many files</h2>

<p>Y después de un tiempo sin ver nada nuevo de Vim, hoy toca ver cómo se puede
<a href="http://vimeo.com/4456458">utilizar una macro para editar varios ficheros</a>, del cual,
se pueden sacar los siguientes macros y consejos:</p>

<ul>
<li><code>q + a</code> para comenzar a grabar una macro en la posición <code>a</code></li>
<li><code>@ + a</code> para ejecutar la macro grabada en la posición <code>a</code></li>
<li><code>@ + @</code> para ejecutar la última macro</li>
<li><code>5 + @ + a</code> para ejecutar la macro en <code>a</code> 5 veces</li>
<li><code>:wn</code> guardar todos los cambios y moverse al siguiente buffer</li>
<li><code>:prev</code> moverse al buffer anterior</li>
<li><code>" + a + p</code> imprime la macro guardada en la posición <code>a</code></li>
</ul>


<h2>(08-01-2015) Derek Wyatt: Vim macros and global commands</h2>

<p>Sigo aprendiendo cosas sobre Vim, esta vez sigo con
<a href="https://vimeo.com/4448635">macros en Vim y comandos globales</a>. Estos son los
comandos y nuevos consejos que aprendí:</p>

<ul>
<li><code>CTRL + A</code> incrementa en uno el primer número que encuentra en la línea</li>
<li><code>20 CTRL + A</code> incrementa en 20 el primer número de la línea</li>
<li>Grabar y ejecutar macros, visto en el anterior</li>
<li><code>:g/sometext/normal 20^A</code> es un comando global (en modo :normal, lo que sea eso
que signifique), que busca la cadena <code>sometext</code> (ya he visto antes cómo buscar
cadenas de texto) y ejecuta el comando <code>20 CTRL + A</code>. Para ello, para poder
escribir <code>CTRL + A</code> como comando, hay que pulsar <code>CTRL + V</code> para que la
siguiente pulsación la tome de forma literal, y luego pulsar <code>CTRL + A</code></li>
<li><code>CTRL + V</code> hace que Vim tome la siguiente pulsación de forma literal, muy útil
cuando se escriben comandos globales, por ejemplo.</li>
</ul>


<h2>(08-01-2015) Derek Wyatt: Vim expression register</h2>

<p>Una vez acabados los vídeos de nivel intermedio, toca comenzar con los de
nivel avanzado. Comienzo con el <a href="http://vimeo.com/4446843">registro de expresiones</a>. ¿Qué es?
¿Para qué sirve? En el vídeo lo descubro:</p>

<ul>
<li>¿Qué es? Es un registro, un lugar donde almacenar <em>cosas</em>. ¿Y qué cosas
son esas? Pues son comandos.</li>
<li>¿Para qué sirve? Lo utilizan los programadores de plugins para extender
Vim y para integrarlo con herramientas de terceros.</li>
<li><code>:imap &lt;c-j&gt;d &lt;c-r&gt;=system('echo foo')&lt;cr&gt;</code> mapea (en modo <strong>i</strong>nserción)
la combinación de teclas <code>CTRL + J, D</code> para que ejecute el comando de
sistema <code>echo foo</code> e inserte el resultado en el archivo que estamos
editando. <code>&lt;c-r&gt;</code> significa <code>CTRL + R</code>, que accede al <em>registro de expresiones</em>
del que estamos hablando.</li>
</ul>


<h2>(18-01-2015) Derek Wyatt: Vim autocomands</h2>

<p>Siguiendo con vídeos de nivel avanzado, esta vez toca <em>auto comandos</em>. Parece
una funcionalidad super útil de Vim. Es una funcionalidad donde puedes configurar
Vim para que realice los comandos que quieras cuando ocurra algún evento: por
ejemplo, cuando se guarda un fichero en disco, o cuando se mueva el cursor.
El vídeo está disponible en <a href="http://vimeo.com/4454614">Autocomandos</a>,
y es muy cortito, que no te de pereza.</p>

<ul>
<li><code>:help :autocmd</code></li>
</ul>


<h3>(18-01-2015) Derek Wyatt: Find command and the path</h3>

<p>El vídeo anterior era realmente corto, y solamente saqué en claro un comando
para Vim, <code>:autocmd</code>, pero para su uso es necesario de tener funciones u
otros comandos para que realmente haga algo.</p>

<p>Así pues, el siguiente es <a href="http://vimeo.com/6154082">Find command and the Path</a>
para aprender a buscar ficheros y cargarlos para su edición.</p>

<ul>
<li><code>:set path=&lt;directorio&gt;</code>: establece la variable <code>path</code> en Vim, para búsqueda
de ficheros por ejemplo.</li>
<li><code>:find &lt;filename&gt;</code>: busca por un fichero y lo abre para su edición</li>
<li><code>:pwd</code>: muestra el directorio de trabajo actual</li>
</ul>


<h3>(Marzo 2015) Comando <code>set statusline</code></h3>

<p>Esta vez no tengo nada de ningún video, pero es igualmente interesante. Mediante
el comando <code>set statusline</code> se puede configurar la apariencia de la <em>barra de
estado</em> de Vim. Existen muchos símbolos (por llamarlos de alguna manera) que a
modo de función <code>printf</code> pueden ser sustituidos por diversos campos dentro del
editor: nombre del fichero, número de línea, codificación del fichero,...</p>

<p>A partir de <a href="http://stackoverflow.com/questions/21069164/osx-vim-set-laststatus-2-shows-only-the-filename-but-i-want-to-see-everythin">esta pregunta en Stack Overflow</a>
encontré el fichero de configuración de <a href="https://github.com/sk1418/myConf/blob/master/common/.vimrc#L506">sk1418</a>
en el cual me basé para crearme mi propia configuarción de la barra de estado:</p>

<pre><code>set laststatus =2 " always show status bar
set statusline=%&lt;%f%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %p\ %P
</code></pre>

<p>La cual me muestra:</p>

<ul>
<li>Nombre del fichero, con la ruta completa</li>
<li>Una marca para saber si el fichero está modificado</li>
<li>Valor decimal del carácter donde está situado el cursor</li>
<li>Valor hexadecimal del mismo</li>
<li>Columna o línea del fichero donde está el cursor</li>
<li>Fila</li>
<li>Tanto por ciento del fichero donde está el cursor</li>
</ul>


<h3>(Mayo 2015) <a href="http://www.viemu.com/a-why-vi-vim.html">Why, oh why, do those #?@! nutheads use vi?</a></h3>

<p>Después de un cierto tiempo, tropecé con éste post, del cual extraje algún que
otro comando que no conocía todavía. Y no solo comandos, sino secuencias de ellos
que me permiten realizar tareas muy comunes en el desarrollo de software.</p>

<p><em>Extraer una variable</em></p>

<p>```
if (!entry.used &amp;&amp; equivalent(entry.key(), qk.key) &amp;&amp; (curcontext &amp; entry.contexts)) {</p>

<pre><code>// do something
</code></pre>

<p>}
```</p>

<p>Situar el cursor al principio de <code>equivalent</code> y teclear el comando <code>c%</code>:</p>

<p>```
if (!entry.used &amp;&amp; <cursor will be here> &amp;&amp; (curcontext &amp; entry.contexts)) {</p>

<pre><code>// do something
</code></pre>

<p>}
```</p>

<p>Resulta que eso <strong>c</strong>orta el texto <code>equivalent(entry.key(), qk.key)</code> y entra en modo
edición. Luego puedo escribir el nombre de la variable, cambiar a modo normal
y pulsar <code>O</code> para insertar una línea arriba:</p>

<p>```
<cursor here>
if (!entry.used &amp;&amp; equiv &amp;&amp; (curcontext &amp; entry.contexts)) {</p>

<pre><code>// do something
</code></pre>

<p>}
```</p>

<p>Luego, puedo declarar la variable, y pegar lo que hay en el portapapeles con <code>CTRL + R</code>:</p>

<p>```
bool equiv = equivalent(entry.key(), qk.key);
if (!entry.used &amp;&amp; equiv &amp;&amp; (curcontext &amp; entry.contexts)) {</p>

<pre><code>// do something
</code></pre>

<p>}
```</p>

<ul>
<li><code>zt</code>: Mueve la línea (hace <strong>z</strong>oom) donde está el cursor arriba del todo
(<strong>t</strong>op)</li>
<li><code>zz</code>: Mueve la línea (hace <strong>z</strong>oom) donde está el cursor al centro de la
pantalla</li>
<li><code>zb</code>: Mueve la línea (hace <strong>z</strong>oom) donde está el cursor abajo del todo
(<strong>b</strong>ottom)</li>
<li><code>*</code>: busca hacia adelante la palabra seleccionada</li>
<li><code>#</code>: busca hacia atrás</li>
<li><code>=aB</code>: corregir la indentación (<code>=</code>) de un (<strong>a</strong>) <strong>Bloque</strong></li>
<li>Comando <code>hlsearch</code>, por ejemplo: <code>:set hlsearch</code></li>
<li><code>gU</code>: convierte a mayúsculas todo el texto seleccionado</li>
<li><code>gu</code>: convierte a minúsculas todo el texto seleccionado</li>
</ul>


<h3>(Junio 2015) <a href="https://www.youtube.com/watch?v=xJz2Hq-jWxY">A casual introduction to Vim on Windows</a></h3>

<p>Por casualidad encontré este vídeo de Roy Osherove, donde habla acerca de Vim
(en Windows, aunque el sistema operativo tiene poca influencia para el nivel
que Roy nos cuenta). No aprendí ningún comando nuevo, porque Roy habla de comandos
básicos, para comenzar a usar Vim, pero creo que el vídeo es un recurso esencial
para el aprendizaje de Vim, por lo que lo enlazo aquí.</p>

<h3>(Julio 2015) <a href="http://vim.wikia.com/wiki/Word_count">Contar palabras</a></h3>

<p>De repente, escribiendo un post para este blog, me pregunté: ¿Será muy largo
el post?, ¿Cuántas palabras habrá?. Tampoco tengo claro cuantas palabras hacen
que un post sea largo, pero bueno, tenía curiosidad por saber cuántas palabras
había en el post.</p>

<p>El problema es que escribí el post en Windows. Si hubiera estado en Linux, las
hubiera contado con <code>wc -w</code>. Estaba en Vim, y decidí buscar algún plugin que
contara las palabras por mí. En lugar de eso, encontré un comando:</p>

<ul>
<li><code>g</code> + <code>CTRL g</code></li>
</ul>


<h3>(Julio 2015) <a href="https://www.youtube.com/watch?v=wlR5gYd6um0">Mastering the Vim language</a>, Chris Toomey</h3>

<ul>
<li>Priorizar <em>text objects</em> frente a movimientos (<code>iw</code> frente a <code>w</code>), hacen que
los comandos sean más repetibles, ya que seleccionan mejor. El movimiento <code>w</code>
sólo selecciona la palabra si el cursor está al inicio de la misma.</li>
<li><a href="https://github.com/tpope/vim-repeat">repeat.vim</a> es un plugin que que remapea <code>.</code> (commando repetir) de tal forma
que los comandos de los plugins sean compatibles con <code>.</code></li>
<li><code>:set relativenumber</code>, <code>:set norelativenumber</code>, para ver el número de líneas
relativas respecto a la que está el cursor</li>
</ul>


<p><strong>Algunos plugins</strong></p>

<ul>
<li><a href="https://github.com/tpope/vim-surround">surround plugin</a>:

<ul>
<li><code>ds"</code> : borra las comillas dobles de alrededor</li>
<li><code>cs"'</code> : cambia las comillas dobles que encierran el texto por comillas simples</li>
<li>y unos cuantos más, como <code>cst&lt;text&gt;</code> para cambiar tags HTML</li>
</ul>
</li>
<li><a href="https://github.com/tpope/vim-commentary">commentary plugin</a>: parece mucho más potente que el que proporciona comandos
<code>gcc</code> y demás. éste proporciona <code>cm&lt;motion&gt;</code>, por ejemplo: <code>cml</code> (comenta línea),
<code>cm4j</code> (commenta 4 líneas hacia abajo)</li>
<li><a href="http://www.vim.org/scripts/script.php?script_id=2703">replace with register plugin</a>: con el comando <code>gr&lt;motion&gt;</code>, por ejemplo,
si tengo copiada una palabra, puedo hacer <code>griw</code> para <em>go replace inner word</em></li>
<li><a href="https://github.com/christoomey/vim-sort-motion">sort-motion plugin</a>: con el comando <code>gs&lt;motion&gt;</code> lo que hace es ordenar
líneas alfabéticamente (para imports, requires,...)</li>
<li><a href="https://github.com/christoomey/vim-system-copy">system-copy plugin</a>: para copiar al portapapeles del sistema</li>
</ul>


<p><strong>Text objects personalizados</strong></p>

<ul>
<li>indentación: <code>cmii</code>, <code>cmni"</code></li>
<li>entero: <code>cmae</code> (<strong>c</strong>omment <strong>a</strong>ll <strong>e</strong>ntire, comenta el documento entero)</li>
<li>línea: <code>cml</code></li>
</ul>


<h3>(Agosto 2015) <a href="https://www.youtube.com/watch?v=3TX3kV3TICU">Let Vim do the typing</a>, by George Brocklehurst</h3>

<ul>
<li><code>"a</code> + <code>p</code>: pega lo que hay en el registro <code>a</code></li>
<li>En modo inserción, <code>CTRL + r</code> + <code>&lt;letra del registro&gt;</code>, pega lo copiado en un
registro</li>
<li><code>CTRL + a</code>, en modo inserción, pega el último texto insertado</li>
<li><code>CTRL + p</code>, <code>CTRL + SHIFT + p</code>, <code>CTRL + n</code>, para autocompletar palabras en los
documentos abiertos de Vim</li>
<li>Con un fichero CTAGS, si escribo el nombre de una clase y presiono <code>CTRL + }</code>
(o <code>CRTL + ]</code> no lo tengo claro), Vim me lleva a la declaración de esa clase</li>
<li>Con <code>CTRL + x</code> entra en el modo de autocompletado (palabras, líneas, párrafos,...)</li>
<li>Después de un <code>CTRL + }</code>, puedes volver a navegar hacia atrás con <code>CTRL + o</code></li>
<li><code>CTRL + x</code> seguido de <code>CTRL + f</code> entra en el modo autocompletar nombres de
ficheros</li>
<li>Con <code>CTRL + x</code> seguido de <code>CTRL + p</code> puedes ir autocompletando palabras de una
frase. Cada vez que pulsas los dos, puedes ir autocompletando una palabra</li>
<li>Con <code>CTRL + x</code> seguido de <code>CTRL + n</code> lo mismo pero en el otro sentido</li>
<li>Con <code>CTRL + x</code> seguido de <code>CTRL + l</code> se autocompletan líneas. Si sigues con
<code>CTRL + x</code> -> <code>CTRL + l</code> te va autocompletando siguientes líneas</li>
<li>Con <code>CTRL + x</code> -> <code>CTRL + o</code>, qué tal si te puede autocompletar métodos en tu
lenguaje de programación. No necesita plugin</li>
<li><code>:set complete</code> muestra tu configuración de autocompletado. el valor por
defecto que muestra es: <code>.,w,b,u,t,i,kspell</code>. <code>.</code> del buffer actual, <code>w</code> de
las ventanas abiertas, <code>b</code> de los buffers abiertos, <code>u</code> de los buffers no
activos, <code>t</code> de los ficheros CTAGS, <code>i</code> de los includes/requires, <code>kspell</code>
en los diccionarios cuando tengas activado el chequeo de ortografía
(<code>:set spell</code>)</li>
<li><a href="https://georgebrock.github.io/talks/vim-completion">Repositorio de George</a>, por si se necesita algún documento de referencia</li>
</ul>


<h3>(29-08-2015) Derek Wyatt: Globals, commands and functions</h3>

<p>El último vídeo de Derek, de su lista de <a href="http://derekwyatt.org/vim/tutorials/advanced/">vídeos para aprender Vim</a>. Este vídeo se
titula <a href="https://vimeo.com/15443936">Globals, commands and functions</a>, y estas son las notas que tomé mientras
lo estuve viendo:</p>

<ul>
<li><code>:saveas &lt;path&gt;</code>: para guardar un fichero con un nuevo nombre</li>
<li><code>:set ft=xml</code>: establece el tipo de fichero (<code>ft</code>) a <code>xml</code></li>
<li><code>=g</code> (o <code>=gg</code>): para indentar todo el fichero</li>
<li><code>:%s/&lt;regexp&gt;/&lt;text&gt;/</code>: sustituye globalmente en todo el fichero. Dentro de la expresión regular, podemos crear grupos de texto encerrados entre <code>\(</code> y <code>\)</code>. Estos grupos serán recordados y podrán incluirse en la parte del texto mediante <code>\1</code>, <code>\2</code>,...</li>
<li><code>:g</code>: comando <strong>g</strong>lobal. Permite ejecutar comandos (<strong>i</strong>nsertar, borrrar, copiar,...) desde la línea de comandos. Ver <code>:help :g</code></li>
<li><code>:v</code>: igual que <code>:g</code> pero a la inversa. Por ejemplo, <code>:v/^foo/d</code>, busca las líneas que empiezan con <code>foo</code>, y las que no lo hacen, las borra. Es decir, ejecuta un comando en las líneas que NO cumplen una condición</li>
<li><code>:normal</code>: te permite ejecutar comandos del modo normal desde la línea de comandos</li>
<li><code>:normal gggqG</code>: ejecuta los comandos <code>gg</code> (ir al inicio del fichero), <code>gq</code> (corta las líneas al ancho especificado con <code>set tw=&lt;width&gt;</code>), <code>G</code> hasta el final del fichero</li>
<li><code>gq</code>: inserta carácteres de nueva línea para adecuar el ancho de línea al especificado con <code>:set tw=&lt;width&gt;</code></li>
<li><code>:g/^-/s/- //</code>: es un comando global (<code>:g</code>), para aquellas líneas que
comienzen con <code>-</code>. El comando es <strong>s</strong>ustituir (<code>s</code>) los carácters <code>-</code> con
<code>vacío</code></li>
<li><code>:%s/\s\{4}//</code>: sustituye en todo el fichero exactamente 4 espacios en blanco
(<code>\s\{4}</code>) con <code>vacío</code></li>
<li><code>\zs</code> en medio de una expresión regular de sustitución: hace que la
sustitución comienze a partir de ahí. Por ejemplo: <code>:%s/\s\{8}\zs-/#/</code> hace
que busque 8 espacios en blanco seguidos de un guión, y que sustituya a partir
de los 8 espacios en blanco, que no los toque</li>
<li><code>:history</code>: muestra un histórico de los últimos comandos de la línea de
comandos (<code>:history : -20</code> muestra sólo los últimos 20)</li>
</ul>


<h1>(Septiembre 2015) <a href="https://www.youtube.com/watch?v=lwD8G1P52Sk">My first Vim plugin</a>, de Chris Toomey</h1>

<p>En la charla <a href="https://www.youtube.com/watch?v=lwD8G1P52Sk">My first Vim plugin</a> aprenderemos a crear plugins para Vim. No te
asustes, no es para tanto. También aprenderemos a crear funciones que se puedan
llamar desde la línea de comandos de Vim, éste es el inicio de cualquier
plugin.</p>

<ul>
<li><code>:set spell</code>: activa la corrección ortográfica</li>
<li><code>]s</code>: lleva el cursor al primer error ortográfico que encuentre</li>
<li><code>z=</code>: muestra un menú con las opciones para corregir el error ortográfico</li>
<li><code>1z=</code>: selecciona (sin abrir el menú) la primera opción de correción</li>
<li><code>m&lt;letra&gt;</code>: establece un marcador en la posición donde está el cursor ahora mismo.</li>
<li><code>&lt;backtic&gt;&lt;backtic&gt;&lt;letra&gt;</code>: mueve el cursor hasta el marcador que diga <code>&lt;letra&gt;</code></li>
<li><code>:normal! &lt;comando&gt;</code>: ejecuta tal cual el comando que le escribamos. Por
ejemplo, si escribimos <code>:normal! mm]s1z=&lt;back-tick&gt;m</code>, ejecuta lo siguiente:
establece un marcador en <code>m</code> (<code>mm</code>), va al primer error ortográfico (<code>]s</code>),
lo corrige con la primera opción (<code>1z=</code>), vuelve el cursor a la posición donde
estábamos (<code>&lt;back-tick&gt;m</code>)</li>
<li>En un fichero de configuración de Vim:</li>
</ul>


<p><code>``
nnoremap &lt;leader&gt;sp :normal! mm]s1z=</code>m<cr></p>

<h1>no olvidar <cr> al final, es como pulsar <enter></h1>

<p>```</p>

<p>Lo que hace es asignar la sequencia de comandos <code>&lt;leader&gt;sp</code> para que ejecute
el comando que hemos estado hablando. Y qué tecla es <code>&lt;leader&gt;</code>? Dice que
normalemente es <code>\</code>, pero que él la tiene mapeada a <code>&lt;spacebar&gt;</code>. Otra gente
la suele tener mapeada a la coma.</p>

<p>Ahora, lo englobamos en una función:</p>

<p>```
function! FixLastSpellingError() {</p>

<pre><code>normal! mm]s1z=`m
</code></pre>

<p>}
nnoremap <leader>sp :call FixLastSpellingError
```</p>

<ul>
<li><code>{</code> mueve el cursor al inicio del párrafo, <code>}</code> lo mueve al final</li>
<li>con <code>kmmjdd{p&lt;back-tick&gt;m</code> podemos mover una línea arriba del todo del párrafo (al principio
de una lista, por ejemplo): sube una línea, pone un marcador, baja, borra la línea,
se mueve al principio del párrafo, pega y vuelve al marcador.</li>
<li><code>yypVr=&lt;cr&gt;</code>: marca una línea como el primer título de Markdown:
copia la línea, la pega debajo, se mueve debajo, selecciona
visualmente la línea completa, reemplaza todo con <code>=</code>.</li>
</ul>


<p><strong>Plugins</strong></p>

<ul>
<li>quicklink: para visitar enlaces que tengas en un fichero Markdown</li>
<li>text-obj-indent: son objectos de texto adicionales, como por ejemplo un nivel
de indentación</li>
<li>sort-motion: permite ordenar con comandos de movimiento: palabra, linea, párrafo,...</li>
<li>tmux_nav y tmux_runner: para manejar sessiones de tmux desde Vim, abriendo
ventanas en Vim y enviando comandos a ellas</li>
</ul>


<!-- 
  ¿Queda algo por aprender por aquí, o simplemente repasar ya?
-->



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Efectividad de 10 técnicas para estudiar]]></title>
    <link href="http://rchavarria.github.io/blog/2014/09/07/efectividad-de-10-tecnicas-para-estudiar/"/>
    <updated>2014-09-07T10:23:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2014/09/07/efectividad-de-10-tecnicas-para-estudiar</id>
    <content type="html"><![CDATA[<p>Hace poco, escuchando el episodio 20 del podcast
<a href="http://www.bastayadepicar.com/episodio/020">Basta ya de picar</a>,
los creadores del podcast proponían un artículo como muy interesante.
Dicho artículo trataba de
<a href="http://bigthink.com/neurobonkers/assessing-the-evidence-for-the-one-thing-you-never-get-taught-in-school-how-to-learn">cómo aprender a aprender</a>.</p>

<p>Lo leí y me pareció tan interesante que no pude resistirme a hacer un pequeño
resumen para poder consultarlo en un futuro, y ya de paso, ¿por qué no
publicarlo?</p>

<!-- more -->


<h2>Técnicas</h2>

<p>Aquí están las técnicas ordenadas de mayor a menor efectividad:</p>

<ul>
<li><p>Exámenes (efectifidad alta): la técnica es más efectiva cuanto más elaboradas
tengan que ser las respuestas, pero incluso los de múltiples opciones son efectivos.
También resultan muy efectivos si las preguntas las elige uno mismo.
Relacionado: <a href="http://en.wikipedia.org/wiki/Cornell_Notes">Sistema para tomar notas de Cornell</a>,
incluso se incluye una <a href="http://lsc.cornell.edu/LSC_Resources/cornellsystem.pdf">plantilla</a>.</p></li>
<li><p>Práctica distribuida (efectividad alta): qué es mejor, ¿estudiarlo todo de
golpe o dividirlo y planificarlo a lo largo del tiempo?. Algunos estudios
recomiendan dividirlo y espaciarlo entre un 10% y 20% del tiempo que queremos
retener lo aprendido. Por ejemplo, si disponemos de un año, estudiaríamos una
vez al mes. esto contrasta mucho con la práctica habitual de los estudiantes
de estudar todo el último momento (ese conocimiento no durará mucho).</p></li>
<li><p>Elaborar preguntas (efectividad media): se trata de crear explicaciones de
<strong>por qué</strong> los hechos estudiados son verdaderos. Se concentran los esfuerzos
en el <em>por qué</em>, en lugar de en el <em>qué</em>. Suele ayudar tener conocimientos
previos de lo que se está estudiando.</p></li>
<li><p>Auto-explicación (efectividad media): es muy buena técnica para aprender
conceptos abstractos. Se trata de explicar <strong>cómo</strong> uno resuelve o entiende
el problema mientras se razonan las elecciones que se van tomando. Es más
efectivo si se hace mientras se estudia que si se hace después.</p></li>
<li><p>Práctica intercalada (efectividad media): qué es mejor, ¿estudiar temas en
bloques o estudiarlos entrelazados? En realidad, no se sabe muy bien, pero parece
que funciona bastante bien para aprendizajes que mezclan lo físico y lo mental.</p></li>
<li><p>Resúmenes (efectividad baja): no es tan efectivo como las anteriores pero sí
que es más que el subrayado, utilizar palabras claves y la re-lectura.</p></li>
<li><p>Subrayado (efectividad baja): no es muy efectivo porque no necesita de una
especial atención.</p></li>
<li><p>Palabras claves como mnemónicos (efectividad baja): es efectiva para ciertos
aprendizajes, como por ejemplo recordar nombres, nuevos idiomas, términos cienticios, ...</p></li>
<li><p>Asociar texto con imágenes (efectividad baja): es efectiva para recordar frases,
pero no mucho para textos largos.</p></li>
<li><p>Re-lectura (efectividad baja): es más eficiente si se espacia en el tiempo que
si se realiza justo después de terminar la primera lectura.</p></li>
</ul>


<h2>Conclusión</h2>

<p>Cada una de estas técnicas, por sí sola, no tendrá un efecto muy positivo en
nuestro aprendizaje, pero si las combinamos, seguro que notamos mejoría. Por
ejemplo, según el artículo, qué tal si la próxima vez que tengamos que
aprender algo planificamos unos intervalos de estudio a lo largo del tiempo,
mientras lo estudiamos por qué no nos formulamos una serie de preguntas
(haciendo incapié en el <em>por qué</em> de los conceptos), para después responder
con nuestras propias palabras a dichas preguntas.</p>

<h3>Cómo funciona la técnica de tomar notas de Cornell</h3>

<p>Resumen extraído de la entrada en la wikipedia:
<a href="http://en.wikipedia.org/wiki/Cornell_Notes">Cornell note-taking system</a></p>

<p>Dividir el papel en dos columnas: <em>columna de preguntas</em>, de 1/3 del ancho y
<em>columna de notas</em>, 2/3 de ancho. La columna de notas es la de tomar notas de
la lección que estamos recibiendo. La columna de preguntas es para anotar
palabras claves y preguntas que nos surjan. Esta columna se rellena cuanto
antes una vez hayamos terminado de tomar notas.</p>

<p>Al pie de página, reservar 5 o 7 líneas para hacer un resumen de las notas
tomadas. Para estudiar, simplemente tapar con la mano la columna de notas y
tratar de responder a las preguntas de la columna de preguntas.</p>
]]></content>
  </entry>
  
</feed>
