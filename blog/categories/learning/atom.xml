<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: learning | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/learning/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2016-09-11T22:56:03+02:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir: quinto asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/09/11/elixir-quinto-asalto/"/>
    <updated>2016-09-11T11:43:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/09/11/elixir-quinto-asalto</id>
    <content type="html"><![CDATA[<p>Y ya vamos por el quinto asalto, el quinto de la serie sobre el aprendizaje del
lenguaje <a href="http://elixir-lang.org/">Elixir</a>. En este asalto aprenderemos estructuras de control de flujo,
esenciales en cualquier lenguaje de programación. No sé en otros lenguajes
funcionales, pero en Elixir, estas estructuras no son muy bien acogidas. De
todas formas, son parte del lenguaje, son sencillas y nos servirán para
establecer conexiones con lenguajes que ya conozcamos.</p>

<p>Para seguir con el aprendizaje, sigo con el método seguido en otros asaltos
partiendo del post <a href="/blog/2016/01/17/aprendiendo-elixir/">aprendiendo Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/fight-II-harc-II.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/6bQhPq">Fight II / Harc II</a> de <a href="https://www.flickr.com/photos/silangel/">silangel</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p>En Elixir no se usan mucho, se suelen escribir métodos pequeños, que junto con
claúsulas de guarda y <em>pattern matching</em> nos alejan bastante de lo que aquí
estudiaremos. Normalmente, se suelen favorecer esos mecanismos frente a
estructuras de control. Al principio cuesta acostumbrarse, pero luego uno se va
dando cuenta de que los cuerpos de los métodos quedan más pequeños y más
enfocados a hacer una sola cosa, aunque despista un poco que una misma función
tenga varios cuerpos.</p>

<p><strong><code>if</code> y <code>unless</code></strong></p>

<p>```</p>

<h1>Ambos toman dos parámetros, una condición y una <em>keyword list</em>, cuyas claves posibles son <code>do:</code> y <code>else:</code>.</h1>

<p>if 1 == 2, do: "truthy", else: "falsy"
unless 2 == 1, do: "do not execute", else: "execute this"</p>

<h1>igual que las funciones, se puede acortar un poco</h1>

<p>if 1 == 2 do
  "truthy"
else
  "falsy"
end
```</p>

<p><strong><code>cond</code></strong></p>

<p>En realidad es una macro, como muchas otras construciones del lenguaje, y
acepta una serie de condiciones. Se ejecutará el código de la primera condición
que se evalúe a <code>true</code>.</p>

<p>```</p>

<h1>Resolver la kata FizzBuzz</h1>

<p>cond do
  rem(current, 3) == 0 and rem(current, 5) == 0 -> "FizzBuzz"
  rem(current, 5) == 0 -> "Buzz"
  rem(current, 3) == 0 -> "Fizz"
  true -> current
end
```</p>

<p>En muchos casos, una mejor alternativa puede ser utilizar múltiples funciones,
pattern matching y claúsulas de guarda en lugar del bloque <code>cond</code>.</p>

<p><strong><code>case</code></strong></p>

<p><code>case</code> permite evaluar una serie de patrones, y ejecuta el código asociado a
dicho patrón. También se pueden usar claúsulas de guarda.</p>

<p>```</p>

<h1>para controlar errores al abrir un fichero</h1>

<p>case File.open("some file.txt") do
  { :ok, file } -> IO.puts "First line: #{IO.read(file, :line)}"
  { :error, reason } -> IO.puts "Failed to open file: #{reason}"
end</p>

<h1>con claúsulas de guarda</h1>

<p>dave = %{name: "Dave", age: 27}
case dave do
  person = %{age: age} when is_number(age) and age >= 21 -> IO.puts "You are allowed #{person.name}"
  _ -> IO.puts "You are not allowed"
end
```</p>

<p><strong>Excepciones</strong></p>

<p>Las excepciones en Elixir se usan para casos excepcionales. Por ejemplo, si hay
un fallo al leer un fichero de configuración, con un nombre fijo. Pero no si
hay un error al leer un fichero que el usuario ha introducido el nombre,
podemos controlar eso, y no sería un error excepcional.</p>

<p>```</p>

<h1>lanzando una RuntimeError</h1>

<p>raise "Giving up"</p>

<h1>o con algunos argumentos</h1>

<p>raise RuntimeError, message: "Stack overflow"</p>

<h1>por convención, se suele escribir <code>!</code> al final de una llamada que puede</h1>

<h1>devolver una excepción bien conocida, por ejemplo</h1>

<p>{ ok: file } = File.open!("foo.bar")
```</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li>[exercise-01-round-05.exs]: reescribe la kata FizzBuzz con <code>case</code></li>
<li>[exercise-02-round-05.exs]: muchas funciones tienen una segunda
implementación, que termina con <code>!</code>, la cual, si el resultado no coincide con
<code>{ :ok, data }</code> lanza una excepción. Implementa una función <code>ok!</code> que haga
exactamente esto</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: cuarto asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/08/10/elixir-cuarto-asalto/"/>
    <updated>2016-08-10T17:20:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/08/10/elixir-cuarto-asalto</id>
    <content type="html"><![CDATA[<p>Éste es el cuarto asalto en mi aventura aprendiendo <a href="http://elixir-lang.org/">Elixir</a>. En esta ocasión
trato con tipos de datos binarios, cadenas y <strong>sigils</strong>. No es mucho, pero las cadenas son
una parte esencial de cualquier lenguaje de programación. Y dominarlas
significa dominar una gran parte del lenguaje.</p>

<p>Por supuesto, sigo aprendiendo con el método descrito en el post sobre <a href="/blog/2016/01/17/aprendiendo-elixir/">aprender Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/fourth-fight.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/5yHK4Y">Muñeco de Gohan y Bu peleando</a> de <a href="https://www.flickr.com/photos/alotor/">Alonso Javier Torres</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p>Para definir una cadena se pueden usar comillas simples o comillas dobles.
También se puede usar comillas triples, para escribir lo que llaman <code>heredocs</code>,
y se suelen usar para escribir comentarios para documentar métodos y módulos.</p>

<p>En Elixir, existe lo que llaman <em>sigils</em> (que se podría traducir como código,
señal o símbolo mágico). Comienzan con <code>~</code>, seguido de una letra que determina
el tipo de símbolo:</p>

<ul>
<li><code>c</code> para una lista de carácteres</li>
<li><code>r</code> para expresión regular</li>
<li><code>w</code> para una lista de palabras separado por espacios</li>
<li>y hay más</li>
</ul>


<p>y cuyo valor se puede enmarcar en distintos delimitadores: <code>&lt;..&gt;</code>, <code>{...}</code>,
<code>[...]</code>,...</p>

<p>Un uso muy típico es para escribir expresiones regulares:</p>

<p><code>
~r{[0-9]+[A-Z]*}
</code></p>

<p>Los <em>sigils</em> pueden incluso personalizarse, y crear los tuyos propios.</p>

<p>Las cadenas definidas mediante comillas dobles, son lo que se conoce en otros
lenguajes como <em>strings</em>. Las cadenas con comillas simples, se llaman
<em>character lists</em> (o <em>char list</em>), listas de carácteres, y son listas, arrays.</p>

<p><strong>Cadenas con comillas simples</strong></p>

<p>Son una lista de códigos que representan los carácteres. Y como son una lista,
podemos usar métodos de <code>List</code>: <code>++</code>, <code>--</code>, <code>List.zip</code>, <code>[ head | tail ]</code>,...</p>

<p>Para saber el número entero que representa un carácter, se puede usar la
notación <code>?&lt;chr&gt;</code>, por ejemplo, <code>?a</code> o <code>?4</code>, para saber los valores numéricos
de los carácteres <code>a</code> y <code>4</code> respectivamente.</p>

<p><strong>Binarios</strong></p>

<p>Qué mejor que un poco de código para ver cómo se usa este tipo de datos</p>

<p>```</p>

<h1>el tipo <em>binario</em> representa una secuencia de bits</h1>

<p>iex> b = &lt;&lt; 1, 2, 3 >>
&lt;&lt;1, 2, 3>>
iex> byte_size b
3
iex> bit_size b
24</p>

<h1>se puede especificar también la cantidad de bits que queremos que ocupen</h1>

<p>iex> b = &lt;&lt; 1::size(2), 1::size(3) >>
&lt;&lt;9::size(5)>>
iex> byte_size b
1
iex> bit_size b
5</p>

<h1>también se pueden almacenar enteros, floats y otros binarios</h1>

<p>iex> an_int = &lt;&lt; 1 >>
&lt;<1>>
iex> a_float = &lt;&lt; 2.5 :: float >>
&lt;&lt;64, 4, 0, 0, 0, 0, 0, 0>>
iex> mix = &lt;&lt; an_int :: binary, a_float :: binary >>
&lt;&lt;1, 64, 4, 0,......>></p>

<h1>extraer valores (echa un vistazo a cómo se codifican los floats según</h1>

<h1>el estándar IEEE 754)</h1>

<p>iex> &lt;&lt; sign::size(1), exp::size(11), mantissa::size(52) >> = &lt;&lt; 3.14159::float >>
iex> (1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exp-1023)
3.14159</p>

<h1>las cadenas con comillas dobles "" (dqs: double quoted string) son de</h1>

<h1>tipo binario, y están codificadas en UTF-8 lo que significa que la</h1>

<h1>longitud de la cadena no tiene por qué coincidir con el tamaño en bytes</h1>

<p>iex> dqs = "∂x/∂y"
"∂x/∂y"
iex> String.length dqs
5
iex> byte_size dqs
9
```</p>

<p><strong>Procesando cadenas</strong></p>

<p>Igual que podemos dividir una lista en <code>head</code> y <code>tail</code>, podemos extraer el
primer carácter (se refiere a él como <em>grapheme</em>, grafema/grafo/...) de una
cadena binaria o <em>dqs</em> especificando que <code>head</code> es de tipo <code>utf8</code> y que <code>tail</code>
sigue siendo de tipo binario:</p>

<p><code>
defp each(&lt;&lt; head::utf8, tail::binary &gt;&gt;), do [ head | each(tail) ]
defp each(&lt;&lt;&gt;&gt;), do []
</code></p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p>Está claro que hay que ver la documentación del módulo <a href="http://elixir-lang.org/docs/stable/elixir/String.html"><code>String</code></a>, que contiene
métodos para manipular cadenas encerradas en comillas dobles (recuerda, son de
tipo binario).</p>

<p>Las expresiones regulares son bastante comunes, y en Elixir se suelen usar
mediante <a href="http://elixir-lang.org/getting-started/sigils.html"><em>sigils</em></a>. Son un aspecto bastante curioso del lenguaje y pueden ser
personalizados.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-01-round-04.exs">exercise-01-round-04.exs</a>: escribe una función que devuelva <code>true</code> si el
parámetro (una lista de carácteres) contiene sólo carácteres imprimibles (del
espacio a la tilde)</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-02-round-04.exs">exercise-02-round-04.exs</a>: escribe una función que devuelva <code>true</code> en el
caso de que dos palabras sean anagramas. <code>anagram?(word1, word2)</code></li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-03-round-04.exs">exercise-03-round-04.exs</a>: escribe una funcion que calcule suma, resta,...
de una cadena pasada como parámetro: <code>calculate('123 + 27') # =&gt; 150</code>. Este
es especialmente difícil (al menos para mi nivel): devolver tuplas, parsear
números (utilizando recursión de una forma muy imaginativa), utilizando pattern
matching para construir funciones dependiendo del operador,...</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-04-round-04.exs">exercise-04-round-04.exs</a>: escribe una función que pasándole una lista de
dqs (double quoted strings) las imprima centradas en un ancho de la palabra
más larga, cada una en una línea distinta.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-05-round-04.exs">exercise-05-round-04.exs</a>: escribe una función que pase a mayúsculas la
primera letra de cada frase en una cadena</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-06-round-04.exs">exercise-06-round-04.exs</a>: escribe una función que parsee un fichero CSV
(que tendrá los campos id, estado y cantidad neta), y que se lo pase a la
función desarrollada en el tercer asalto, al ejercicio
<code>exercise-02-round-03.exs</code>.</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: tercer asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/05/01/elixir-tercer-round/"/>
    <updated>2016-05-01T17:46:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/05/01/elixir-tercer-round</id>
    <content type="html"><![CDATA[<p>Éste es el tercer asalto para aprender <a href="http://elixir-lang.org/">Elixir</a>, y las cosas se van poniendo
interesantes, aunque todavía siento que estoy muy verde y me falta todavía
mucho para ser capaz de hacer las cosas más sencillas.</p>

<p>En este asalto, aprendo nuevas cosas proporcionadas por los módulos <code>Enum</code>,
<code>Stream</code> y otras coleciones, así como las <em>comprehensions</em>, que me recuerdan
mucho a los clásicos bucles <code>for</code>.</p>

<p>Sigo aprendiendo siguiendo el método descrito en el post sobre <a href="/blog/2016/01/17/aprendiendo-elixir/">aprender Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/third-fight.png"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/c9bWJA">3rd fight</a> de <a href="https://www.flickr.com/photos/takfoto/">Tomasz Krawczak</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/legalcode">CC BY-NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Procesando colleciones con <code>Enum</code></strong></p>

<p>Elixir tiene muchos tipos de datos que actúan como colleciones: listas, mapas,
diccionarios, rangos, ficheros e incluso funciones. Las colecciones se pueden
iterar (sobretodo con funciones del módulo <code>Enum</code>), y algunas permiten añadir
elementos.</p>

<p>```</p>

<h1>convierte cualquier colección a List</h1>

<p>list = Enum.to_list 1..5
  #=> [1, 2, 3, 4, 5]</p>

<h1>concatena</h1>

<p>Enum.concat([1, 2, 3], [4, 5, 6])
  #=> [1, 2, 3, 4, 5]</p>

<h1>crea nuevas colleciones</h1>

<p>Enum.map(list, &amp;(&amp;1 * 10))
  #=> [10, 20, 30, 40, 50]</p>

<h1>selecciona elementos por posición</h1>

<p>Enum.at(10..20, 3) #=> 13
Enum.at(10..20, 20) #=> nil
Enum.filter(list, &amp;(&amp;1 > 2)) #=> [3, 4, 5]
Enum.reject(list, &amp;Integer.is_even/1) #=> [1, 3, 5]</p>

<h1>ordena y compara elementos</h1>

<p>Enum.sort([ "there", "was", "a", "crooked", "man" ],
  &amp;(String.length(&amp;1) &lt;= String.length(&amp;2))
Enum.max([ "there", "was", "a", "crooked", "man" ]) #=> "was"</p>

<h1>divide una colleción</h1>

<p>Enum.take(list, 3)    #=> [1, 2, 3]
Enum.take_every(list, 2)  #=> [1, 3, 5]
Enum.take_while(list, &amp;(&amp;1 &lt; 4))
Enum.split(list, 3)
  #=> { [1, 2, 3], [4, 5] }
Enum.split_while(list, &amp;(&amp;1 &lt; 4))
  #=> { [1, 2, 3], [4, 5] }</p>

<h1>une los elementos de una colección</h1>

<p>Enum.join(list)
Enum.join(list, ", ")   #=> "1, 2, 3, 4, 5"</p>

<h1>hace preguntas sobre operaciones</h1>

<p>Enum.all?(list, &amp;(&amp;1 &lt; 4))
Enum.any?(list, &amp;(&amp;1 &lt; 4))
Enum.member?(list, 4)
Enum.empty?(list)</p>

<h1>mezcla colecciones</h1>

<p>Enum.zip(list, [:a, :b, :c])
  #=> [ {1, :a}, {2, :b}, {3, :c} ]</p>

<h1>otros</h1>

<p>Enum.reduce(<collection>, <function>)
```</p>

<p><strong><code>Stream</code>s, enumerables diferidos o perezosos</strong></p>

<p>El módulo <code>Stream</code> permite enumerar collecciones de forma diferida (<em>lazy</em> es
la palabra utilizada, que traduzco libremente como <em>diferida</em>).</p>

<p>Las funciones del módulo <code>Enum</code> procesan todos los elementos de la colección de
una vez, consumiendo memoria. Las del módulo <code>Stream</code> consumen los elementos de
uno en uno, según se van necesitando. Los <em>streams</em> se pueden componer, es
decir, los streams son collecciones, por lo que se pueden usar las funciones de
<code>Stream</code> con los propios streams (sería como crear streams de streams).</p>

<p>Finalmente, para obtener los resultados, se puede convertir un <code>Stream</code> a una
lista:</p>

<p><code>
[1, 2, 3, 4, 5]
  |&gt; Stream.map(&amp;(&amp;1 * &amp;1)
  |&gt; Stream.map(&amp;(&amp;1 + 1)
  |&gt; Stream.filter(fn x -&gt; rem(x, 2) == 1 end)
  |&gt; Enum.to_list
</code></p>

<p>Con <code>Enum</code> debemos esperar a tener todos los elementos de la colección para
empezar a procesarlos. Con <code>Stream</code> podemos comenzar a procesarlos
inmediatamente. Imagina que leemos de un servidor remoto, o de un sensor, ambos
mandan datos infinitamente, por lo que <code>Enum</code> no sería una opción válida en
este caso.</p>

<p>Normalmente, serán las librerías y los frameworks quienes nos proporcionen los
streams con los que vamos a trabajar, pero también podemos crearlos nosotros
con métodos proporcionados por Elixir: <code>cycle</code>, <code>repeatedly</code>, <code>iterate</code>,
<code>unfold</code> y <code>resource</code>.</p>

<p>```</p>

<h1>cycle toma una coleción y va devolviendo de uno en uno indefinidamente</h1>

<h1>cuando la colección se acaba, vuelve a empezar desde el principio</h1>

<p>Stream.cycle([1, 2, 3])
  |> Enum.take(10)</p>

<h1>=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]</h1>

<h1>repeatedly toma una función y la ejecuta cada vez que se le pide un elemento</h1>

<p>Stream.repeatedly(fn -> true end) |> Enum.take(3)
  #=> [ true, true, true ]
Stream.repeatedly(&amp;:random.uniform/0) |> Enum.take(3)
  #=> [ 0.723, 0.941, 0.1234 ]</p>

<h1>iterate toma un valor inicial y una función. el primer elemento es el valor inicial,</h1>

<h1>el siguiente es el valor devuelto por la función pasándole el valor inicial, el siguiente</h1>

<h1>es el valor devuelto por la función pasándole el valor anterior, así indefinidamente</h1>

<p>Stream.iterate(0, &amp;(&amp;1 + 1)) |> Enum.take(5)
  #=> [0, 1, 2, 3, 4]</p>

<h1>unfold es similar a iterate, pero con tuplas. el primer valor de la tupla</h1>

<h1>significa el valor de la iteración actual, el segundo valor significa el valor</h1>

<h1>a procesar en la siguiente iteración</h1>

<p>Stream.unfold( {0, 1}, fn {f1, f2} -> {f1, {f2, f1+f2}} end ) |> Enum.take(15)
  #=> [0, 1, 1, 2, 3, 5, 8, 13, ... fibonacci]</p>

<h1>resource es similar a unfold. toma tres funciones como argumentos. la primera</h1>

<h1>crea el recurso, la segunda va dando valores de las iteraciones (como unfold)</h1>

<h1>y la tercera cierra el recurso (fichero, bbdd, ...)</h1>

<p>```</p>

<p><strong>El protocolo <code>Collectable</code></strong></p>

<p>No son lo mismo, y todavía no soy capaz de describir exactamente lo que es un
<em>protocolo</em>, pero el concepto que tengo de ellos hoy mismo es que son
<em>equivalentes</em> a las interfaces en los lenguajes orientados a objetos.</p>

<p><code>Enumerable</code> es un protocolo que permite iterar una colección. <code>Collectable</code>
permite añadir elementos a una colección. Se puede utilizar <code>Enum.into</code> para
hacerlo y convertir un tipo de colección en otro.</p>

<p><code>
Enum.into 1..5, [1000, 10001]
  #=&gt; [1000, 1001, 1, 2, 3, 4, 5]
</code></p>

<p><strong>Comprehensions</strong></p>

<p>Se le pueden pasar una o más colecciones, entonces extrae todas las
combinaciones posibles de los elementos de dichas colecciones, opcionalmente
puede filtrar valores, y genera una nueva colección con los valores que pasan
el filtro. La sintaxis es <code>result = for &lt;generator&gt; or &lt;filter&gt;, do:
&lt;expression&gt;</code>. Donde <code>&lt;generator&gt;</code> tiene la forma <code>pattern &lt;- collection</code> y el
filtro es simplemente una condición, por ejemplo <code>x &lt; 4</code>.</p>

<p>Las variables declaradas en una comprehension tienen la misma como ámbito, no
escapan de él.</p>

<p>```
for x <- [1, 2, 3, 4, 5], x < 4, do: x * x
  # => [1, 4, 9]</p>

<p>for x <- [1, 2], y <- [5, 6], do: x * y
  # => las posibles combinaciones serían [1, 5], [1, 6], [2, 5], [2, 6]
  # => y esas combinaciones serían las iteraciones de la comprehension</p>

<h1>se pueden usar variables de generadores en siguientes generadores</h1>

<p>min_maxes = [ {1, 4}, {2, 3}, {10, 15} ]
for { min, max } <- min_maxes, n <- min..max, do: n
  # => [ 1, 2, 3, 4, 2, 3, 10, 11, 12, 13, 14, 15 ]</p>

<h1>por defecto, las comprehensions devuelven una lista. Se puede cambiar</h1>

<h1>con el parámetro <code>into:</code></h1>

<p>for x <- ~w{ cat dog }, into: Map.new, do: { x, String.upcase(x) }
  # => %{ "cat" => "CAT", "dog" => "DOG" }
```</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p>Podría investigar sobre qué son los protocolos, pero creo que están descritos
en el libro del cual está surgiendo esta serie de posts, por lo que esperaré a
llegar ahí.</p>

<p>Tener siempre muy presente las funciones del módulo <code>Enum</code>, ya que casi seguro
que se van a utilizar siempre que haya colecciones de por medio.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/exercise-01-round-03.exs">exercise-01-round-03.exs</a>: con ayuda de la función <code>span</code> escrita anteriormente, escribir una función que devuelva la lista de números primos de <code>2</code> hasta <code>n</code></li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/exercise-02-round-03.exs">exercise-02-round-03.exs</a>: a partir de dos listas, una de tasas de impuestos, y otra de compras, calcular el importe total de cada una de las compras</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/lists-and-recursion-5.exs">lists-and-recursion-5.exs</a>: implementar funciones presentes en <code>Enum</code>: <code>all?</code>, <code>each</code>, <code>filter</code>, <code>take</code> y <code>split</code>.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/lists-and-recursion-6.exs">lists-and-recursion-6.exs</a>: implementar <code>flatten</code></li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: segundo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/03/27/elixir-segundo-asalto/"/>
    <updated>2016-03-27T17:42:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/03/27/elixir-segundo-asalto</id>
    <content type="html"><![CDATA[<p>Sigo aprendiendo <a href="http://elixir-lang.org/">Elixir</a>, despacio, pero sigo con ello. Éste es el segundo
asalto del aprendizaje. En este asalto, lucho con estructuras de datos un poco
más complejas, como listas, diccionarios, <em>structs</em> o <em>sets</em>. Estas estructuras
ya existen en otros lenguajes de programación, pero en Elixir son tratadas de
una forma un poco diferente.</p>

<p>Por supuesto, en este asalto también sigo el método de aprendizaje descrito
desde el post sobre <a href="/blog/2016/01/17/aprendiendo-elixir/">aprender Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2016/rms-won.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/2PDNng">RMS won</a> de <a href="https://www.flickr.com/photos/kmerenkov/">Konstantin Merenkov</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/legalcode">CC BY-NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Listas</strong></p>

<p>Una lista es recursiva. Está formada por una cabecera (<em>head</em>) y una cola
(<em>tail</em>). La cabecera es unicamente el primer elemento. La cola, es una lista
con el resto de elementos. De esta forma, la lista <code>[1, 2, 3]</code>, en realidad es
<code>[1 | [2 | [3 | [] ] ] ]</code> (al final se concatena una lista vacía).</p>

<p>Como las listas son recursivas, muchas funciones que manipulan listas lo son.
Elixir hace super sencilla la recursividad. Mezclando recursividad y pattern
matching, se pueden hacer virgerías. Super fácil implementar el cifrado César
(ver <a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-04-round-02.exs">exercise-04-round-02.exs</a>).</p>

<p><strong>Diccionarios</strong></p>

<p>Existen varios tipos de diccionarios: <code>Maps</code>, <code>HashDicts</code>, <code>Keywords</code>, <code>Sets</code> y
<code>Structs</code>.</p>

<p>Para acceder a una clave del diccionario: <code>dict[:key]</code>, las claves son Atoms.</p>

<p><code>Enum.into</code> convierte entre tipos enumerados, por ejemplo, entre tipos de
diccionarios.</p>

<p>```</p>

<h1>Distintas operaciones que podemos hacer sobre diccionarios</h1>

<p>dict = %{ key1: "Clave 1", key2: "Clave 2" }%
ticd = %{ key9: "Clave 9", key8: "Clave 8" }%</p>

<h1>eliminar claves de un diccionario</h1>

<p>Dict.drop(dict, [:key2])</p>

<h1>añadir claves</h1>

<p>Dict.put(dict, :key3, "Clave 3")</p>

<h1>unir diccionarios</h1>

<p>Dict.merge(dict, tcid)</p>

<h1>obtener valores, similar a dict[:key1]</h1>

<p>Dict.get(dict, :key1)</p>

<h1>obtener todos los valores</h1>

<p>Dict.values(dict)</p>

<h1>el pattern matching en diccionarios es muy útil</h1>

<p>person = %{ name: "Dave", height: 1.88 }</p>

<h1>establecer a_name = "Dave"</h1>

<p>%{ name: a_name } = person</p>

<h1>pattern matching que no falla</h1>

<p>%{ name: _, height: _ } = person</p>

<h1>pattern matching que no falla</h1>

<p>%{ name: "Dave" } = person</p>

<h1>falla</h1>

<p>%{ name: _, weight: _ } = person
** (Match error) no ...</p>

<h1>pattern matching no puede enlazar claves de diccionarios</h1>

<p>%{ 2 => state } = %{ 1 => ok:, 2 => error: }
=> state = :error</p>

<p>%{ state => ok: } = %{...}
=> Error ...</p>

<h1>para actualizar un mapa, se usa la siguiente estructura, muy parecida a <code>List</code></h1>

<h1>Puede actualizar pero no añadir</h1>

<p>new_map = %{ old_map | key => value, ... }
```</p>

<p><strong>Mapas tipados (typed maps)</strong></p>

<p>Son como un mapa que tiene un conjunto de campos fijos y valores por defecto
para ellos. Se puede utilizar <em>pattern matching</em> por tipo y por contenido.</p>

<p>Estos mapas son los llamados <code>Struct</code>. Los <code>Struct</code>s son mapas limitados: las
claves deben ser <em>Atoms</em>. Se crean con <code>defstruct</code>, y el nombre del módulo pasa
a ser el nombre del struct:</p>

<p>```
defmodule Subscribrer do
  defstruct name: "", paid: false, over_18: true
end</p>

<p>s1 = %Subscribrer{}
=> %Subscribrer{ name: "", paid: false, over_18: true }</p>

<p>s2 = %Subscribrer{ name: "Dave" }</p>

<h1>a las claves se accede mediante un punto <struct>.<key></h1>

<p>s2.name
=> "Dave"</p>

<p>%Subscribrer{ name: name } = s2
name
=> "Dave"</p>

<h1>así se actualizan los datos</h1>

<p>s3 = %Subscribrer{ s2 | name: "Marie" }</p>

<h1>la idea de que el nombre del módulo sea el nombre del Struct</h1>

<h1>es que se puedan añadir métodos al módulo que modifiquen la</h1>

<h1>estructura del Struct (esto me suena mucho a las clases de la</h1>

<h1>Programación Orientada a Objetos).</h1>

<p>defmodule Attendee do
  defstruct name: "", paid: false, over_18: true</p>

<p>  def may_attend_after_party(attendee = %Attendee{}) do</p>

<pre><code>attendee.paid &amp;&amp; attendee.over_18
</code></pre>

<p>  end</p>

<p>  ...
end
```</p>

<p>El autor reconoce que los <code>Struct</code>s se parecen mucho a los objectos de la
Programación Orientada a Objetos. Y también nos advierte que tengamos cuidado,
que no caigamos en la tentación, que nos mantengamos puros, que no mezclemos
paradigmas.</p>

<p><strong>Estructuras de diccionario anidadas</strong></p>

<p>Las <code>Structs</code> se pueden anidar. Se consigue haciendo que el valor de una de las
claves sea otro <code>Struct</code>.</p>

<p>Imagina que tenemos dos <code>Struct</code>s anidadas así:</p>

<p>```
report = %BugReport{
  owner: %Customer{</p>

<pre><code>name: "Dave",
company: "Pragmatic"
</code></pre>

<p>  },
  details: "broken"
}</p>

<h1>se puede acceder a company</h1>

<p>company = report.owner.company</p>

<h1>podemos modificarla con la macro put_in</h1>

<p>put_in(report.owner.company, "PragProg")
```</p>

<p>Con <code>update_in</code> podemos modificar el valor actual (accesible a través de un
parámetro de la macro). También existen las macros <code>get_in</code> y
<code>get_and_update_in</code></p>

<p>Esas macros también funcionan con mapas y keyword lists. Si en lugar de una
clave o lista de claves, se pasa una función, las macros se convierten en
funciones dinámicas y llamarán a esta función con tres parámetros.</p>

<p><strong>Sets</strong></p>

<p>Actualmente solo hay una implementación de ellos, <code>HashSet</code>.</p>

<p>```
one_to_five = Enum.into 1..5, HashSet.new</p>

<h1>comprueba si un valor existe o no</h1>

<p>Set.member(one_to_five, 5)
=> true</p>

<h1>concatena varios Set's</h1>

<p>three_to_eight = Enum.into 3..8, HashSet.new
Set.union(one_to_five, three_to_eight)
=> #Hashset[ 1, 2, 3, 4, 5, 6, 7, 8]</p>

<h1>qué elementos estań en el primero que no están en el segundo</h1>

<p>Set.difference(one_to_five, three_to_eight)
=> #Hashset[ 1, 2 ]
Set.difference(three_to_eight, one_to_five)
=> #Hashset[ 6, 7, 8 ]</p>

<h1>qué valores están en ambos</h1>

<p>Set.intersection(one_to_five, three_to_eight)
=> #Hashset[ 3, 4, 5 ]
```</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p>Algunos métodos intersantes del módulo <code>List</code>: operadores para concatenar <code>++</code>,
diferencia <code>--</code>, pertenencia <code>in</code> y métodos tales como <code>flatten</code>, <code>foldl</code>,
<code>foldr</code>, <code>zip</code>, <code>unzip</code>, <code>keyfind</code>, <code>keydelete</code>, <code>keyreplace</code>,...</p>

<p>Además de los métodos que hemos visto de <code>Dict</code>, podemos encontrar: <code>values</code>,
<code>drop</code>, <code>put</code>, <code>merge</code>, <code>get</code>, <code>HashDict.new</code>,...</p>

<p>El módulo <code>Keyword</code> tiene métodos para manipular listas de tuplas, o keyword
lists: <code>delete</code>, <code>drop</code>, <code>equal?</code>, <code>get_and_update</code>, <code>merge</code>, <code>pop</code>, <code>put</code>,...</p>

<p>Existen unas macros, que sirven para manipular los valores almacenados en
diccionarios: <code>get_in</code>, <code>update_in</code>, <code>get_and_update_in</code>,... Si a estas macros
se les pasa una función en lugar de unas claves, se usará esa función para
obtener los valores del diccionario. Debería ser sencillo saber usarlas, pero
todavía no llego a entender exactamente cómo funciona y para qué se podría
utilizar.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-01-round-02.exs">exercise-01-round-02.exs</a>: antes se ha implementado (en el libro) la
funcción <code>sum</code>, que suma los elementos de una lista. Se ha utilizado un
acumulador. Implementar lo mismo sin el acumulador</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-02-round-02.exs">exercise-02-round-02.exs</a>: escribir una función <code>mapsum</code> que acepte una
lista y una función, de forma que aplique la función a cada elemento y sume
los resultados</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-03-round-02.exs">exercise-03-round-02.exs</a>: escribir una función <code>max(list)</code> que devuelva el
máximo valor de la lista</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-04-round-02.exs">exercise-04-round-02.exs</a>: implementar el cifrado César, <code>caesar(list, n)</code>,
donde <code>list</code> es una lista de carácteres (es decir, una cadena con comillas
simples <code>'cadena'</code>) y que sea circular, cuando sobrepase <code>z</code>, que vuelva a la
<code>a</code>.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-05-round-02.exs">exercise-05-round-02.exs</a>: escribir una función <code>span(from, to)</code> que
devuelva una lista de números desde <code>from</code> hasta <code>to</code>.</li>
</ul>


<h2>Enseñar lo aprendido</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: primer asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/02/09/elixir-primer-asalto/"/>
    <updated>2016-02-09T21:57:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2016/02/09/elixir-primer-asalto</id>
    <content type="html"><![CDATA[<p>Éste es el primer asalto de mi aprendizaje de <a href="http://elixir-lang.org/">Elixir</a>. En él, no espero
resolver problemas súper complicados, es un primer contacto con el lenguaje. Me
conformaré con ser capaz de escribir un programa algo más complicado que un
simple hola mundo. En este primer asalto, lucho con tipos de datos, funciones
(anónimas y con nombre), pattern matching, claúsulas de guarda y módulos.</p>

<p>En estos asaltos, intentaré seguir los siguientes pasos:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2016/touch-gloves-derived-small.png"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/awy1vc">Touch Gloves</a> de <a href="https://www.flickr.com/photos/kaiban/">Jack Zallum</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/legalcode">CC BY-NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Instalación</strong></p>

<p>Instalar la máquina virtual de Erlang y el entorno de Elixir es extremadamente
sencillo. Aquí están los comandos para hacerlo en una máquina con Ubuntu como
sistema operativo. En la <a href="http://elixir-lang.org/install.html">documentación de Elixir</a> hay instrucciones para otros
sistemas operativos.</p>

<p><code>
$ wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb
$ sudo dpkg -i erlang-solutions_1.0_all.deb
$ sudo apt-get update
$ sudo apt-get install esl-erlang
$ sudo apt-get install elixir
</code></p>

<p><strong>Editores</strong></p>

<p>La comunidad de Elixir ha creado plugins para los editores de código más
famosos, entre ellos <a href="http://www.vim.org/">Vim</a>, que utilizo para mis <a href="http://rchavarria.github.io/pet-projects/">proyectos personales</a>.</p>

<p>Instalar el plugin <a href="https://github.com/elixir-lang/vim-elixir">vim-elixir</a> en Vim es facilísimo si instalas plugins con
pathogen:</p>

<p><code>
$ git clone https://github.com/elixir-lang/vim-elixir.git ~/.vim/bundle/vim-elixir
</code></p>

<p><strong>Herramientas</strong></p>

<p><code>iex</code> es una herramienta de tipo REPL (read, evaluate, print, loop), que nos
permite ejecutar código Elixir de forma rápida. El comando <code>iex &lt;fichero.exs&gt;</code>
compila un script de Elixir y lo carga en la herramienta. Si ya estamos dentro
de ella, el comando para compilar el código Elixir de un fichero sería <code>c
"&lt;fichero exs&gt;"</code>.</p>

<p><strong>Pattern matching</strong></p>

<p>El operador <code>=</code> es muy diferente a lo que esperamos de él los que estamos
acostumbrados a la programación orientada a objetos. Tiene una apariencia
similar, pero no se comporta de la misma forma. Con este operador, Elixir trata
de hacer coincidir los valores de la izquierda con los valores de la derecha.</p>

<p><code>
a = 2
[a, b, a] = [1, 2, 1]
[^a, b] = [2, 3]
[a, b, c] = [1, 2, [3, 4, 5]]   # c vale [3, 4, 5]
</code></p>

<p><strong>Inmutabilidad</strong></p>

<p>¿Es eficiente devolver una copia de los datos? En los lenguajes funcionales, no
se modifican los datos, se devuelve una copia de ellos transformados. Parece
ineficiente, pero es todo lo contrario. Al no modificarse los originales, éstos
pueden compartirse por muchas variables, y pueden estar tranquilos, ya que no
se va a modificar. En los lenguajes no funcionales, se devuelve una copia (no
eficiente), en los funcionales, en realidad no se devuelve una copia, se
comparte todo lo que se puede. Por lo que es más eficiente.</p>

<p>¿Qué pasa con el recolector de basura? ¿Consume muchos recursos para deshacerse
de todos esos datos transformados que ya no se utilizan? No consume mucho, en
Elixir (en Erlang en realidad), hay muchos procesos, cada uno con un <em>heap</em>
distinto, por lo que el heap es más pequeño que en otros lenguajes, y el
recolector de basura se ejecuta bastante más rápido.</p>

<p><strong>Tipos de datos</strong></p>

<p>Y por fin algo de código:</p>

<p>```</p>

<h1>enteros</h1>

<p>this_is_an_int = 1234
this_is_an_int = 0xcafe    # admite hexadecimal
this_is_an_int = 0o765     # octal
this_is_an_int = 0b01010   # binario
this_is_an_int = 1_000_000</p>

<h1>en coma flotante</h1>

<p>this_is_a_float = 1.0
this_is_a_float = 0.245
this_is_a_float = .342        # error
this_is_a_float = 314159.0e-5</p>

<h1>rangos</h1>

<p>this_is_a_range = 1..100</p>

<h1>expresiones regulares</h1>

<p>this_is_a_regexp = ~r{regexp}options</p>

<h1>tuplas</h1>

<p>this_is_a_tuple = { :ok, 42, "next" }</p>

<h1>listas: se parecen a los arrays de otros lenguajes, pero no</h1>

<h1>lo son. Son estructuras enlazadas. Una lista o está vacía, o</h1>

<h1>contiene un head y un tail, donde tail es otra lista</h1>

<p>this_is_a_list = [ 1, 2, 3 ]</p>

<h1>mapas: lista de parejas clave/valor</h1>

<p>this_is_a_map = %{ key => value, key => value }</p>

<h1>si las claves son Atoms, se puede escribir</h1>

<p>this_is_a_map = %{ red: 0xFF0000, green: 0x00FF00, blue: 0x0000FF }</p>

<h1>binarios: para acceder a datos como una secuencia de bits y bytes (para muy bajo nivel)</h1>

<p>```</p>

<p>Hay otros tipos de datos, como los PIDs (referencias a procesos locales o
remotos) o los puertos (referencias a recursos sobre los cuales leeremos o
escribiremos).</p>

<p>Un tipo de datos muy interesante (y que yo personalmente no conocía) son los
<em>Atoms</em>: constantes representando el nombre de algo. Su nombre es su valor. Dos
Atoms son igules si tienen el mismo nombre, vengan de donde vengan (incluso de
máquinas diferentes)</p>

<p>```</p>

<h1>atoms</h1>

<p>this_is_an_atom = :fred
this_is_an_atom = :is_binary?
this_is_an_atom = :var@32
this_is_an_atom = :&lt;>
this_is_an_atom = :"lo john silver"
```</p>

<p>Hay dos estructuras muy similares, la lista de palabras clave: <code>[red: 0xFF000,
green: 0x00FF00]</code>, que se transforma en <code>[{:red, 0xFF0000}, {:green,
0x00FF00}]</code> y un mapa <code>%{red: 0xFF000, green: 0x00FF00}</code>. Se recomienda usar la
lista de palabras clave para pasar parámetros y usar los mapas cuando se
necesite un array asociativo.</p>

<p>No hemos dicho nada de las cadenas. Pertenecen al tipo <em>Binario</em>. Existe
interpolación de cadenas, con <code>#{...}</code> se evalúa el código de dentro y se
formatea la cadena con el valor obtenido.</p>

<p><strong>Funciones anónimas</strong></p>

<p><code>
sum = fn (a, b) -&gt; a + b end
sum.(2, 3)   # devuelve 5
</code></p>

<p>Las funciones pueden devolver otras funciones. Las funciones recuerdan su
entorno original. Forman lo que se conoce como <em>closures</em>. Me recuerda mucho a
las funciones de JavaScript en este aspecto.</p>

<p>Existe una forma de crear funciones anónimas de una forma muy concisa, con el
operador <code>&amp;...</code></p>

<p>```
sum = fn (a, b) -> a + b end
sum2 = &amp;(&amp;1 + &amp;2)   # idéntica a la función anterior</p>

<h1>devuelve lista con dos elementos: doble del primer parámetro, y cuadrado del mismo</h1>

<p>returns_a_list = &amp;[2 * &amp;1, &amp;1 * &amp;1]</p>

<h1>esta notación viene muy bien para pasar funciones por parámetro</h1>

<p>Enum.map [1, 2, 3] &amp;(&amp;1 * &amp;1)   # devuelve [1, 4, 9]
```</p>

<p>Es normal ver la definición de una función como <code>&amp;map/2</code>, donde <code>map</code> es el
nombre de la función y <code>2</code> es el <em>arity</em>, el número de parámetros de la misma.</p>

<p><strong>Módulos, funciones con nombre y funciones privadas</strong></p>

<p>```
defmodule Times do
  ## define una función en una única línea
  def double(n), do: n * 2</p>

<p>  ## define una función en varias líneas
  def triple(n) do</p>

<pre><code>n * 3
</code></pre>

<p>  end</p>

<p>  ## define una función privada
  defp quadruple(n) do: n * 4
end
```</p>

<p>Las funciones con nombre pueden tener varios cuerpos. Eso ayuda a utilizar
<em>pattern matching</em> a la hora de implementar una solución.</p>

<p>```
defmodule Factorial do
  # el factorial de 0, siempre es 1, esta definición es quien para la recursividad
  def of(0), do: 1</p>

<p>  # el factorial de cualquier otro número, es recursivo
  def of(n), do: n * factorial(n - 1)
end</p>

<p>Factor.of(5)
  # => 120
```</p>

<p>También, las definiciones pueden tener claúsulas de guarda, mediante <code>when
&lt;condition&gt;</code>, lo que ayuda a tener un pattern matching más específico.</p>

<p>```
defmodule Guard do
  def what_is(x) when is_number(x) do</p>

<pre><code>IO.puts "#{x} is a number"
</code></pre>

<p>  end
  def what_is(x) when is_list(x) do</p>

<pre><code>IO.puts "#{x} is a list"
</code></pre>

<p>  end
  def what_is(x) when is_atom(x) do</p>

<pre><code>IO.puts "#{x} is an atom"
</code></pre>

<p>  end
end
```</p>

<p><strong>El operador tubería (pipe)</strong></p>

<p>El operador <code>|&gt;</code> toma el resultado de una función y lo pasa como primer
parámetro de la segunda función. <code>String.reverse "foobar" |&gt; String.capitalize</code></p>

<p>```
filing = DB.find_customers</p>

<pre><code>       |&gt; Orders.for_customers
       |&gt; sales_tax(2016)
       |&gt; prepare_filing
</code></pre>

<p>list
  |> sales_taxes(2016)
  |> prepare_filing</p>

<h1>es lo mismo que llamar</h1>

<p>prepare_filing( sales_taxes(list, 2016) )
```</p>

<p><strong>Parámetros por defecto</strong></p>

<p>```
defmodule DefaultParams do
  def func(p1, p2 \ 2) do</p>

<pre><code>IO.inspect [p1, p2]
</code></pre>

<p>  end
end</p>

<p>Example.func("a", "b")
  # => ["a", "b"]</p>

<p>Example.func("a")
  # => ["a", 2]
```</p>

<p><strong>Librerías</strong></p>

<p>Se pueden buscar módulos y librerías ya implementados para realizar ciertas
tareas que necesitemos, para ello, está la documentación de <a href="http://elixir-lang.org/docs.html">librerías de Elixir</a>.
Si no encontramos ahí lo que buscamos, lo podemos buscar en <a href="http://erlang.org/doc/">librerías de Erlang</a>.</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p><strong>¿Qué hace <code>^</code> en el pattern matching?</strong></p>

<p>El operador <code>^</code> obliga a que el valor actual de una variable coincida con el
valor en la expresión de <em>pattern matching</em>. En caso de no coincidir, se
producirá un error.</p>

<p><code>
a = 2
[^a, b] = [2, 3]  ## no hay error, `a` valía `2` y aquí coinciden
[^a, b] = [1, 3]  ## error
</code></p>

<p><strong>Tuplas, <em>keyword list</em> y mapas</strong></p>

<p>Las <em>keyword list</em> son una lista usadas muy a menudo, tienen la forma:</p>

<p><code>
keyword_list = [ red: 0xFF0000, green: 0x00FF00, blue: 0x0000FF ]
</code></p>

<p>Pero no es más que una forma simplificada de escribir una lista de tuplas,
donde el primer valor de cada una de ellas es un Atom:</p>

<p><code>
tuple_list = [ {:red, 0xFF000}, {:green, 0x00FF00}, {:blue, 0x0000FF} ]
</code></p>

<p>Una estructura muy parecida a estas son los mapas, que no son más que un
conjunto de parejas clave-valor:</p>

<p><code>
a_map = %{ :red =&gt; 0xFF000, :green =&gt; 0x00FF00, :blue =&gt; 0x0000FF }
</code></p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-01/round-01-exercise-01.exs">round-01-exercise-01.exs</a>: utilizar varios cuerpos de una función y
recursividad para implementar una función que calcule la suma de <code>1</code> hasta
<code>n</code></li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-01/round-01-exercise-02.exs">round-01-exercise-02.exs</a>: implementar la función <code>gcd(x, y)</code> que calcule el
máximo común divisor. Matemáticamente: <code>gcd(x, y)</code> es <code>x</code> si <code>y</code> es cero y es
<code>gcd(y, rem(x, y))</code> en caso contrario</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-01/round-01-exercise-03.exs">round-01-exercise-03.exs</a>: crear el juego <em>Estoy pensando en un número entre
el 1 y el 100</em>: rangos, div(a, b), claúsulas de guarda, pattern matching en
rangos: <code>a..b = 4..8</code>, funciones privadas</li>
</ul>


<h2>Enseñar lo aprendido</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
</feed>
