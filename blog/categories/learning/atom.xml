<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: learning | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/learning/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2016-09-18T17:27:24+02:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir: séptimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto/"/>
    <updated>2016-09-18T16:20:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto</id>
    <content type="html"><![CDATA[<p>El aprendizaje va avanzando, ya vamos por el séptimo asalto. Éste trata sobre
cómo <a href="http://elixir-lang.org/">Elixir</a> maneja múltiples procesos, por lo que trataremos algún tema de
concurrencia. También veremos algunas cosas básicas sobre cómo monitorizar los
procesos de los que consta nuestra aplicación.</p>

<p>Sin olvidar del método de aprendizaje con el que <a href="/blog/2016/01/17/aprendiendo-elixir/">comenzé</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/you-gotta-fight-for-your-right-to-eat.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/4rvPED">You gotta fight for your right to... eat</a> de <a href="https://www.flickr.com/photos/r2wk/">ldjpg</a>, <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">CC BY NC ND 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Trabajando con múltiples procesos</strong></p>

<p>Elixir usa el <a href="https://en.wikipedia.org/wiki/Actor_model">modelo de actores</a> para gestionar la concurrencia.</p>

<p>Elixir se apoya en Erlang para gestionar los procesos, que no son los procesos
del sistema operativo.</p>

<p>Para crear un proceso, se hace con la llamada <code>spawn</code>. <code>spawn</code> puede crear un
proceso y ejecutar en él código que tengas en un módulo cualquiera. El proceso
puede empezar en cualquier momento (asíncrono total) y se utilizan mensajes
entre procesos para sincronizarlos.</p>

<p>Los mensajes no tienen por qué ser <code>Strings</code>, pueden ser de cualquier tipo
(generalmente tuplas o atoms). Los mensajes se mandan con <code>send</code>, y debes usar
un <code>PID</code> (devuelto por <code>spawn</code>).</p>

<p>El receptor, espera mensajes con <code>receive</code>. <code>receive</code> funciona como <code>case</code>: se
pueden poner varios casos, y el primero que coincida, se ejecuta.</p>

<p><code>receive</code> maneja sólo un mensaje. Si queremos recibir varios, debemos volver a
llamar al método que contiene el <code>receive</code>, de forma recursiva (y Elixir es muy
bueno con la recursividad). <code>receive</code> también acepta un parámetro, <code>after</code>,
para definir un timeout.</p>

<p>El autor dice que los procesos en Elixir son como los objetos en lenguajes
orientados a objectos, pero con mejor sentido del humor. El hecho es que son
muy livianos, y pueden mantener estado, así que podemos pensar en ellos como en
objetos de la programación orientada a objetos.</p>

<p><strong>Enlazar procesos</strong></p>

<p>Normalmente, un proceso no sabe cuando muere un proceso hijo. Debemos hacer
algo manualmente para que se notifique. Podemos crear procesos <em>enlazados</em>
(linked) con <code>spawn_link</code>. Por defecto, si un proceso hijo muere, mata al
proceso padre. Para controlar esto y poder escuchar el mensaje que lanza el
proceso hijo al morir, debemos <em>atrapar la salida</em> mediante
<code>Process.flag(:trap_exit, true)</code> justo antes de hacer <code>spawn_link</code>.</p>

<p>Dos procesos enlazados pueden comunicarse bidireccionalmente.</p>

<p>Elixir usa el framework OTP para construir árboles de procesos. OTP lleva mucho
tiempo en funcionamiento, y debemos confiar en que lo hace mucho mejor que
nosotros, por lo que lo usaremos prácticamente siempre. OTP incluye el concepto
de <em>Supervisor de procesos</em>. Más adelante estudiaremos temas relacionados con
OTP.</p>

<p><strong>Monitorizando procesos</strong></p>

<p>Si <code>spawn_link</code> permite comunicación bidireccional, <code>spawn_monitor</code> solo la
permite unidireccional. El proceso hijo puede notificar al padre, pero no al
revés.</p>

<p>```</p>

<h1>monitor devuelve el pid del proceso hijo y una referencia de la monitorización</h1>

<p>res = spawn_monitor(<module>, <function>, <params>)
IO.inspect res</p>

<h1>=> { #PID{3.3.3.3}, #Reference{1.2.3.4} }</h1>

<p>```</p>

<p>También se puede monitorizar un proceso existente con <code>Process.monitor</code>.</p>

<p>¿Cuándo utilizar cada uno? Depende de la utilidad. Si la muerte de un hijo
debería matar al padre, usa procesos enlazados. Si la muerte/fallo de un hijo
solamente debería notificar al padre, usa monitorización.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-01-round-07.exs">exercise-01-round-07.exs</a>: ejecutar el programa que pasa mensajes en cadena
de un proceso a otro hasta llegar al millón de procesos.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-02-round-07.exs">exercise-02-round-07.exs</a>: escribir un código que cree dos procesos, y que a
cada uno le mande un token (p.e.: "pepito" y "fulanito"), y que los procesos
lo devuelvan. En teoría, ¿es determinista el orden en el que se reciben las
respuestas? ¿Y en la práctica? En caso de que no, ¿cómo podría hacerse que
fuera determinista?.</li>
</ul>


<p><strong>Resultados</strong></p>

<p>Parece que sí es determinista (al menos con dos procesos). Depende del orden en
el que se creen los procesos, incluso si invertimos el orden en el que se
envían los tokens, el primer proceso creado es el primero en responder.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-03-round-07.exs">exercise-03-round-07.exs</a>: usa <code>spawn_link</code> para crear un proceso, el cual
envía un mensaje al padre y finaliza inmediatamente. Mientras, en el padre,
después de crear el proceso, espera 500ms y luego comienza a recibir todos los
mensajes que están esperando. Tracea todo lo que recibas. ¿Importa que no
estuvieras recibiendo notificaciones cuando el hijo terminó?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No recibe ningún mensaje, el hijo termina, terminando al padre durante la
espera.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-04-round-07.exs">exercise-04-round-07.exs</a>: repite el ejercicio anterior, pero en lugar de
terminar con <code>exit</code>, que el hijo lance una excepción. ¿qué diferencia notas?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No hay mucha difrencia. El padre sigue terminando, sin escuchar ningún mensaje.
Al menos, la excepción aparece por consola, mostrándose un error diciendo que
el proceso hijo (con su PID) ha lanzado una excepción. En el ejercicio
anterior, solamente aparecía que el proceso padre terminaba, nada más.</p>

<p>Usando <code>Process.flag(:trap_exit, true)</code>, el proceso padre recibe mensajes:</p>

<p>```
$ elixir -r exercise-03-round-07.exs -e "Exercise3.run"
Parent's PID #PID&lt;0.48.0>
PID's child #PID&lt;0.53.0>
Received: "Hello!"
Received: {:EXIT, #PID&lt;0.53.0>, :boom}</p>

<p>$ elixir -r exercise-04-round-07.exs -e "Exercise4.run"
Parent's PID #PID&lt;0.48.0>
Child's PID #PID&lt;0.53.0></p>

<p>22:46:14.313 [error] Process #PID&lt;0.53.0> raised an exception
** (RuntimeError) Child finished</p>

<pre><code>exercise-04-round-07.exs:19: Exercise4.child/1
</code></pre>

<p>Received: "Hello!"
Received: {:EXIT, #PID&lt;0.53.0>, %{RuntimeError{message: "Child finished"},
[{Exercise4, :child, 1, [file: 'exercise-04-round-07.exs', line: 19]}]}}
```</p>

<p>Las diferencias están en lo recibido en el mensaje de terminación del hijo. En
caso de <code>exit</code> se recibe <code>:EXIT</code>, un PID, y la causa de la salida. En el caso
de la excepción: <code>:EXIT</code>, un PID y la excepción, parece, porque tiene pinta de
pila de llamadas, con su módulo, función, parámetros,...</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-05-round-07.exs">exercise-05-round-07.exs</a>: repetir el ejercicio pero con <code>spawn_monitor</code>.</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No creo que lo esté haciendo bien. Se supone que monitorizando la comunicación
no es bidireccional, pero el padre recibe el mensaje que envía el hijo, así
como el mensaje que se envía al terminar o lanzar la excepción. La única
diferencia visible es que en lugar de recibir solamente un PID, se recibe un
PID y la referencia de monitorización.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-06-round-07.exs">exercise-06-round-07.exs</a>: escribir una función implementando <em>pararell
map</em>, que es como una función <code>map</code> pero cada elemento es procesado por un
proceso distinto. Preguntas: ¿por qué es necesario guardar en la variable <code>me</code>
el PID del proceso padre? Se debe utilizar <code>^pid</code> para recibir los resultados
en orden, pero... ¿qué pasa si se utiliza <code>_pid</code>? ¿cómo hacer para que falle:
esperas, aumentar número elementos, que la función que procesa cada elemento
sea más complicada,...?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>Aumentando el número de elementos afecta al orden en el que se reciben los
mensajes. También he conseguido recibir mensajes en orden distinto con el
siguiente código:</p>

<p><code>
Parallel.pmap 1..10, fn (i) -&gt;
  # la espera es más corta según el elemento `i` se va a haciendo mayor
  wait_up_to = round(10 / i)
  :timer.sleep(wait_up_to)
  i
end
  #=&gt; [ 7, 8, 9, 10, 5, 6, 3, 4, 2, 1 ]
</code></p>

<p>Volviendo a poner <code>^pid</code> el orden vuelve a ser correcto.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-07-round-07.exs">exercise-07-round-07.exs</a>: toma como referencia un planificador (servidor de
Fibonacci) de un ejercicio del libro y crea otro similar. Esta vez, se deben
contar las apariciones de la palabra <code>cat</code> en cada fichero que se encuentre en
un directorio dado. Cada fichero será procesado por un proceso distinto.
¿Podrías escribir el planificador de una forma más genérica?</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: sexto asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/09/14/elixir-sexto-asalto/"/>
    <updated>2016-09-14T21:32:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/09/14/elixir-sexto-asalto</id>
    <content type="html"><![CDATA[<p>Sexto asalto. En esta ocasión no veremos nada del lenguaje, si no del
ecosistema de <a href="http://elixir-lang.org/">Elixir</a>. Elixir viene acompañado de unas magníficas herramientas
que complementan en lenguaje de programación en sí: <code>mix</code>, la herramienta de
construcción de aplicaciones y herramientas de testing como <code>ExUnit</code> y
<code>DocTests</code>. Además de estas herramientas, exploraremos también los sitios web
donde los desarrolladores alojan la mayoría de las librerías y proyectos Elixir
disponibles.</p>

<p>Sigo con la metodología de aprendizaje explicada en el <a href="/blog/2016/01/17/aprendiendo-elixir/">primer post sobre Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/more-gladiators.png"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/6xvcMz">More gladiators</a> de <a href="https://www.flickr.com/photos/archeon/">Hans Splinter</a>, <a href="https://creativecommons.org/licenses/by-nd/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p>Elixir viene con la herramienta <code>mix</code>, la herramienta oficial de construcción
de proyectos (creación, testeo, construcción, gestión de dependencias,...). En
este asalto crearemos una aplicación que nos permitirá listar los últimos <code>n</code>
<em>issues</em> de cualquier proyecto de <a href="https://github.com">GitHub</a>.</p>

<p><code>mix help</code> lista los comandos disponibles. Los más interesantes podrían ser:
<code>mix run</code> para ejecutar el proyecto, <code>mix test</code> para ejecutar los tests o <code>mix
new</code> para crear uno nuevo.</p>

<p>Crearemos un nuevo proyecto, llamado <code>rct_issues</code>:</p>

<p><code>
$ mix new rct_issues
</code></p>

<p>Listando los ficheros y directorios que ha creado el comando, encontramos los
siguientes:</p>

<ul>
<li><code>/README.md</code>: aquí podemos poner la descripción del proyecto.</li>
<li><code>/config/</code>: donde vivirá la configuración del proyecto</li>
<li><code>/lib/</code>: aquí irá el código fuente de nuestro proyecto</li>
<li><code>/test/</code>: aquí irá el código de tests</li>
<li><code>mix.exs</code>: opciones de configuración del proyecto en sí</li>
</ul>


<p><strong>Transformación: parsear la línea de comandos</strong></p>

<p>La aplicación de ejemplo tomará los parámetros de la línea de comandos. Las
aplicaciones Elixir consisten en una serie de transformaciones, y la primera de
ellas será la de parsear la línea de comandos.</p>

<p>En Elixir existen una serie de convenciones:</p>

<ul>
<li>El código que gestiona la línea de comandos va en un módulo llamado
<code>&lt;proyecto&gt;.CLI</code>, así que nuestro código iría en un módulo llamado
<code>RctIssues.CLI</code></li>
<li>Cada módulo va en un fichero distinto</li>
<li>Cada módulo va dentro del espacio de nombres del proyecto, por lo que todos
los módulos colgarán de <code>RctIssues</code></li>
<li>Los <em>espacios de nombres</em> corresponden con directorios en el árbol del
proyecto. Así, el módulo <code>RctIssues.CLI</code> se escribiría en el directorio
<code>/lib/rct_issues/cli.ex</code>. Ver fichero de código fuente <a href="https://github.com/rchavarria/learning-elixir/blob/master/projects/rct_issues/lib/rct_issues/cli.ex">cli.ex</a></li>
</ul>


<p><strong>Los primeros tests</strong></p>

<p>Elixir viene con un pequeño framework de testing llamado <code>ExUnit</code>.</p>

<p>En el fichero <code>/test/cli_test.exs</code> escribiremos los tests para el módulo que
acabamos de escribir (echar un vistazo al fichero <a href="https://github.com/rchavarria/learning-elixir/blob/master/projects/rct_issues/test/cli_test.exs">cli_test.exs</a>)</p>

<p><strong>Transformación: obtener datos de GitHub</strong></p>

<p>La siguiente transformación sería obtener datos de GitHub. Para ello
necesitaremos alguna librería externa. Hay varios lugares donde buscar:</p>

<ol>
<li>Librerías propias de Eixir, en <a href="http://elixir-lang.org/docs">http://elixir-lang.org/docs</a></li>
<li>Librerías propias de Erlang (también distribuidas con Elixir), en
<a href="http://erlang.org/docs">http://erlang.org/docs</a></li>
<li>Si todo esto falla, podemos buscar en el repositorio de <a href="http://hex.pm">Hex</a>,
el gestor de dependencias de Elixir</li>
<li>Si aún así, todo falla, siempre nos quedará Google y GitHub</li>
</ol>


<p>El autor recomienda usar <code>HTTPoison</code> como librería. Esta librería se encuentra
en <code>Hex</code>, con lo que es muy fácil incluirla en nuestro proyecto. Simplemente
hay que modificar el método <code>deps</code> dentro del fichero <code>/mix.exs</code>, indicando el
nombre y la versión de la librería que queremos usar:</p>

<p>```
defp deps do
  [</p>

<pre><code>{ :httpoison, "~&gt; 0.4" }
</code></pre>

<p>  }
end
```</p>

<p>Con el comando <code>mix deps</code> podremos saber el estado de las dependencias del
proyecto. Con <code>mix deps.get</code> podremos descargar las dependencias que no estén
instaladas localmente. En caso de estar instaladas, lo estarán en el directorio
<code>/deps</code>, como proyectos Elixir, con lo que podremos navegar a través de ellas.</p>

<p>Ahora ya podemos usarla. Lo haremos en un nuevo módulo, escrito en
<a href="https://github.com/rchavarria/learning-elixir/blob/master/projects/rct_issues/lib/rct_issues/github_issues.ex"><code>/lib/rct_issues/github_issues.ex</code></a>. También modificaremos el método
<code>applications</code> de <code>mix.exs</code> para indicar que la dependencia <code>HTTPoison</code> va a
ser ejecutada como una <em>subaplicación</em> dentro de nuestro proyecto (hablará más
adelante sobre ello en el libro).</p>

<p><strong>Transformación: parsear la respuesta JSON</strong></p>

<p>Para la siguiente transformación incluiremos una dependencia que proviene del
mundo Erlang. <code>mix</code> es capaz de incluir dependencias de muy diversas fuentes,
Erlan entre ellas. Se añade la librería <code>jsx</code>, como dependencia del proyecto.
Añadir la línea <code>{ :jsx, "~&gt; 2.0" }</code> al fichero <code>mix.exs</code> y ejecutar el comando
<code>mix deps.get</code> para instalarla localmente.</p>

<p>Modificaremos nuestro módulo que debe parsear la respuesta,
<code>lib/rct_issues/github_issues.ex</code>:</p>

<p>```
def handle_response(%{status_code: 200, body: body}) do
  { :ok, :jsx.decode(body) }
end</p>

<p>def handle_response(%{status_code:   _, body: body}) do
  { :error, :jsx.decode(body) }
end        <br/>
```</p>

<p><strong>Configuración de la aplicación</strong></p>

<p>Cuando creamos el proyecto con <code>mix</code>, éste crea un directorio de configuración,
<code>config/</code>, con el fichero <code>config.exs</code>, donde podremos escribir ciertas
configuraciones de nuestro proyecto.
Cada línea de configuración suele ser un registro de clave valor, por ejemplo, para nuestro proyecto añadiríamos:</p>

<p><code>
use Mix.Config
config :rct_issues, github_url: "https://api.github.com"
</code></p>

<p>Más adelante, podremos usar este valor configurado gracias al módulo
<code>Application</code>, así</p>

<p>```</p>

<h1>crea una variable de clase llamada github_url</h1>

<p>@github_url Application.get_env(:rct_issues, :github_url)
```</p>

<p><strong>Construir un ejecutable</strong></p>

<p>Para ello es necesario modificar el fichero <code>mix.exs</code>, para configurar la
herramienta <code>escript</code> y poder indicarle el módulo principal de la aplicación
que se va a construir, el cual debe de tener un método llamado <code>main</code>.</p>

<p>Para construir, simplemente ejecutar el comando:</p>

<p><code>
mix escript.build
</code></p>

<p>Y tendremos un ejecutable que podremos ejecutar como cualquier otra aplicación
de consola de Unix/Linux</p>

<p><strong>Ejecutando los comentarios</strong></p>

<p>¿Cómo? ¿Ejecutar los comentarios? No te preocupes, Elixir puede ejecutar
ciertos comentarios como si fueran tests. En realidad, ejecuta comentarios
escritos en cierta forma como si fueran sesiones de la herramienta <code>iex</code>. Esto
sí que es documentación ejecutable. Simplemente, espectacular.</p>

<p>Un comentario del tipo:</p>

<p><code>``
@doc """   
Given a list of rows, where each row contains a keyed list
of columns, return a list containing lists of the data in
each column. The</code>headers` parameter contains the
list of columns to extract</p>

<h2>Example</h2>

<pre><code>iex&gt; list = [Enum.into([{"a", "1"},{"b", "2"},{"c", "3"}], HashDict.new),
...&gt;         Enum.into([{"a", "4"},{"b", "5"},{"c", "6"}], HashDict.new)]

iex&gt; Issues.TableFormatter.split_into_columns(list, [ "a", "b", "c" ])
[ ["1", "4"], ["2", "5"], ["3", "6"] ]
</code></pre>

<p>"""      <br/>
def split_into_columns(rows, headers) do</p>

<h1>...</h1>

<p>```</p>

<p>Creamos un nuevo fichero de tests en <code>test/doc_test.exs</code>:</p>

<p><code>
defmodule DocTest do
  use ExUnit.Case
  doctest Issues.TableFormatter
end  
</code></p>

<p>Donde <code>Issues.TableFormatter</code> es el módulo donde hemos incluido el comentario
<em>ejecutable</em>. Podemos lanzar los comentarios testeables con los comandos <code>mix
test test/doc_test.exs</code> o simplemente <code>mix test</code>.</p>

<p>Para crear la documentación del proyecto, está la herramienta ExDoc, similar a
JavaDoc. Para ello hay que añadirlo como dependencia del proyecto en el fichero
<code>mix.exs</code>:</p>

<p>```
defp deps do
[</p>

<h1>...</h1>

<p>  { :ex_doc, github: "elixir-lang/ex_doc" },</p>

<h1>...</h1>

<p>]
end
```</p>

<p>Para generarlos, instalar la dependencia con <code>mix deps.get</code>, y generar la
documentación con <code>mix docs</code>.</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<ul>
<li>Necesitarás consular documentación sobre <code>OptionParser</code> para ser capaz de
hacer el primer ejercicio... No solamente eso, si no que he escrito unos
tests para aprender cómo funciona <a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-05/exercise-01-round-06.exs">tests de exercise-01-round-06</a></li>
<li>¿Como se hace para formatear una cadena siempre con la misma anchura?
(¿<code>String.pad</code> o algo así?). Parece que <a href="http://elixir-lang.org/docs/stable/elixir/String.html#ljust/3"><code>String.ljust/3</code></a> hace el trabajo.</li>
</ul>


<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-06/exercise-01-round-06.exs">exercise-01-round-06</a>: repetir (honestamente) el proceso de crear un nuevo
proyecto y crear un módulo que parsee opciones de la línea de comandos y un
test para ello</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-06/exercise-02-round-06.exs">exercise-02-round-06</a>: seguir implementando el ejemplo del libro lo más
honestamente que se pueda. Se implementarán las siguientes transformaciones:
obtener los datos de GitHub con HTTPoison, parsear el JSON resultante con JSX,
extraer sólo la información que nos interesa, ordenarla y recuperar sólo la
cantidad que quiere el usuario.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-06/exercise-03-round-06.exs">exercise-03-round-06</a>: implementar el resto de la funcionalidad de la
aplicación</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-06/exercise-04-round-06.exs">exercise-04-round-06</a>: escribir una aplicación que pida datos a un organismo
de EEUU sobre el tiempo, parsee los datos XML y los muestre de forma
agradable</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: quinto asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/09/11/elixir-quinto-asalto/"/>
    <updated>2016-09-11T11:43:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/09/11/elixir-quinto-asalto</id>
    <content type="html"><![CDATA[<p>Y ya vamos por el quinto asalto, el quinto de la serie sobre el aprendizaje del
lenguaje <a href="http://elixir-lang.org/">Elixir</a>. En este asalto aprenderemos estructuras de control de flujo,
esenciales en cualquier lenguaje de programación. No sé en otros lenguajes
funcionales, pero en Elixir, estas estructuras no son muy bien acogidas. De
todas formas, son parte del lenguaje, son sencillas y nos servirán para
establecer conexiones con lenguajes que ya conozcamos.</p>

<p>Para seguir con el aprendizaje, sigo con el método seguido en otros asaltos
partiendo del post <a href="/blog/2016/01/17/aprendiendo-elixir/">aprendiendo Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/fight-II-harc-II.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/6bQhPq">Fight II / Harc II</a> de <a href="https://www.flickr.com/photos/silangel/">silangel</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p>En Elixir no se usan mucho, se suelen escribir métodos pequeños, que junto con
claúsulas de guarda y <em>pattern matching</em> nos alejan bastante de lo que aquí
estudiaremos. Normalmente, se suelen favorecer esos mecanismos frente a
estructuras de control. Al principio cuesta acostumbrarse, pero luego uno se va
dando cuenta de que los cuerpos de los métodos quedan más pequeños y más
enfocados a hacer una sola cosa, aunque despista un poco que una misma función
tenga varios cuerpos.</p>

<p><strong><code>if</code> y <code>unless</code></strong></p>

<p>```</p>

<h1>Ambos toman dos parámetros, una condición y una <em>keyword list</em>, cuyas claves posibles son <code>do:</code> y <code>else:</code>.</h1>

<p>if 1 == 2, do: "truthy", else: "falsy"
unless 2 == 1, do: "do not execute", else: "execute this"</p>

<h1>igual que las funciones, se puede acortar un poco</h1>

<p>if 1 == 2 do
  "truthy"
else
  "falsy"
end
```</p>

<p><strong><code>cond</code></strong></p>

<p>En realidad es una macro, como muchas otras construciones del lenguaje, y
acepta una serie de condiciones. Se ejecutará el código de la primera condición
que se evalúe a <code>true</code>.</p>

<p>```</p>

<h1>Resolver la kata FizzBuzz</h1>

<p>cond do
  rem(current, 3) == 0 and rem(current, 5) == 0 -> "FizzBuzz"
  rem(current, 5) == 0 -> "Buzz"
  rem(current, 3) == 0 -> "Fizz"
  true -> current
end
```</p>

<p>En muchos casos, una mejor alternativa puede ser utilizar múltiples funciones,
pattern matching y claúsulas de guarda en lugar del bloque <code>cond</code>.</p>

<p><strong><code>case</code></strong></p>

<p><code>case</code> permite evaluar una serie de patrones, y ejecuta el código asociado a
dicho patrón. También se pueden usar claúsulas de guarda.</p>

<p>```</p>

<h1>para controlar errores al abrir un fichero</h1>

<p>case File.open("some file.txt") do
  { :ok, file } -> IO.puts "First line: #{IO.read(file, :line)}"
  { :error, reason } -> IO.puts "Failed to open file: #{reason}"
end</p>

<h1>con claúsulas de guarda</h1>

<p>dave = %{name: "Dave", age: 27}
case dave do
  person = %{age: age} when is_number(age) and age >= 21 -> IO.puts "You are allowed #{person.name}"
  _ -> IO.puts "You are not allowed"
end
```</p>

<p><strong>Excepciones</strong></p>

<p>Las excepciones en Elixir se usan para casos excepcionales. Por ejemplo, si hay
un fallo al leer un fichero de configuración, con un nombre fijo. Pero no si
hay un error al leer un fichero que el usuario ha introducido el nombre,
podemos controlar eso, y no sería un error excepcional.</p>

<p>```</p>

<h1>lanzando una RuntimeError</h1>

<p>raise "Giving up"</p>

<h1>o con algunos argumentos</h1>

<p>raise RuntimeError, message: "Stack overflow"</p>

<h1>por convención, se suele escribir <code>!</code> al final de una llamada que puede</h1>

<h1>devolver una excepción bien conocida, por ejemplo</h1>

<p>{ ok: file } = File.open!("foo.bar")
```</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li>[exercise-01-round-05.exs]: reescribe la kata FizzBuzz con <code>case</code></li>
<li>[exercise-02-round-05.exs]: muchas funciones tienen una segunda
implementación, que termina con <code>!</code>, la cual, si el resultado no coincide con
<code>{ :ok, data }</code> lanza una excepción. Implementa una función <code>ok!</code> que haga
exactamente esto</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: cuarto asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/08/10/elixir-cuarto-asalto/"/>
    <updated>2016-08-10T17:20:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/08/10/elixir-cuarto-asalto</id>
    <content type="html"><![CDATA[<p>Éste es el cuarto asalto en mi aventura aprendiendo <a href="http://elixir-lang.org/">Elixir</a>. En esta ocasión
trato con tipos de datos binarios, cadenas y <strong>sigils</strong>. No es mucho, pero las cadenas son
una parte esencial de cualquier lenguaje de programación. Y dominarlas
significa dominar una gran parte del lenguaje.</p>

<p>Por supuesto, sigo aprendiendo con el método descrito en el post sobre <a href="/blog/2016/01/17/aprendiendo-elixir/">aprender Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/fourth-fight.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/5yHK4Y">Muñeco de Gohan y Bu peleando</a> de <a href="https://www.flickr.com/photos/alotor/">Alonso Javier Torres</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p>Para definir una cadena se pueden usar comillas simples o comillas dobles.
También se puede usar comillas triples, para escribir lo que llaman <code>heredocs</code>,
y se suelen usar para escribir comentarios para documentar métodos y módulos.</p>

<p>En Elixir, existe lo que llaman <em>sigils</em> (que se podría traducir como código,
señal o símbolo mágico). Comienzan con <code>~</code>, seguido de una letra que determina
el tipo de símbolo:</p>

<ul>
<li><code>c</code> para una lista de carácteres</li>
<li><code>r</code> para expresión regular</li>
<li><code>w</code> para una lista de palabras separado por espacios</li>
<li>y hay más</li>
</ul>


<p>y cuyo valor se puede enmarcar en distintos delimitadores: <code>&lt;..&gt;</code>, <code>{...}</code>,
<code>[...]</code>,...</p>

<p>Un uso muy típico es para escribir expresiones regulares:</p>

<p><code>
~r{[0-9]+[A-Z]*}
</code></p>

<p>Los <em>sigils</em> pueden incluso personalizarse, y crear los tuyos propios.</p>

<p>Las cadenas definidas mediante comillas dobles, son lo que se conoce en otros
lenguajes como <em>strings</em>. Las cadenas con comillas simples, se llaman
<em>character lists</em> (o <em>char list</em>), listas de carácteres, y son listas, arrays.</p>

<p><strong>Cadenas con comillas simples</strong></p>

<p>Son una lista de códigos que representan los carácteres. Y como son una lista,
podemos usar métodos de <code>List</code>: <code>++</code>, <code>--</code>, <code>List.zip</code>, <code>[ head | tail ]</code>,...</p>

<p>Para saber el número entero que representa un carácter, se puede usar la
notación <code>?&lt;chr&gt;</code>, por ejemplo, <code>?a</code> o <code>?4</code>, para saber los valores numéricos
de los carácteres <code>a</code> y <code>4</code> respectivamente.</p>

<p><strong>Binarios</strong></p>

<p>Qué mejor que un poco de código para ver cómo se usa este tipo de datos</p>

<p>```</p>

<h1>el tipo <em>binario</em> representa una secuencia de bits</h1>

<p>iex> b = &lt;&lt; 1, 2, 3 >>
&lt;&lt;1, 2, 3>>
iex> byte_size b
3
iex> bit_size b
24</p>

<h1>se puede especificar también la cantidad de bits que queremos que ocupen</h1>

<p>iex> b = &lt;&lt; 1::size(2), 1::size(3) >>
&lt;&lt;9::size(5)>>
iex> byte_size b
1
iex> bit_size b
5</p>

<h1>también se pueden almacenar enteros, floats y otros binarios</h1>

<p>iex> an_int = &lt;&lt; 1 >>
&lt;<1>>
iex> a_float = &lt;&lt; 2.5 :: float >>
&lt;&lt;64, 4, 0, 0, 0, 0, 0, 0>>
iex> mix = &lt;&lt; an_int :: binary, a_float :: binary >>
&lt;&lt;1, 64, 4, 0,......>></p>

<h1>extraer valores (echa un vistazo a cómo se codifican los floats según</h1>

<h1>el estándar IEEE 754)</h1>

<p>iex> &lt;&lt; sign::size(1), exp::size(11), mantissa::size(52) >> = &lt;&lt; 3.14159::float >>
iex> (1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exp-1023)
3.14159</p>

<h1>las cadenas con comillas dobles "" (dqs: double quoted string) son de</h1>

<h1>tipo binario, y están codificadas en UTF-8 lo que significa que la</h1>

<h1>longitud de la cadena no tiene por qué coincidir con el tamaño en bytes</h1>

<p>iex> dqs = "∂x/∂y"
"∂x/∂y"
iex> String.length dqs
5
iex> byte_size dqs
9
```</p>

<p><strong>Procesando cadenas</strong></p>

<p>Igual que podemos dividir una lista en <code>head</code> y <code>tail</code>, podemos extraer el
primer carácter (se refiere a él como <em>grapheme</em>, grafema/grafo/...) de una
cadena binaria o <em>dqs</em> especificando que <code>head</code> es de tipo <code>utf8</code> y que <code>tail</code>
sigue siendo de tipo binario:</p>

<p><code>
defp each(&lt;&lt; head::utf8, tail::binary &gt;&gt;), do [ head | each(tail) ]
defp each(&lt;&lt;&gt;&gt;), do []
</code></p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p>Está claro que hay que ver la documentación del módulo <a href="http://elixir-lang.org/docs/stable/elixir/String.html"><code>String</code></a>, que contiene
métodos para manipular cadenas encerradas en comillas dobles (recuerda, son de
tipo binario).</p>

<p>Las expresiones regulares son bastante comunes, y en Elixir se suelen usar
mediante <a href="http://elixir-lang.org/getting-started/sigils.html"><em>sigils</em></a>. Son un aspecto bastante curioso del lenguaje y pueden ser
personalizados.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-01-round-04.exs">exercise-01-round-04.exs</a>: escribe una función que devuelva <code>true</code> si el
parámetro (una lista de carácteres) contiene sólo carácteres imprimibles (del
espacio a la tilde)</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-02-round-04.exs">exercise-02-round-04.exs</a>: escribe una función que devuelva <code>true</code> en el
caso de que dos palabras sean anagramas. <code>anagram?(word1, word2)</code></li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-03-round-04.exs">exercise-03-round-04.exs</a>: escribe una funcion que calcule suma, resta,...
de una cadena pasada como parámetro: <code>calculate('123 + 27') # =&gt; 150</code>. Este
es especialmente difícil (al menos para mi nivel): devolver tuplas, parsear
números (utilizando recursión de una forma muy imaginativa), utilizando pattern
matching para construir funciones dependiendo del operador,...</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-04-round-04.exs">exercise-04-round-04.exs</a>: escribe una función que pasándole una lista de
dqs (double quoted strings) las imprima centradas en un ancho de la palabra
más larga, cada una en una línea distinta.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-05-round-04.exs">exercise-05-round-04.exs</a>: escribe una función que pase a mayúsculas la
primera letra de cada frase en una cadena</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-06-round-04.exs">exercise-06-round-04.exs</a>: escribe una función que parsee un fichero CSV
(que tendrá los campos id, estado y cantidad neta), y que se lo pase a la
función desarrollada en el tercer asalto, al ejercicio
<code>exercise-02-round-03.exs</code>.</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: tercer asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/05/01/elixir-tercer-round/"/>
    <updated>2016-05-01T17:46:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/05/01/elixir-tercer-round</id>
    <content type="html"><![CDATA[<p>Éste es el tercer asalto para aprender <a href="http://elixir-lang.org/">Elixir</a>, y las cosas se van poniendo
interesantes, aunque todavía siento que estoy muy verde y me falta todavía
mucho para ser capaz de hacer las cosas más sencillas.</p>

<p>En este asalto, aprendo nuevas cosas proporcionadas por los módulos <code>Enum</code>,
<code>Stream</code> y otras coleciones, así como las <em>comprehensions</em>, que me recuerdan
mucho a los clásicos bucles <code>for</code>.</p>

<p>Sigo aprendiendo siguiendo el método descrito en el post sobre <a href="/blog/2016/01/17/aprendiendo-elixir/">aprender Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/third-fight.png"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/c9bWJA">3rd fight</a> de <a href="https://www.flickr.com/photos/takfoto/">Tomasz Krawczak</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/legalcode">CC BY-NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Procesando colleciones con <code>Enum</code></strong></p>

<p>Elixir tiene muchos tipos de datos que actúan como colleciones: listas, mapas,
diccionarios, rangos, ficheros e incluso funciones. Las colecciones se pueden
iterar (sobretodo con funciones del módulo <code>Enum</code>), y algunas permiten añadir
elementos.</p>

<p>```</p>

<h1>convierte cualquier colección a List</h1>

<p>list = Enum.to_list 1..5
  #=> [1, 2, 3, 4, 5]</p>

<h1>concatena</h1>

<p>Enum.concat([1, 2, 3], [4, 5, 6])
  #=> [1, 2, 3, 4, 5]</p>

<h1>crea nuevas colleciones</h1>

<p>Enum.map(list, &amp;(&amp;1 * 10))
  #=> [10, 20, 30, 40, 50]</p>

<h1>selecciona elementos por posición</h1>

<p>Enum.at(10..20, 3) #=> 13
Enum.at(10..20, 20) #=> nil
Enum.filter(list, &amp;(&amp;1 > 2)) #=> [3, 4, 5]
Enum.reject(list, &amp;Integer.is_even/1) #=> [1, 3, 5]</p>

<h1>ordena y compara elementos</h1>

<p>Enum.sort([ "there", "was", "a", "crooked", "man" ],
  &amp;(String.length(&amp;1) &lt;= String.length(&amp;2))
Enum.max([ "there", "was", "a", "crooked", "man" ]) #=> "was"</p>

<h1>divide una colleción</h1>

<p>Enum.take(list, 3)    #=> [1, 2, 3]
Enum.take_every(list, 2)  #=> [1, 3, 5]
Enum.take_while(list, &amp;(&amp;1 &lt; 4))
Enum.split(list, 3)
  #=> { [1, 2, 3], [4, 5] }
Enum.split_while(list, &amp;(&amp;1 &lt; 4))
  #=> { [1, 2, 3], [4, 5] }</p>

<h1>une los elementos de una colección</h1>

<p>Enum.join(list)
Enum.join(list, ", ")   #=> "1, 2, 3, 4, 5"</p>

<h1>hace preguntas sobre operaciones</h1>

<p>Enum.all?(list, &amp;(&amp;1 &lt; 4))
Enum.any?(list, &amp;(&amp;1 &lt; 4))
Enum.member?(list, 4)
Enum.empty?(list)</p>

<h1>mezcla colecciones</h1>

<p>Enum.zip(list, [:a, :b, :c])
  #=> [ {1, :a}, {2, :b}, {3, :c} ]</p>

<h1>otros</h1>

<p>Enum.reduce(<collection>, <function>)
```</p>

<p><strong><code>Stream</code>s, enumerables diferidos o perezosos</strong></p>

<p>El módulo <code>Stream</code> permite enumerar collecciones de forma diferida (<em>lazy</em> es
la palabra utilizada, que traduzco libremente como <em>diferida</em>).</p>

<p>Las funciones del módulo <code>Enum</code> procesan todos los elementos de la colección de
una vez, consumiendo memoria. Las del módulo <code>Stream</code> consumen los elementos de
uno en uno, según se van necesitando. Los <em>streams</em> se pueden componer, es
decir, los streams son collecciones, por lo que se pueden usar las funciones de
<code>Stream</code> con los propios streams (sería como crear streams de streams).</p>

<p>Finalmente, para obtener los resultados, se puede convertir un <code>Stream</code> a una
lista:</p>

<p><code>
[1, 2, 3, 4, 5]
  |&gt; Stream.map(&amp;(&amp;1 * &amp;1)
  |&gt; Stream.map(&amp;(&amp;1 + 1)
  |&gt; Stream.filter(fn x -&gt; rem(x, 2) == 1 end)
  |&gt; Enum.to_list
</code></p>

<p>Con <code>Enum</code> debemos esperar a tener todos los elementos de la colección para
empezar a procesarlos. Con <code>Stream</code> podemos comenzar a procesarlos
inmediatamente. Imagina que leemos de un servidor remoto, o de un sensor, ambos
mandan datos infinitamente, por lo que <code>Enum</code> no sería una opción válida en
este caso.</p>

<p>Normalmente, serán las librerías y los frameworks quienes nos proporcionen los
streams con los que vamos a trabajar, pero también podemos crearlos nosotros
con métodos proporcionados por Elixir: <code>cycle</code>, <code>repeatedly</code>, <code>iterate</code>,
<code>unfold</code> y <code>resource</code>.</p>

<p>```</p>

<h1>cycle toma una coleción y va devolviendo de uno en uno indefinidamente</h1>

<h1>cuando la colección se acaba, vuelve a empezar desde el principio</h1>

<p>Stream.cycle([1, 2, 3])
  |> Enum.take(10)</p>

<h1>=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]</h1>

<h1>repeatedly toma una función y la ejecuta cada vez que se le pide un elemento</h1>

<p>Stream.repeatedly(fn -> true end) |> Enum.take(3)
  #=> [ true, true, true ]
Stream.repeatedly(&amp;:random.uniform/0) |> Enum.take(3)
  #=> [ 0.723, 0.941, 0.1234 ]</p>

<h1>iterate toma un valor inicial y una función. el primer elemento es el valor inicial,</h1>

<h1>el siguiente es el valor devuelto por la función pasándole el valor inicial, el siguiente</h1>

<h1>es el valor devuelto por la función pasándole el valor anterior, así indefinidamente</h1>

<p>Stream.iterate(0, &amp;(&amp;1 + 1)) |> Enum.take(5)
  #=> [0, 1, 2, 3, 4]</p>

<h1>unfold es similar a iterate, pero con tuplas. el primer valor de la tupla</h1>

<h1>significa el valor de la iteración actual, el segundo valor significa el valor</h1>

<h1>a procesar en la siguiente iteración</h1>

<p>Stream.unfold( {0, 1}, fn {f1, f2} -> {f1, {f2, f1+f2}} end ) |> Enum.take(15)
  #=> [0, 1, 1, 2, 3, 5, 8, 13, ... fibonacci]</p>

<h1>resource es similar a unfold. toma tres funciones como argumentos. la primera</h1>

<h1>crea el recurso, la segunda va dando valores de las iteraciones (como unfold)</h1>

<h1>y la tercera cierra el recurso (fichero, bbdd, ...)</h1>

<p>```</p>

<p><strong>El protocolo <code>Collectable</code></strong></p>

<p>No son lo mismo, y todavía no soy capaz de describir exactamente lo que es un
<em>protocolo</em>, pero el concepto que tengo de ellos hoy mismo es que son
<em>equivalentes</em> a las interfaces en los lenguajes orientados a objetos.</p>

<p><code>Enumerable</code> es un protocolo que permite iterar una colección. <code>Collectable</code>
permite añadir elementos a una colección. Se puede utilizar <code>Enum.into</code> para
hacerlo y convertir un tipo de colección en otro.</p>

<p><code>
Enum.into 1..5, [1000, 10001]
  #=&gt; [1000, 1001, 1, 2, 3, 4, 5]
</code></p>

<p><strong>Comprehensions</strong></p>

<p>Se le pueden pasar una o más colecciones, entonces extrae todas las
combinaciones posibles de los elementos de dichas colecciones, opcionalmente
puede filtrar valores, y genera una nueva colección con los valores que pasan
el filtro. La sintaxis es <code>result = for &lt;generator&gt; or &lt;filter&gt;, do:
&lt;expression&gt;</code>. Donde <code>&lt;generator&gt;</code> tiene la forma <code>pattern &lt;- collection</code> y el
filtro es simplemente una condición, por ejemplo <code>x &lt; 4</code>.</p>

<p>Las variables declaradas en una comprehension tienen la misma como ámbito, no
escapan de él.</p>

<p>```
for x <- [1, 2, 3, 4, 5], x < 4, do: x * x
  # => [1, 4, 9]</p>

<p>for x <- [1, 2], y <- [5, 6], do: x * y
  # => las posibles combinaciones serían [1, 5], [1, 6], [2, 5], [2, 6]
  # => y esas combinaciones serían las iteraciones de la comprehension</p>

<h1>se pueden usar variables de generadores en siguientes generadores</h1>

<p>min_maxes = [ {1, 4}, {2, 3}, {10, 15} ]
for { min, max } <- min_maxes, n <- min..max, do: n
  # => [ 1, 2, 3, 4, 2, 3, 10, 11, 12, 13, 14, 15 ]</p>

<h1>por defecto, las comprehensions devuelven una lista. Se puede cambiar</h1>

<h1>con el parámetro <code>into:</code></h1>

<p>for x <- ~w{ cat dog }, into: Map.new, do: { x, String.upcase(x) }
  # => %{ "cat" => "CAT", "dog" => "DOG" }
```</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p>Podría investigar sobre qué son los protocolos, pero creo que están descritos
en el libro del cual está surgiendo esta serie de posts, por lo que esperaré a
llegar ahí.</p>

<p>Tener siempre muy presente las funciones del módulo <code>Enum</code>, ya que casi seguro
que se van a utilizar siempre que haya colecciones de por medio.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/exercise-01-round-03.exs">exercise-01-round-03.exs</a>: con ayuda de la función <code>span</code> escrita anteriormente, escribir una función que devuelva la lista de números primos de <code>2</code> hasta <code>n</code></li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/exercise-02-round-03.exs">exercise-02-round-03.exs</a>: a partir de dos listas, una de tasas de impuestos, y otra de compras, calcular el importe total de cada una de las compras</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/lists-and-recursion-5.exs">lists-and-recursion-5.exs</a>: implementar funciones presentes en <code>Enum</code>: <code>all?</code>, <code>each</code>, <code>filter</code>, <code>take</code> y <code>split</code>.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/lists-and-recursion-6.exs">lists-and-recursion-6.exs</a>: implementar <code>flatten</code></li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
</feed>
