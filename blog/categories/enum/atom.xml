<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: enum | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/enum/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2015-02-27T01:44:37+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Formatear y parsear enumerados en Java con valores personalizados]]></title>
    <link href="http://rchavarria.github.io/blog/2013/01/22/formatear-y-parsear-enumerados-en-java-con-valores-personalizados/"/>
    <updated>2013-01-22T13:17:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2013/01/22/formatear-y-parsear-enumerados-en-java-con-valores-personalizados</id>
    <content type="html"><![CDATA[<p>A partir de la versión 1.5 de Java, nos encontramos con un tipo de datos, un tipo
especial de clases podríamos decir, los enumerados. Los tipos enumerados sirven para
acotar los posibles valores que puede tomar una variable o tipo de objeto. Java
proporciona un método para transformar un enumerado en cadena, <code>name()</code>, y un método
estático para convertir una cadena en uno de los valores del enumerado,
<code>valueOf(String)</code>. Pero estos métodos son un poco limitados, ya que no nos permiten
personalizar los valores a los cuales son transformados los enumerados.</p>

<!-- more -->


<p>Partiremos del siguiente código describiendo tres valores en un enumerado:</p>

<p>``` java
public enum States {</p>

<pre><code>EVERYTHING_IS_OK,
SOMETHING_WENT_WRONG,
TOTAL_FAILURE;
</code></pre>

<p>}
```</p>

<p>Así, sin más, podemos obtener la representación en <code>String</code> de <code>States.TOTAL_FAILURE</code>
simplemente llamando al método <code>States.TOTAL_FAILURE.name()</code>. De la misma forma, usando
la llamada <code>States.valueOf("EVERYTHING_IS_OK")</code> es fácil imaginar qué valor del enumerado
obtendremos.</p>

<p>Pero, y si en lugar de esa representación a <code>String</code>, ¿queremos definir la nuestra
propia?. Por ejemplo, siguiendo la siguiente tabla:</p>

<ul>
<li>EVERYTHING_IS_OK &rarr; green</li>
<li>SOMETHING_WENT_WRONG &rarr; yellow</li>
<li>TOTAL_FAILURE &rarr; red</li>
</ul>


<h2>Formatear a cadena</h2>

<p>Formatear es sencillo, y directo. Podemos declarar un campo <code>value</code> donde almacenar el
valor al cual queremos transformar el enumerado, y podemos sobreescribir el método
<code>toString()</code> de la siguiente manera:</p>

<p>``` java
public enum States {</p>

<pre><code>EVERYTHING_IS_OK("green"),
SOMETHING_WENT_WRONG("yellow"),
TOTAL_FAILURE("red");

private String value;

private States(String value) {
    this.value = value;
}

public String toString() {
    return value;
}
</code></pre>

<p>}
```</p>

<h2>Parsear desde una cadena</h2>

<p>El problema viene cuando queremos obtener un valor del enumerado a partir de un <code>String</code>.
Supongamos que la transformación la vamos a hacer en un método estático, que por contraste
con el anterior método llamaremos <code>fromString</code>. Veamos qué opciones tenemos, de menos a
más apropiadas:</p>

<h3>Sentencias if</h3>

<p>La primera solución que le viene a uno a la cabeza es usar sentencias <code>if</code>.</p>

<p>``` java
[...]
public static States fromString(String fromValue) {</p>

<pre><code>if("green".equals(fromValue)) {
    return EVERYTHING_IS_OK;
} else if("yellow".equals(fromValue)) {
    return SOMETHING_WENT_WRONG;
} else if("red".equals(fromValue)) {
    return TOTAL_FAILURE;
}
throw new IllegalArgumentException("Wrong value: " + fromValue);
</code></pre>

<p>}
[...]
```</p>

<p>No hay mucho que decir aquí, simplemente que se debería evitar a toda costa esta solución.</p>

<h3>Bucle for</h3>

<p>Otra solución, un poco más elegante, pero básicamente siguiendo la misma filosofía, podría
ser utilizar un bucle para recorrer los posibles valores del enumerado:</p>

<p>```
[...]
public static States fromString(String fromValue) {</p>

<pre><code>for(States state : values()) {
    if(state.value.equals(fromValue)) {
        return state;
    }
}
throw new IllegalArgumentException("Wrong value: " + fromValue);
</code></pre>

<p>}
[...]
```</p>

<p>Esta solución es un poquito mejor, ya que si modificamos los valores posibles del enumerado,
no es necesario que modifiquemos este método.</p>

<h3>Prealmacenamiento de los valores en un Map</h3>

<p>Existe una solución que no involucra el uso de sentencias <code>if</code>, lo cual es muy positivo, ya
que estamos evitando la posibilidad de error, ya que no tendremos que formular una condición.</p>

<p>Esta solución la encontré en un hilo el de Stack Overflow <a href="http://stackoverflow.com/questions/1080904/how-can-i-lookup-a-java-enum-from-its-string-value">how can I lookup a Java enum
from its string value?</a>.
Lo que pretende esta solución es crear una estructura de datos, y cuando se quiera transformar
un <code>String</code> en un valor del enumerado, simplemente se consulte esa estructura de datos.</p>

<p>La estructura de datos será un <code>Map</code> estático, que se rellenará en un bloque estático y
consultaremos en nuestro método <code>fromString</code>.</p>

<p>```
[...]
private static Map&lt;String, States> dictionary;
static {</p>

<pre><code>dictionary = new HashMap&lt;String, States&gt;();
for(States state : values()) {
    dictionary.put(state.value; state);
}
</code></pre>

<p>}
[...]
public static States fromString(String fromValue) {</p>

<pre><code>States state = dictionary.get(fromValue);
if(state == null) {
    throw new IllegalArgumentException("Wrong value: " + fromValue);
}
return state;
</code></pre>

<p>}
[...]
```</p>

<h2>Peligros de esta última solución</h2>

<p>En Stack Overflow, un comentario a la respuesta donde encontré la solución sugiere que esta solución
puede causar problemas debido al classloader.</p>

<p>Pero he investigado un poco el tema, y parece que el comentario es erróneo, al menos para el
uso de los enumerados que estoy exponiendo aquí. Según el
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#d5e12253">ejemplo 8.9.2-1 de la especificación del java</a>,
primero se inicializan los valores del enumerado, luego la variable estática y finalmente
se ejecuta el bloque de código estático, estando ya todos los valores del enumerado
inicializados.</p>

<p>Aquí os dejo unos cuantos enlaces a que confirman que la última solución es correcta:</p>

<ul>
<li><a href="http://blog.deepincode.com/2006/12/bootstrapping-static-fields-within-enums">Bootstrapping static fields within enums</a> y en enlace encontrado en ese mismo post: <a href="http://blog.deepincode.com/2006/11/type-safe-enumerations-in-java-50">Type Safe Enumerations in Java 5.0</a> (buscar al final de este último post).</li>
<li>Otro hilo de Stack Overflow, <a href="http://stackoverflow.com/questions/6827987/when-are-these-class-and-subclass-static-blocks-executed-for-an-enum">When are these class and subclass static blocks executed (for an Enum)?</a> que me lleva al recurso definitivo:</li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#d5e12253">Java Language Specification - Example 8.9.2-1</a>: Si la documentación de Oracle sobre java es errónea, apaga y vámonos.</li>
</ul>


<h2>Otras soluciones</h2>

<p>Por supuesto que existen otras soluciones, quizá mejores que la última que propongo, pero
no he querido hacer más largo este post y he querido centrarme en proponer una alternativa
a los métodos <code>.name()</code> y <code>.valueOf()</code>, pertenecientes al propio enumerado.</p>

<p>Es por esto por lo que he descartado usar clases externas para formatear o parsear el
enumerado, lo cual me habría hecho llegar a otras soluciones bien distintas. Pero si crees
que tu solución es muchísimo mejor que ésta, déjame un comentario, será bienvenido.</p>
]]></content>
  </entry>
  
</feed>
