<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: agile | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/agile/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2014-12-02T00:20:06+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Charla sobre eXtreme Programming]]></title>
    <link href="http://rchavarria.github.io/blog/2014/09/20/charla-sobre-extreme-programming/"/>
    <updated>2014-09-20T01:27:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2014/09/20/charla-sobre-extreme-programming</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/2014/xppractices.jpg" width="360" height="270" title="Prácticas de eXtreme Programming" ></p>

<p>Recientemente he dado una charla en el trabajo acerca de <a href="http://www.extremeprogramming.org">eXtreme Programming</a>.
No es nada del otro mundo, tampoco pretendo dar lecciones a nadie y tampoco
he descubierto nada que no estuviera escrito ya. Pero al hacer la charla he
reunido un poco de información de aquí y de allá, y ya que he hecho ese
pequeño esfuerzo, ¿por qué no plasmarlo aquí?</p>

<p>A continuación os dejo el guión que escribí mientras la preparaba. No conté
todo lo que está, ni está todo lo que conté, pero este fue mi pequeño trabajo
de campo.</p>

<!-- more -->


<h2>Introducción al desarrollo ágil de software</h2>

<p>El desarrollo de software comenzó siendo hecho por ingenieros, de los de toda
la vida (que no quiere decir que sea malo, pero como veremos fue diferente),
lo que condicionó su forma de hacerlo, pero construir software es más parecido
a crear una obra de arte: requiere <em>creatividad</em> y <em>artesanía</em>.</p>

<p>A diferencia de otros productos de la ingeniería, el software es maleable,
muchas veces ilógico y siempre se encuentra incompleto (por eso se parece
a una obra de arte).</p>

<p>Al entender estas diferencias es cuando empiezan a surgir nuevas forma de
desarrollar software, como el desarrollo ágil de software.</p>

<p>No existen metodologías o procesos ágiles (en contra de todo lo que se vende
últimamente), sólo existen <strong>equipos ágiles</strong>. Eso que se describe como
metodología ágil no es más que la construcción de un entorno para que los
equipos aprendan a ser ágiles.</p>

<p>Diferencias con lo que se venía haciendo hasta ahora:</p>

<ul>
<li>La forma en la que el equipo trabaja junto es más importante que cualquier
proceso (gente y comunicación frente a procesos y herramientas).</li>
<li>El cliente, el usuario, pasa a ser un miembro esencial del equipo.</li>
<li>El mayor problema con el desarrollo de software son los requisitos
cambiantes. Para la mayoría de los proyectos, aceptar los cambios puede
costar menos que asegurar que los requisitos no van a cambiar nunca.</li>
</ul>


<p>Al cambiar la forma de ver los cambios, resulta que es más fácil cambiar cómo
se gestionan los proyectos. En lugar de gestionar actividades y esperar al
final del todo a tener una aplicación, los agilistas gestionan los requisitos
(aceptando que éstos van a cambiar) y se muestra al cliente cómo la aplicación
va cambiando con el tiempo.</p>

<h2>Gestión por funcionalidades</h2>

<p>En la gestión tradicional, se planifican las actividades una detrás de otra,
cuando finaliza una comienza la siguiente. Así hasta el final del proyecto.
Es entonces la única vez donde se muestra el software creado.</p>

<p>¿Cómo funciona? Los requisitos son constantes a lo largo del tiempo, y fluyen a
través de las actividades como por una línea de montaje. Cada actividad finaliza
con los requisitos a la vez  y al final de la línea se entrega un software.
Podemos tener gente especializada en cada actividad, e ir cambiando de equipo
según vamos cambiando de actividad. La única pega que tiene es que los requisitos
no son constantes, por lo que todo lo demás no sirve de nada.</p>

<p>¿Y Agile? Agile considera que los requisitos no son constantes. Cada requisito,
cada funcionalidad se presenta al cliente como una Historia de Usuario. El gráfico
anterior se gira 90º y el proceso en sí mismo es el que permanece constante. Se
planifican los requisitos por prioridad, y se va trabajando uno a uno pasándolo por
todas las actividades, por lo que vamos teniendo requisitos completos poco a poco.
Tener los requisitos priorizados permite cambiarlos a antojo. Y no solo eso,
también permite finalizar el proyecto en el momento en el que queramos.</p>

<p>Este giro de 90º permite a los managers a tener una estimación de coste por
requisito, no por actividad.</p>

<p>Uno de los costes de gestionar requisitos es que siempre hay que estar listo para
nuevas funcionalidades, por lo que se debe mantener una calidad muy alta tanto en
diseño como en código.</p>

<h2>Cómo evoluciona el software</h2>

<p>En todo desarrollo de software llega un momento en el al que arreglar un bug,
resulta que se crean uno o varios pequeños bugs por ahí dispersos.</p>

<p>Barry Boehm ya encontró que según va avanzando un proyecto software en su ciclo
de vida, el coste de un cambio se vuelve cada vez más y más grande. Un concepto
que lo explica mejor podría ser el Principio de Oxidación del Software.</p>

<p>Esta curva se comenzó interpretando de forma que se debían crear documentos de
requisitos lo más detallados y lo más estáticos posibles. Agile no lo considera
así, en lugar de eso se prepara para que los cambios en los requisitos cuesten
poco.</p>

<p>Para eso, y para combatir la oxidación del software, Agile propone:</p>

<ul>
<li>Refactorizar: hacerlo sin descanso, sin límites, sin parar, sin excusas…
refactoriza</li>
<li>Tests: unitarios y de aceptación. También se aceptan otros: de integración,
de sistema, de lo que sea, pero tests. Automáticos, eso si. Con ellos se logra
eliminar el miedo a los cambios.</li>
<li>Entrega temprana y frecuente: con ello se aumenta el feedback del cliente y
ayuda a identificar cambios. Y cuanto antes se detecten estos cambios, menor
coste tendrán.</li>
</ul>


<p>¿Cómo mantener la capacidad de poder realizar cambios manteniendo el coste en
niveles aceptables? Sólo porque el cliente no vea el código no significa que
no tengamos que hacer esfuerzo para mantener la capacidad de realizar cambios.
Y esto se consigue manteniendo un alto nivel de calidad, una baja complejidad
y una cobertura de tests lo más alta posible.</p>

<h2>Introducción a XP</h2>

<p>El primer proyecto en el que se usó eXtreme Programming comenzó el 6 de marzo
de 1996. XP es uno de los famosos Procesos Ágiles, entre los que se encuentran
Scrum, Kanban,…</p>

<p>En lugar de entregar todo lo que el cliente desea en un futuro lejano, XP va
entregando el software trocito a trocito, según se va necesitando.</p>

<p>XP hace hincapié en el trabajo en equipo. Managers, clientes y programadores
forman parte del mismo equipo. Los clientes se sienten bien siendo parte del
equipo, los programadores contribuyen activamente y los managers se encargan
de que exista una buena comunicación.</p>

<p>¿Por qué extremo? Por una serie de reglas y prácticas las lleva a su máxima
expresión, mucho más que en proyectos tradicionales.</p>

<h2>De vuelta a lo básico, qué es lo que en realidad importa</h2>

<p>Como ya sabemos, crear software es muy complicado. Por lo que no tiene sentido
perder el tiempo en tareas que no importan. XP se deshace de tareas o actividades
que se consideran que no aportan valor.</p>

<p>XP tiene una serie de reglas que se pueden englobar en estos cuatro aspectos:</p>

<ul>
<li><em>Escuchar</em>: hay que aprender, hay que conocer el problema. Eso te dirá qué es
lo que debes testear. Como probablemente no lo averigües tú solo, deberás
escuchar a los clientes, a los usuarios, managers y demás gente de negocio.</li>
<li><em>Diseñar</em>: hay que escuchar lo que el código nos cuenta acerca de cómo quiere
estar estructurado, y darle forma poco a poco.</li>
<li><em>Codificar</em>: si al final del día no hay un software ejecutable, no habrás
hecho nada.</li>
<li><em>Testear</em>: hay que saber cuándo hemos terminado. De otra forma, estarás atascado
pensando si todo cumple con lo establecido o no. Pero lo peor de todo, es que
tampoco vas a saber cómo de cerca estás de tu destino.</li>
</ul>


<h2>Reglas</h2>

<p>Algunas reglas sueltas quizá no tengan sentido, pero combinadas se puede ver
hacia dónde van, qué es lo que quieren conseguir.</p>

<h3>Escuchar</h3>

<p>Se escriben Historias de Usuario (las cuales son el corazón de la planificación
en un proyecto XP).</p>

<p>El proyecto se divide en iteraciones o sprints.</p>

<p>Al final de cada iteración, se realiza una pequeña entrega de funcionalidades.</p>

<p>Se crean tres niveles de planificación:</p>

<ul>
<li>Release plan: mira hacia el futuro unos cuantos meses y agrupa historias
en grandes entregas.</li>
<li>Next Iteration plan: se agrupan las historias que se van a realizar en
la próxima iteración.</li>
<li>Current Iteration plan: las historias definidas para esta iteración se
dividen hasta que se encuentran tareas que se pueden acometer fácilmente.
Los planes se toman como algo vivo, no como algo estático. Si el cliente
cambia de idea, se cambian los planes. Si el equipo se retrasa en una entrega,
se cambian los planes.</li>
</ul>


<p>Se intenta conseguir un Ritmo Sostenible.</p>

<p>Cada dia comienza con un Stand-up Meeting.</p>

<p>Se mide la Velocidad del Proyecto.</p>

<p>Se favorecen los Espacios Abiertos y se fomenta la Movilidad de las Personas.</p>

<h3>Diseñar</h3>

<p>Simplicidad, se busca siempre lo más sencillo posible. Para poder mostrárselo
al cliente lo antes posible y obtener feedback.</p>

<p>Siempre se usa una Metáfora del Sistema, se busca usar el lenguaje propio
del negocio, la jerga que se usa en el entorno para el cual se está
desarrollando el software.</p>

<p>Se crean Spikes, para reducir riesgos.</p>

<p>Ninguna funcionalidad se añade prematuramente (yagni).</p>

<p>Se Refactoriza en cualquier momento y en cualquier lugar que sea posible.</p>

<p>Se usan Tarjetas CRC para las decisiones de diseño. Así, todos los miembros
del equipo entienden y contribuyen al diseño.</p>

<h3>Codificar</h3>

<p>El cliente siempre está disponible para resolver dudas sobre el software.</p>

<p>El código se escribe siguiendo unos Estándares consensuados por el equipo.</p>

<p>Primero, se escriben los Tests Unitarios, luego el código de producción.</p>

<p>Todo el código de producción se escribe mientras se Programa por Parejas.</p>

<p>Se Integra Frecuentemente, mejor con Integración Contínua.</p>

<p>El código es de todos, Collective Ownership.</p>

<h3>Testear</h3>

<p>En un proyecto XP, los programadores toman la actitud de ser ellos quien
demuestran al cliente que los requisitos funcionan, y no al revés, no es
el cliente quien demuestra que lo que pidió no funciona.</p>

<p>Todo el código debe tener Tests Unitarios. Y todos los tests pasan antes
de sacar una versión.</p>

<p>Cuando se encuentra un bug, se crea un test para reproducirlo, arreglarlo,
y que nunca vuelva a salir una versión con ese bug.</p>

<p>Se escriben Tests de Aceptación. Se ejecutan frecuentemente y su puntuación
se hace pública.</p>

<h2>Valores</h2>

<p>XP mejora un proyecto software en cinco aspectos fundamentales, que se han
convertido en los valores de XP. Las reglas que acabamos de ver son consecuencia
de maximizar estos valores.</p>

<ul>
<li>Simplicidad: se hace lo que es necesario, pero nada más. No se añade complejidad
extra porque sí. Se avanza a pasos pequeños pero firmes.</li>
<li>Comunicación: todo el mundo es parte del equipo. Siempre que se pueda, la
comunicación es cara a cara.</li>
<li>Feedback: al final de cada iteración se entrega un software ejecutable y
válido. Se demuestra el software pronto y frecuentemente.</li>
<li>Respeto: todo el mundo da y recibe respeto. Los programadores respetan la
experiencia de los clientes y al revés.</li>
<li>Coraje: siempre se dice la verdad sobre las estimaciones y el estado de las
tareas.</li>
</ul>


<h2>Para seguir leyendo</h2>

<ul>
<li><a href="http://www.adictosaltrabajo.com/detalle-noticia.php?noticia=379">Principio de oxidación del software (Spanish)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Barry_Boehm">Barry Boehm</a></li>
<li><a href="http://www.extremeprogramming.org/lessons.html">XP lessons learned</a></li>
<li><a href="http://www.extremeprogramming.org/when.html">When should XP be used</a></li>
<li><a href="http://www.agile-process.org">Agile process</a></li>
<li><a href="http://www.amazon.com/Extreme-Programming-Explained-Embrace-Edition/dp/0321278658">Extreme programming explained</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Curso de Scrum Master]]></title>
    <link href="http://rchavarria.github.io/blog/2013/10/08/curso-de-scrum-master/"/>
    <updated>2013-10-08T11:28:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2013/10/08/curso-de-scrum-master</id>
    <content type="html"><![CDATA[<p>Los días 3 y 4 de octubre de 2013 tuve una oportunidad única, la de asistir a
un curso <strong>GRATUITO</strong> de Scrum Master impartido por <a href="http://twitter.com/adiazmaroto">Ángel Diaz-Maroto</a> en las oficinas de
<a href="http://www.ingdirect.es">ING Direct</a>. Fue un curso espectacular, con otras 14-15 personas magníficas y
que estoy muy agradecido tanto a ING como a Ángel por hacerlo posible. Fue una
auténtica pasada.</p>

<p>Este post es para agradecérselo públicamente y para tener unas pequeñas notas y
no olvidarme de la fabulosa experiencia vivida.</p>

<!-- more -->


<h2>El curso</h2>

<p>El curso fueron 2 días muy intensos, donde aprendimos el funcionamiento de Scrum y el
papel que juega el rol del Scrum Master (porque es un rol, nunca un puesto o un título).
Por supuesto, una vez realizado el curso no eres realmente un Scrum Master, pero yo
lo veo un poco como sacarse el carnet de conducir. Es lo que te da la posibilidad
de conducir y aprender realmente a conducir en situaciones de la vida real. Este curso
es algo así, <strong>nos ha habilitado para aprender a ser Scrum Master en proyectos de la vida
real</strong>.</p>

<p>Muy pronto aprendimos la primera lección: ¿Cómo se hace Scrum? ¿Cómo se hace <em>agile</em>?.
Me quedo con la frase de Ángel:</p>

<blockquote><p>Agilear se hace aligerando</p></blockquote>

<p>La diferencia fundamental de las metodologías ágiles frente a las tradicionales,
es que las ágiles se basan en eliminar, mientras que las tradicionales se
basan en añadir capas de complejidad.</p>

<h2>Acuerdos de trabajo</h2>

<p>Lo primero de todo, antes de empezar a trabajar, lo primordial es establecer unos
acuerdos de trabajo. Sin ellos, cualquier proyecto, empresa, lo que sea, que necesite
de un trabajo en grupo, no podrá saber si todo el mundo avanza en la misma dirección.</p>

<p>Nosotros es lo primero que hicimos al comenzar el curso, y éstos fueron nuestros
<em>Acuerdos de Trabajo</em>:</p>

<p><img class="left" src="/images/2013/curso-scrum-master/01-acuerdos-trabajo.jpg" width="194" height="260"></p>

<ul>
<li>Speak up! (¡Habla!): Los problemas se deben resolver cuanto antes. Si te molesta
cualquier cosa, por pequeña que sea, si crees que va a haber un problema con algo...
Dilo en voz alta, que se sepa. Esta es la única forma de que se resuelvan rápidamente.</li>
<li>Compañerismo: sin él, difícilmente se podrá crear un buen ambiente de trabajo.</li>
<li>Objetivo común: todos debemos ir en la misma dirección, si no, estaremos despediciando
esfuerzos.</li>
</ul>


<h2>Crear una visión</h2>

<p><img class="right" src="/images/2013/curso-scrum-master/02-vision.jpg" width="194" height="260"></p>

<p>Uno de los acuerdos de trabajo es el de tener un objetivo común, y para ello es
necesario crear una visión.</p>

<p>La nuestra la creamos a través de una dinámica de grupo, y al final, el resultado
consensuado al que llegamos fue que nuestra visión para este curso sería:</p>

<blockquote><p>Aprender, en grupo, métodos y buenas prácticas y bases de Scrum, divirtiéndonos.</p></blockquote>

<h2>Manifiesto ágil</h2>

<p><img class="right" src="/images/2013/curso-scrum-master/03-clover.jpg" width="194" height="260"></p>

<p>Una vez sentadas las bases de cómo vamos a trabajar y qué es lo que vamos a
esperar del curso, comenzamos. Y qué mejor punto para empezar que conociendo
los cuatro valores del <a href="http://www.agilemanifesto.org/iso/es/">manifiesto ágil</a>:</p>

<ul>
<li><strong>Individuos e interacciones</strong> sobre procesos y herramientas</li>
<li><strong>Software funcionando</strong> sobre documentación extensiva</li>
<li><strong>Colaboración con el cliente</strong> sobre negociación contractual</li>
<li><strong>Respuesta ante el cambio</strong> sobre seguir un plan</li>
</ul>


<h2>Scrum</h2>

<p><img class="left" src="/images/2013/curso-scrum-master/04-scrum.jpg" width="194" height="260"></p>

<p>Existen multitud de metodologías que se pueden considerar ágiles, entre ellas
está <em>Scrum</em>. Aunque Scrum no es una metodología en sí, es un marco de trabajo.
No es una lista de prácticas que debes hacer, si no una serie de recomendaciones,
que puedes seguir o no, y que son totalmente independientes del campo en que
se apliquen. Y puede que estos sean los factores que han hecho que Scrum se
haya adoptado tanto en todo el mundo.</p>

<p>En el curso, aprendimos cuáles son los actores de Scrum (Product Owner, Scrum
Master, Team, ...), qué elementos forman parte de él (Backlog, Spring,
Entregable, ...) y qué reuniones lo hacen posible (Diaria, Retrospectiva,
Demo, ...).</p>

<p>Todo se podría resumir en <em>Inspección y Adaptación</em>. Inspeccionar qué se está
haciendo y cómo, detectar dónde se podría mejorar y adaptarse para atajar
esos impedimentos para conseguir una mejora contínua.</p>

<h2>Principios y valores</h2>

<p>Luego pasamos a ver cuáles son los principios y valores de Scrum.</p>

<p>Todos ellos se podrían resumir en uno <strong>Respeto</strong>. A partir de él se pueden
ir concretando alguno más, por mencionar algunos (que surgieron a partir de
nosotros y fueron completados por Ángel):</p>

<p><img class="left" src="/images/2013/curso-scrum-master/05-principios-valores.jpg" width="194" height="260"></p>

<ul>
<li>Transparencia: no esconder nada, mostrar toda la información importante acerca
del avance del proyecto, que los problemas salgan a la luz, ...</li>
<li>Confianza: esto da libertad a los integrantes del equipo para trabajar a su
manera y dar lo mejor de sí mismos.</li>
<li>Foco: trabajar con un objetivo común, y no desperciar esfuerzos.</li>
<li>Coraje: porque para cambiar las cosas y trabajar de forma auto-organizada,
sin un <em>jefismo</em> que te las imponga, se necesita mucho coraje.</li>
</ul>


<h2>Roles</h2>

<p>Los dos roles de Scrum que vimos en el curso son el <em>Product Owner</em> y el <em>Scrum
Master</em>. Existe una relación muy fuerte entre ellos, y de ellos depende en
gran medida el éxito del proyecto.</p>

<p>Estuvimos discutiendo qué características deberían tener estos roles:</p>

<p><img class="right" src="/images/2013/curso-scrum-master/06-scrum-master.jpg" width="194" height="260"></p>

<p><img class="right" src="/images/2013/curso-scrum-master/07-product-owner.jpg" width="194" height="260"></p>

<ul>
<li>Scrum Master

<ul>
<li>dialogante</li>
<li>tenaz</li>
<li>empático</li>
</ul>
</li>
<li>Product Owner

<ul>
<li>accesible</li>
<li>priorizador</li>
<li>estratega</li>
</ul>
</li>
</ul>


<h2>Retrospectiva</h2>

<p>Durante todo el curso aplicamos la siguiente máxima:</p>

<blockquote><p>Learn by doing</p></blockquote>

<p><img class="left" src="/images/2013/curso-scrum-master/08-retro.jpg" width="194" height="260"></p>

<p>Es decir, <em>aprender haciendo</em>. De esta forma, aprendimos Scrum haciendo Scrum.
Y Scrum no existe sin una retrospectiva.</p>

<p>La retrospectiva es una parte fundamental de Scrum. Lo más importante, lo que
proporciona la retro, es que al terminar la reunión, se ha tenido que tomar una
decisión:</p>

<blockquote><p>Qué acciones vamos a tomar para solucionar alguno de los problemas que tenemos</p></blockquote>

<p>Y así, poco a poco, problema a problema, con un ritmo sostenible, sin agobios,
ir mejorando contínuamente. Nunca llegarás a la perfección, siempre aparecerán
nuevos problemas, pero ahí estará la retro para identificarlos, sacarlos a la
luz y darles solución.</p>

<h2>Referencias</h2>

<p>A lo largo del curso, hicimos referencia a multitud de autores, libros y recursos,
así que aquí iré dejando aquellas referencias que vayan surgiendo de conversaciones
futuras acerca de este curso:</p>

<ul>
<li><a href="http://scrummasters.com/">Scrum Masters Community</a></li>
<li><a href="https://www.scrum.org/">The home of Scrum</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La meta]]></title>
    <link href="http://rchavarria.github.io/blog/2013/04/10/la-meta/"/>
    <updated>2013-04-10T10:06:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2013/04/10/la-meta</id>
    <content type="html"><![CDATA[<h4>La meta</h4>

<h5>Eliyahu Goldratt</h5>

<p><img class="right" src="http://ecx.images-amazon.com/images/I/51E50P52AXL.<em>SY300</em>.jpg" width="195" height="300" title="La meta" ></p>

<h2>Por qué lo he leído</h2>

<p>Nunca había oído hablar de este libro, pero cuando asistí a la CAS2012, el año pasado en Cáceres,
varias personas que allí conocí (<a href="https://twitter.com/rferlei">Roberto</a> y
<a href="https://twitter.com/anuskiaranda">Ana</a>) me hablaron maravillas de él, así que decidí
ponerlo en la lista de libros a leer.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>Bueno, en realidad ya me habían contado de qué iba el libro, así que ya llevaba una buena idea
de lo que se iba a tratar. Y tenía bastantes buenas espectativas.</p>

<h2>Qué encontre</h2>

<p>Encontré un magnífico libro. La verdad es que es muy ameno y divertido. También es intrigante
ir leyendo cómo el autor va relatando a través del protagonista un proceso de descubrimiento de
soluciones a todos sus problemas.</p>

<p>La verdad es que se hace muy fácil de leer y comprender los principios Lean y la teoría de las
restricciones a través de la historia contada a través del protagonista.</p>

<h2>Conclusiones</h2>

<p>El libro me ha encantado, aunque me hubiera gustado mucho más haberlo leído un tiempo atrás, ya
que trabajé en una fábrica como Ingeniero de Desarrollo (para desarrollar nuevos productos). Por
lo menos ha sido divertido revivir experiencias de aquel trabajo, ya que muchos de los principios
(y problemas también) expuestos en el libro ya los viví en mis propias carnes.</p>

<p>Así pues, este es un libro recomendado sobre todo a todos aquellos interesados en mejorar procesos
de producción. No parece un tema muy de desarrollo de software, que es a lo que me dedico, pero
estos principios son la base de las metodologías Lean, y por ende, Agile. Además, es un libro
que se lee relativamente rápido, y, de verdad, es muy divertido, así que tampoco cuesta tanto.</p>

<h2>Pasajes que quiero recordar de este libro</h2>

<blockquote><p>Comprar a precios económicos no es la meta.</p>

<p>La meta no es vender, hay veces que se vende perdiendo dinero o con márgenes ínfimos.</p>

<p>Qué es lo que la gente piensa que son las metas: compras baratas, contratación de gente adecuada,
tecnología punta, fabricacón de bienes de calidad, venta de bienes de calidad,
conquista tasa de mercado, comunciaciones o cumplimiento de los deseos del cliente.
Pero esos son medios para alcanzar la meta.</p>

<p>La calidad sola, es importante, pero no es la meta.</p>

<p>Tecnologia, es importatne, pero no es la meta.</p>

<p>Trabajar no es sinónimo de ganar dinero.</p>

<p>Ésta es la meta: ganar dinero aumentando los beneficios netos y al mismo tiempo el rendimiento
de la inversión (ROI) y la liquidez.</p>

<p>Parámetros que expresan la meta y que permiten establecer procedimientos operativos para
dirigir la fábrica: ingresos, inventarios y gastos de operación.</p>

<p>Una fabrica, en la que todo el mundo produce ininterrumpidamente, es muy poco productiva.</p>

<p>Una regla que expresa la relación entre cuellos de botella y los demas recursos: equilibrar
el flujo, no la capacidad.</p>

<p>El grado de utilización de un recuros 'no-cuello' de botella no vendrá dado por su propia
capacidad sino por alguna otra restricción del sistema.</p>

<p>Se pueden distinguir 4 tipos de tiempos desde que el material entra en la fábrica hasta
que sale de ella: de preparación, de proceso, en cola y de espera.</p>

<p>Tres consejos sobre cómo dirigir: Saber convencer a otras personas, desprender las capas
de la práctica común y vencer la resistencia al cambio.</p>

<p>Nunca des las respuestas, solo plantea las preguntas.</p>

<p>¿Qué cabmiar? ¿Hacia qué cambiar? ¿Cómo provocar el cambio? Basicamente estamos pidiendo
las habiliades fundamentales que uno debería esperar de un directivo.</p></blockquote>

<h2>Conceptos</h2>

<ul>
<li><p>Productividad: significa hacer las cosas de tal manera que, en el caso de la empresa, ésta
se aproxime lo más posible a su meta. Todo aquello que lleve a una compañía más cerca de su meta
es productivo, todo aquello que no la lleve es imprductivo.</p></li>
<li><p>Ingresos: tasa de generacion de dinero a traves de las ventas.</p></li>
<li><p>Inventario: todo el dinero que el sistema ha invertido en adquierrir cosas que pretende vender.</p></li>
<li><p>Gastos de operación: todo el dienro que el sistema gasta para convertir el inventario en ingresos netos.</p></li>
</ul>


<h2>Otras lecturas y enlaces relacionadas</h2>

<ul>
<li><a href="/blog/2012/10/10/lean-software-development/">Lean software development</a>, de Mary y Tom Poppendiek.</li>
<li><a href="https://plus.google.com/105077077543737057709">Roberto Hens</a> también lo ha leído, y esto es lo que le parece:</li>
<li><a href="http://robertohens.blogspot.com.es/2013/04/Kanban-el-Origen-The-Goal.html">Kanban, el origen</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Agile estimating and planning]]></title>
    <link href="http://rchavarria.github.io/blog/2013/02/13/agile-estimating-and-planning/"/>
    <updated>2013-02-13T13:08:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2013/02/13/agile-estimating-and-planning</id>
    <content type="html"><![CDATA[<h4>Agile estimating and planning</h4>

<h5>Mike Cohn</h5>

<p><img class="right" src="http://www.mcwherter.net/Portals/McWherter/9780131479418.jpg" width="245" height="324" title="Agile estimating and planning" ></p>

<h2>Por qué lo he leído</h2>

<p>últimamente estoy leyendo muchos libros relacionados con las metodologías ágiles, y en muchos de ellos se hacía referencia a este libro, así que pensé que debía ser un libro imprescindible. Y así es.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>Esperaba encontrar muchas técnicas de estimación, métricas para controlar que una planificación no se desvía del plan inicial y cosas así.</p>

<p>También esperaba encontrar una serie de consejos a aplicar a la hora de hacer las estimaciones, y la verdad es que el libro no me ha defraudado para nada.</p>

<h2>Qué encontre</h2>

<p>Encontré todo eso y mucho más. Descubrí nuevos conceptos (ver último apartado) y conocí de primera mano técnicas que hasta ahora solo había conocido por encima, como los diagramas <em>burndown</em>, para registrar los puntos de historia que se han implementado en una iteración.</p>

<h2>Conclusiones</h2>

<p>El libro me ha encantado. Creo que es una lectura obligatoria para cualquier persona que esté relacionada con las planificaciones de los proyectos software. Estoy seguro de que aprendería muchísimas cosas. Claro, que si eres desarrollador también te conviene conocer las técnicas explicadas en este libro.</p>

<p>Una cosa que me ha gustado muchísimo es que al final de cada capítulo hay un resumen exponiendo las ideas principales del capítulo. Muy útil por si tienes que ojearlo una vez leído.</p>

<h2>Pasajes que quiero recordar de este libro</h2>

<blockquote><p>En 1981, Barry Boehm dibujó su primera versión del <a href="https://raw.github.com/tapichu/scrum/gh-pages/img/03%20-%20cono%20de%20incertidumbre.png"><em>cono de incertidumbre</em></a>. La imagen del enlace muestra los rangos iniciales de incertidumbre en diferentes puntos de un proceso de desarrollo secuencial ("en cascada")</p>

<p>El "cono de incertidumbre" se va estrechando conforme el proyecto va avanzando.</p>

<p>Un plan <em>ágil</em> is aquel que no es que no queramos cambiar, sino que estamos ansiosos de hacerlo, y queremos
cambiarlo porque eso significa que hemos aprendido algo o que hemos sorteado una dificultad.</p>

<p>Las funcionalidades son la unidad de valor para el cliente, y no las actividades, aunque nosotros
planificamos basándonos en actividades, por eso muchos proyectos fallan.</p>

<p>La multitarea se convierte en un problema para los proyectos planificados tradicionalmente porque
incentiva enfocarse en la máxima utilzizacion de todos los individuos en lugar de mantener un margen
suficiente para poder manejar la variabilidad típica de las tareas de los proyectos software.</p>

<p>Un equipo <em>ágil</em> trabaja como una unidad, no hay espacio para la mentalidad "ahí lo dejo y ya está". Un
buen equipo <em>ágil</em> debe tener una mentalidad de estamos todos juntos en esto.</p>

<p>Las <em>historias de usuario</em> son una técnica poco pesada para expresar los requisitos del software.</p>

<p>Los equipos ágiles planifican a tres niveles: release, iteración y dia. <strong>release</strong>: determina el alcance,
las fechas y los recursos de un proyecto. <strong>iteración</strong>: identfica tareas de alta prioridad que el equipo
debería realizar en la siguiente iteración. <strong>dia</strong>: coordina el trabajo y sincroniza los esfuerzos
del dia a dia.</p>

<p>Los proyectos se deberían ver como una forma de generar un flujo de nuevas capacidades y conocimientos,
conocimientos sobre el producto y sobre el proyecto (equipo, tecnología, personas, ...)</p>

<p>Al igual que en los restaurantes las medidas de las raciones son relativas entre sí, en el mundo software
sólo necesito saber si una funcionalidad es mayor o menor respecto a otra.</p>

<p>Además de saber que las estimaciones son más fiables si son indicadas por aquellos que realizarán la tarea,
las estimaciones son aún mejores si se basan en la colaboración del equipo al completo.</p>

<p>Las tres formas más comunes de dar una estimación son: opinión de un experto, analogía y disgregación (o
dividir una tarea en otras más pequeñas).</p>

<p>La cantidad de tiempo que llevará implementar una funcionalidad es función de su tamaño (puntos historia) y
el ratio de progreso del equipo (velocidad)</p>

<p>Se deben tener en cuenta cuatro factores a la hora de priorizar tareas: valor de las funcionalidades, coste
del desarrollo, nuevo conocimiento que generará y riesgos que eliminará la realización de la tarea.</p>

<p>Kano (link al torpedo este, con imagen y todo si es posible) nos da una forma de separar funcionalidades en tres categorías: indispensables,
lineales y excitantes/sorprendentes.</p>

<p>Entregar un subconjunto coherente de todas las capas de una funcionalidad is siempre mejor que entregar
una capa entera pero sin conexión con el resto de ellas.</p>

<p>Así como un corazón bate a un ritmo regular que mantienen el cuerpo funcionando, un duración de iteración
fija proporciona una constante que ayuda a establecer un ritmo de desarrollo y entregas ~ Simon Baker</p>

<p>Un <em>buffer</em> es un margen de error alrededor de una estimación. Hay dos tipos de buffers: de funcionalidad
(un 25-40% de las funcionalidades son opcionales) y de planificación (se añade un 30% de tiempo a lo que
creo que me va a costar).</p>

<p>Un buffer de planificación no es un alargamiento consciente. Las personas alargan conscientemente sus
estimaciones si creen que se les reprochará no terminar a tiempo. Un buffer es un margen de seguridad
necesario que sumar al conjunto de estimaciones.</p>

<p>Algo que el autor encuentra muy útil como trabajo a realizar antes de una iteración son las <em>condiciones de
satisfacción</em> de las historias de usuario a desarrollar en dicha iteración por parte del cliente.</p>

<p>Un <em>release burndown chart</em> muestra la cantidad de trabajo que queda por realizar al inicio de cada iteración.
Esto se convierte en un indicador visual de cómo y a qué velocidad se está acercando el equipo al objetivo
del proyecto.</p>

<p>La variabilidad es parte da cada estimación. No importa cuánto esfuerzo se ponga en mejorarlas, un equipo nunca
será capaz de estimar perfectamente.</p>

<p>No gestionar la velocidad individualmente. Se debe incentivar siempre que sea posible que todos los miembros
del equipo trabajen como un todo, como un único equipo.</p>

<p>Las estimaciones y planificaciones ágiles funcionan porque se separan las estimaciones de tamaño y de duración:
puntos historia * velocidad = duración</p>

<p>Las planficaciones tradicionales se enfocan en las tareas para crear el producto, mientras que las planificaciones
ágiles se centran en las funcionalidades que desea el usuario.</p>

<p>Cuando creamos un plan al principio de un proyecto y no lo actualizamos con los nuevos conocimiento adquiridos,
estamos perdiendo la oportunidad de sincronizar nuestro proyecto con la realidad.</p></blockquote>

<h2>Conceptos</h2>

<ul>
<li><a href="http://gzurita.blogspot.com.es/2006/07/idea-valiosa-el-cono-de-incertidumbre.html">Cono de incertidumbre</a></li>
<li><a href="http://ow.ly/hFQSx">Velocidad</a></li>
<li><a href="www.youtube.com/watch?v=lGXLe9RiJyY">Commitment-driven iteration planning</a>:
Una aproximación guiado por el compromiso is una alternativa a la
planificación de la iteración. El equipo va añadiendo historias a la iteración de una en una mientras que ellos
se puedan comprometer a entregarlas. Las historias son seleccionadas, descompuestas en tareas y éstas estimadas.
De una en una. En la aproximación de planificar basándose en la velocidad, se eligen un conjunto de historias
cuyas estimaciones sean iguales o menores que la velocidad del equipo.</li>
<li><a href="http://stackoverflow.com/a/3700855/1111676">Condiciones de satisfacción</a></li>
<li><a href="https://www.google.es/search?q=burndown+bar+chart&amp;tbm=isch">burndown bar chart</a></li>
</ul>


<h2>Otras lecturas y enlaces relacionadas</h2>

<ul>
<li><a href="http://jmbeas.es/guias/">Guía de conceptos ágiles</a></li>
<li><a href="http://twitter.com/joserra_diaz/">Jose Ramón Díaz</a>, de <a href="http://www.agilar.org/">Agilar</a>,
habla de <a href="http://najaraba.blogspot.com.es/2013/02/la-estimacion-agil-de-proyectos-puntos.html">estimaciones ágiles</a>
en su blog.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Agile principles, patterns and practices in C#]]></title>
    <link href="http://rchavarria.github.io/blog/2012/11/22/agile-principles-patterns-and-practices-in-c/"/>
    <updated>2012-11-22T11:22:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2012/11/22/agile-principles-patterns-and-practices-in-c</id>
    <content type="html"><![CDATA[<h4>Agile principles, patterns and practices in C#</h4>




<h5>Robert C. Martin</h5>


<p><img class="right" src="http://vig-fp.prenhall.com/bigcovers/0131857258.jpg" width="300" height="222" title="Agile principles, patterns and practices" ></p>

<h2>Por qué lo he leído</h2>


<p>Lo he leido porque me he encontrado referencias a este libro en libros anteriores que he leído, en blogs sobre desarrollo de software que suelo leer y en otros muchos sitios relacionados con el software. Si encuentro tantas referencias, será por algo, ¿no? Además, el autor es muy conocido y valorado, así que no había excusa para no leerlo.</p>

<!-- more -->




<h2>Qué esperaba</h2>


<p>Me esperaba un libro de <em>Uncle Bob™</em>. Ya he leído alguno del mismo autor, y me gusta su estilo. Algunas veces me parece un poco extremista, pero creo que es así porque cree en lo que hace y eso es lo que predica. Cuando creo que exagera, no le hago mucho caso y sigo hacia adelante, ya está.</p>

<p>Esperaba una descripción de las metodologías ágiles aplicadas al momento de escribir software y encontré ...</p>

<h2>Qué encontré</h2>


<p>... un pedazo de ladrillo! Me asusté cuando vi la extensión del libro, pero enseguida entendí el porqué. El libro está lleno de diagramas <a href="http://es.wikipedia.org/wiki/Lenguaje_Unificado_de_Modelado">UML</a> y de código fuente (primero los tests, por supuesto). Así que es normal que sea tan largo.</p>

<p>En cuanto al contenido, me gustó mucho la descripción que hace de muchos patrones de diseño, (incluso he aprendido alguno que no conocía). En el libro también podrás encontrar una descripción detallada de los principios <a href="http://es.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a> y de otros principios sobre cómo organizar y empaquetar los distintos componentes de tu aplicación (clases, paquetes, namespaces, lo que sea).</p>

<h2>Conclusiones</h2>


<p>Aunque el libro sea muy extenso, me ha gustado por varias razones:</p>

<ul>
    <li>He aprendido nuevos patrones de diseño.</li>
    <li>He podido profundizar sobre el patrón Model-View-Controller (ver enlaces más abajo).</li>
    <li>He encontrado una descripción muy detallada de los principios <a href="http://es.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID.</a></li>
</ul>


<h2>Pasajes que quiero recordar de este libro</h2>


<blockquote>Un módulo que es difícil de cambiar, está roto y necesita ser arreglado, aunque funcione.</blockquote>


<blockquote>Un módulo que no comunica está roto y necesita ser arreglado.</blockquote>


<blockquote>Cuanto más conocen los programadores sobre <em>todo</em> el proyecto, más sano y más informado está el equipo que lo desarrolla.</blockquote>


<blockquote>Es el <em>big picture</em> lo que mantiene unido el sistema. Es la visión del sistema lo que hace obvia la localización y la forma de los módulos individuales. Si la forma de un módulo es inconsistente con la <em>metáfora</em>, es el módulo quien está mal, no la metáfora.</blockquote>


<blockquote>Al final, el código fuente <em>es</em> el diseño.</blockquote>


<blockquote>Se sabe que el software se está pudriendo cuando empieza a mostrar alguno de los siguientes síntomas: rigidez, fragilidad, inmovilidad, viscosidad, complejidad innecesaria, repetición innecesaria u opacidad.</blockquote>


<blockquote>El elemento más volatil en los proyectos software son los requisitos. Vivimos en un mundo de requisitos cambiantes, y nuestro trabajo es estar seguros de que nuestros software puede sobrevivir a esos cambios, así que no culpes a los requisitos cambiantes por los fallos en el software.</blockquote>


<blockquote>Los principios SOLID: <strong>S</strong>ingle responsability principle, <strong>O</strong>pen close principle, <strong>L</strong>iskov substitution principle, <strong>I</strong>nterface segregation principle, <strong>D</strong>ependency inversion principle.</blockquote>


<blockquote>Un motivo de cambio es un motivo de cambio sólo cuando el cambio ocurre, mientras tanto no.</blockquote>


<blockquote><em>Strategy </em>and <em>Template method</em> son las formas más comunes de satisfacer Open closed principle. Estos patrones representan una clara separación de la funcionalidad genérica de la implementación detallada de esa funcionalidad.</blockquote>


<blockquote><em>Fool me once, shame on you. Fool me twice, shame on me.</em> Inicialmente, escribimos nuestro código pensando que no va a cambiar. Cuando ocurre un cambio, implementamos abstraciones que nos protegen de futuros cambios de esa misma naturaleza.</blockquote>


<blockquote>Liskov substitution principle nos lleva a una importante conclusión: un modelo, visto aisladamente, no puede ser validado significativamente. La validez de un modelo puede ser expresado solo en términos de sus clientes.</blockquote>


<blockquote>Liskov substitution principle clarifica que en la programación orientada a objetos, una relación de herencia pertenece al comportamiento que puede ser asumido y que los clientes dependen de este comportamiento, lo contrario de lo que normalmente se cree, que la herencia pertenece al estado</blockquote>


<blockquote>El diseño de grandes sistemas depende críticamente de un buen diseño de componentes (paquetes, entregables, ...), de esta forma, los equipos individuales puede enfocarse en componentes aislados en lugar de preocuparse por el sistema completo.</blockquote>


<blockquote>Las interfaces pertenecen al cliente que las usa, no a la implementación. El enlace lógico entre el cliente y el interfaz es más fuerte que la relación entre el interfaz y sus implementaciones. Es tan fuerte que no tiene sentido desplegar el cliente sin el interfaz, pero sí que lo tiene desplegar el interfaz sin sus implementaciones.</blockquote>




<h2>Otras lecturas y enlaces relacionadas</h2>


<ul>
    <li>[pdf] <a href="http://www.objectmentor.com/resources/articles/TheHumbleDialogBox.pdf">The humble dialog box</a>: cómo separar la lógica de negocio de la interfaz gráfica, de Michael Feathers.</li>
    <li><a href="http://www.martinfowler.com/eaaDev/ModelViewPresenter.html">Patrón model-view-presenter</a>: artículo de Martin Fowler que me llevó a éste de <a href="http://www.martinfowler.com/eaaDev/uiArchs.html">Arquitecturas GUI</a>.</li>
    <li><a href="http://apagayvuelveaencender.blogspot.com.es/2012/11/metodologias-agiles-me-las-creo-o-no-me.html">Metodologías ágiles: ¿me las creo o no me las creo?</a>: excelente post de <a href="http://twitter.com/andres_viedma">Andrés Viedma</a> que me viene ni al pelo como enlace relacionado con el libro y donde se explican los cuatro principios del desarrollo de software ágil</li>
    <li>Hace ya un tiempo, leí sobre <a href="http://rchavarria.github.io/blog/2010/03/04/principios-y-patrones-de-diseno/">principios y patrones de diseño</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
