<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: continuous improvement | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/continuous-improvement/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2016-09-11T22:56:03+02:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mejora contínua y análisis estático de código]]></title>
    <link href="http://rchavarria.github.io/blog/2014/05/05/mejora-continua-y-analisis-estatico-de-codigo/"/>
    <updated>2014-05-05T20:00:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2014/05/05/mejora-continua-y-analisis-estatico-de-codigo</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2014/phpcs-small.png" width="350" height="140" title="Evolución del análisis estático de código" ></p>

<p>En una de las últimas retrospectivas de mi equipo de desarrollo, estuvimos
hablando sobre la mejora contínua, y qué podríamos hacer sobre ella. Afortunadamente
usamos <em>Jenkins</em> como servidor de integración contínua y hace ya tiempo configuré
un proyecto en dicha herramienta para realizar análisis estático de código frecuentemente.</p>

<p>Pero hasta ahora no habíamos tomado ninguna decisión sobre qué hacer con ella. Y
en esta retro surgió la oportunidad.</p>

<!-- more -->


<h2>La herramienta</h2>

<p>Como herramienta de análisis estático de código usamos
<a href="https://github.com/squizlabs/PHP_CodeSniffer">PHP_CodeSniffer</a>. La razón
principal es que es una herramienta adecuada al lenguaje que queremos analizar, y
existe un proyecto que integra esta herramienta entre otras con Jenkins
(<a href="http://phpqatools.org">PHP QA Tools</a>).</p>

<p>Una vez instalada y configurada, activamos todas las reglas de estilo disponibles
en la herramienta. Estas reglas incluyen comprobaciones para nombrado de funciones,
nombrado de ficheros, uso de constantes en PHP como <code>true</code> o <code>false</code>, o ciertas
reglas de espaciado: después del nombre de función, alineación del operador de
asignación. Multitud de ellas.</p>

<blockquote><p>Si no puedes medirlo, no puedes mejorarlo</p></blockquote>

<h2>Violaciones del estándar de código</h2>

<p><img class="center" src="/images/2014/phpcs-large.png" title="Descenso del número de errores" ></p>

<p>En el momento de la conversación sobre la mejora contínua nos encontrábamos en
el máximo que se aprecia en el gráfico, unas 8000 violaciones de reglas de
estilo.</p>

<p>Y nos pusimos manos a la obra. Después de un pequeño análisis por nuestra parte,
y unos pocos diálogos (la palabra discusiones tiene un pequeño significado de
lucha que no encaja en esta situación), conseguimos bajar ese número a menos de
30. Por lo tanto, está claro que hemos conseguido alguna <strong>mejora</strong>.</p>

<h2>Qué mejoras obtuvimos</h2>

<p>En el pequeños análisis realizado por nosotros, descubrimos que algunas reglas de
estilo que teníamos activadas resultaban contradictorias. Mientras que una
obligaba a abrir llaves en la misma línea que la definición de la función:</p>

<pre><code>public function doSomething() {
</code></pre>

<p>existía otra regla que obligaba a abrir llaves en una línea nueva:</p>

<pre><code>public function doSomething()
{
</code></pre>

<p>Por lo tanto, una de las dos había que desactivarla, ¿pero cuál?. He aquí la
verdadera mejora. La mejora no es utilizar una regla u otra, sino alcanzar un
consenso dentro del equipo y decidir qué estilo queremos seguir a la hora de
escribir código.</p>

<p>Algunas otras reglas nos permitieron detectar qué clases necesitaban ser
refactorizadas. Por ejemplo, si un método tiene una <em>complejidad ciclomática</em>
elevada o si un método está escrito con demasiados niveles de anidamiento.</p>

<p>Otras reglas simplemente nos enfrentaron a la toma de ciertas decisiones:</p>

<ul>
<li>Cómo queremos organizar nuestros ficheros</li>
<li>Cómo queremos dar el nombre a nuestros métodos</li>
<li>Cómo queremos indentar nuestro código</li>
</ul>


<h2>Conclusión</h2>

<p>No me importa volver a repetirlo, la verdadera mejora no surge de seguir una
regla u otra a la hora de escribir código. La verdadera mejora surge de las
conversaciones, diálogos y <em>discusiones</em> entre los miembros del equipo.</p>

<p>¿Y dónde está la parte de <em>contínua</em>? Se encuentra en el servidor de integración
contínua. Nuestro código es analizado contínuamente, y en el caso de que haya
un aumento significativo de violaciones de reglas de estilo en nuestro código,
seremos avisados y podremos tomar la decisión sobre si retomamos el control
o lo dejamos para más adelante.</p>

<h2>Referencias</h2>

<ul>
<li><a href="https://es.wikipedia.org/wiki/Proceso_de_mejora_continua">Mejora contínua</a></li>
<li><a href="https://es.wikipedia.org/wiki/Integraci%C3%B3n_continua">Integración contínua</a></li>
<li><a href="https://en.wikipedia.org/wiki/Static_code_analysis">Análisis estático de código</a>
(inglés)</li>
</ul>

]]></content>
  </entry>
  
</feed>
