<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: team discussion | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/team-discussion/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2017-12-12T22:19:40+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tests de integración lentos]]></title>
    <link href="http://rchavarria.github.io/blog/2017/04/17/tests-de-integracion-lentos/"/>
    <updated>2017-04-17T21:56:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/04/17/tests-de-integracion-lentos</id>
    <content type="html"><![CDATA[<p>Es una sensación extraña, pero me pasa a veces. Se supone que las máquinas, los ordenadores, son más rápidos que nosotros haciendo según qué cosas. Aún así, hay muchas veces que me desespero. Seguro que más de una vez te has puesto de los nervios porque tu ordenador tardaba mucho en finalizar una tarea: copiar un fichero, abrir un documento, cargar una página web,... Pues una cosa que me exaspera mientras estoy trabajando es esperar a que los tests terminen de ejecutarse.</p>

<p>El post de hoy va de una historia de abuelo cebolleta: hace un tiempo, tuvimos una <em>discusión</em> en la oficia, dentro del equipo con el que trabajo. Estuvimos discutiendo sobre cómo hacer nuestros tests de integración más rápidos.</p>

<p>Por aquel momento teníamos un gran número de tests de integración, más o menos emparejado con el número de tests unitarios. Bueno, sí, ya empezamos mal. Estoy de acuerdo con la teoría de que es mucho mejor tener una <a href="https://martinfowler.com/bliki/TestPyramid.html"><em>pirámide</em> de tests</a>, no un <a href="https://watirmelon.blog/2012/01/31/introducing-the-software-testing-ice-cream-cone/">cucurucho de tests</a>. Pero esa era nuestra realidad. La verdad es que a día de hoy, hemos conseguido tener muchos más tests unitarios que de integración, pero esa es otra historia.</p>

<!-- more -->


<p>Evidentemente, cuantos más tests de integración tenemos, más tiempo tardan éstos en ejecutarse. Pero eso no es excusa para quedarnos de brazos cruzados y esperar un cuarto de hora a que terminen de pasar los tests. La verdad es que sí, que tardan un rato en completarse. Son de integración, y el que no accede a la base de datos, accede a disco, y el que no hace una petición HTTP, el que no... Coges la idea ¿verdad? Integración. Acceso a sistemas externos. Len ti tud. ¡Ay!</p>

<p>J.B. Rainsberger ya lo lleva diciendo mucho tiempo: los <a href="http://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam">tests de integración son un dolor</a>, y además, hacen que cada vez vayas más lento. Pero eso no quita que no sea necesario un cierto número de tests de integración.</p>

<!-- imagen gif animado de alguna chorrada de test unitario pero no de integración -->


<div style="width: 640px; margin: 0 auto">
  <iframe src='https://gfycat.com/ifr/HotOrangeCoypu' frameborder='0' scrolling='no' width='640' height='640' allowfullscreen></iframe>
</div>


<p>Y entonces... ¿qué puntos se discutían?</p>

<p>Por una lado cada tests individual se encarga de dejar la base de datos tal y como estaba antes de ejecutarse (propiedad de <em>aislamiento</em> de los tests). Pero, ¿por qué? ¿Qué tal si al lanzar los tests se crea una nueva base de datos? Limpia, desde cero, y los tests la dejan en un estado cualquiera, no necesariamente limpia. De esta forma, los tests serán más rápidos, ya que se ahorran unas cuantas llamadas para limpiar datos. Por supuesto, utilizaríamos una base de datos distinta a la de cualquier entorno existente, no queremos que los tests interfieran con ellos.</p>

<p>Pero había algunos problemas. Los datos <em>basura</em> de unos tests podrían interferir en otros tests. O los últimos en ejecutarse podrían depender de tests anteriores y no darnos cuenta.</p>

<p>Por otro lado, si descuidamos los tests y no hacemos que limpien todo, terminaremos por ser vagos y hacer malos tests. Podemos incluso tener errores al borrar algunos registros. Total, nos da igual, en la siguiente ejecución, los tests van a empezar con una base de datos limpia.</p>

<p>También, utilizando la misma base de datos que en desarrollo, nos aseguramos que testeamos algo real, algo que usamos en nuestro día a día (aunque tenga sus diferencias con la de producción, por supuesto). Si lo hacemos contra otra base de datos, podemos estar desactualizados en algunas configuraciones, podemos estar falseando algunas características.</p>

<p>Además de todo eso, también surgieron ideas curiosas, por ejemplo, paralelizar la ejecución de los tests. Quizá así podríamos acelerar su ejecución. Por lo pronto, lo que sí hicimos para mejorar el tiempo de ejecución fue minimizar al máximo en número de conexiones a la base de datos desde los tests. No recuerdo la cifra, pero redujimos por lo menos un tercio el tiempo de ejecución de los tests de integración.</p>

<p>Y tú, ¿qué crees? ¿qué sería mejor? ¿utilizar una base de datos nuevecita para cada ejecución de los tests?</p>

<h2>Referencias</h2>

<ul>
<li><a href="https://martinfowler.com/bliki/TestPyramid.html">Pirámide de tests</a>, en contraposición al <a href="https://watirmelon.blog/2012/01/31/introducing-the-software-testing-ice-cream-cone/">cucurucho de tests</a></li>
<li>Los <a href="http://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam">tests de integración son un dolor</a></li>
<li><a href="http://agileinaflash.blogspot.com.es/2009/02/first.html">Propiedades FIRST</a> de los tests</li>
</ul>

]]></content>
  </entry>
  
</feed>
