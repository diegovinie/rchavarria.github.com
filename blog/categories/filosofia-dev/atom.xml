<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: filosofia dev | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/filosofia-dev/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2016-11-28T23:02:39+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Agile principles, patterns and practices in C#]]></title>
    <link href="http://rchavarria.github.io/blog/2012/11/22/agile-principles-patterns-and-practices-in-c/"/>
    <updated>2012-11-22T11:22:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2012/11/22/agile-principles-patterns-and-practices-in-c</id>
    <content type="html"><![CDATA[<h4>Agile principles, patterns and practices in C#</h4>




<h5>Robert C. Martin</h5>


<p><img class="right" src="http://vig-fp.prenhall.com/bigcovers/0131857258.jpg" width="300" height="222" title="Agile principles, patterns and practices" ></p>

<h2>Por qué lo he leído</h2>


<p>Lo he leido porque me he encontrado referencias a este libro en libros anteriores que he leído, en blogs sobre desarrollo de software que suelo leer y en otros muchos sitios relacionados con el software. Si encuentro tantas referencias, será por algo, ¿no? Además, el autor es muy conocido y valorado, así que no había excusa para no leerlo.</p>

<!-- more -->




<h2>Qué esperaba</h2>


<p>Me esperaba un libro de <em>Uncle Bob™</em>. Ya he leído alguno del mismo autor, y me gusta su estilo. Algunas veces me parece un poco extremista, pero creo que es así porque cree en lo que hace y eso es lo que predica. Cuando creo que exagera, no le hago mucho caso y sigo hacia adelante, ya está.</p>

<p>Esperaba una descripción de las metodologías ágiles aplicadas al momento de escribir software y encontré ...</p>

<h2>Qué encontré</h2>


<p>... un pedazo de ladrillo! Me asusté cuando vi la extensión del libro, pero enseguida entendí el porqué. El libro está lleno de diagramas <a href="http://es.wikipedia.org/wiki/Lenguaje_Unificado_de_Modelado">UML</a> y de código fuente (primero los tests, por supuesto). Así que es normal que sea tan largo.</p>

<p>En cuanto al contenido, me gustó mucho la descripción que hace de muchos patrones de diseño, (incluso he aprendido alguno que no conocía). En el libro también podrás encontrar una descripción detallada de los principios <a href="http://es.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a> y de otros principios sobre cómo organizar y empaquetar los distintos componentes de tu aplicación (clases, paquetes, namespaces, lo que sea).</p>

<h2>Conclusiones</h2>


<p>Aunque el libro sea muy extenso, me ha gustado por varias razones:</p>

<ul>
    <li>He aprendido nuevos patrones de diseño.</li>
    <li>He podido profundizar sobre el patrón Model-View-Controller (ver enlaces más abajo).</li>
    <li>He encontrado una descripción muy detallada de los principios <a href="http://es.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID.</a></li>
</ul>


<h2>Pasajes que quiero recordar de este libro</h2>


<blockquote>Un módulo que es difícil de cambiar, está roto y necesita ser arreglado, aunque funcione.</blockquote>


<blockquote>Un módulo que no comunica está roto y necesita ser arreglado.</blockquote>


<blockquote>Cuanto más conocen los programadores sobre <em>todo</em> el proyecto, más sano y más informado está el equipo que lo desarrolla.</blockquote>


<blockquote>Es el <em>big picture</em> lo que mantiene unido el sistema. Es la visión del sistema lo que hace obvia la localización y la forma de los módulos individuales. Si la forma de un módulo es inconsistente con la <em>metáfora</em>, es el módulo quien está mal, no la metáfora.</blockquote>


<blockquote>Al final, el código fuente <em>es</em> el diseño.</blockquote>


<blockquote>Se sabe que el software se está pudriendo cuando empieza a mostrar alguno de los siguientes síntomas: rigidez, fragilidad, inmovilidad, viscosidad, complejidad innecesaria, repetición innecesaria u opacidad.</blockquote>


<blockquote>El elemento más volatil en los proyectos software son los requisitos. Vivimos en un mundo de requisitos cambiantes, y nuestro trabajo es estar seguros de que nuestros software puede sobrevivir a esos cambios, así que no culpes a los requisitos cambiantes por los fallos en el software.</blockquote>


<blockquote>Los principios SOLID: <strong>S</strong>ingle responsability principle, <strong>O</strong>pen close principle, <strong>L</strong>iskov substitution principle, <strong>I</strong>nterface segregation principle, <strong>D</strong>ependency inversion principle.</blockquote>


<blockquote>Un motivo de cambio es un motivo de cambio sólo cuando el cambio ocurre, mientras tanto no.</blockquote>


<blockquote><em>Strategy </em>and <em>Template method</em> son las formas más comunes de satisfacer Open closed principle. Estos patrones representan una clara separación de la funcionalidad genérica de la implementación detallada de esa funcionalidad.</blockquote>


<blockquote><em>Fool me once, shame on you. Fool me twice, shame on me.</em> Inicialmente, escribimos nuestro código pensando que no va a cambiar. Cuando ocurre un cambio, implementamos abstraciones que nos protegen de futuros cambios de esa misma naturaleza.</blockquote>


<blockquote>Liskov substitution principle nos lleva a una importante conclusión: un modelo, visto aisladamente, no puede ser validado significativamente. La validez de un modelo puede ser expresado solo en términos de sus clientes.</blockquote>


<blockquote>Liskov substitution principle clarifica que en la programación orientada a objetos, una relación de herencia pertenece al comportamiento que puede ser asumido y que los clientes dependen de este comportamiento, lo contrario de lo que normalmente se cree, que la herencia pertenece al estado</blockquote>


<blockquote>El diseño de grandes sistemas depende críticamente de un buen diseño de componentes (paquetes, entregables, ...), de esta forma, los equipos individuales puede enfocarse en componentes aislados en lugar de preocuparse por el sistema completo.</blockquote>


<blockquote>Las interfaces pertenecen al cliente que las usa, no a la implementación. El enlace lógico entre el cliente y el interfaz es más fuerte que la relación entre el interfaz y sus implementaciones. Es tan fuerte que no tiene sentido desplegar el cliente sin el interfaz, pero sí que lo tiene desplegar el interfaz sin sus implementaciones.</blockquote>




<h2>Otras lecturas y enlaces relacionadas</h2>


<ul>
    <li>[pdf] <a href="http://www.objectmentor.com/resources/articles/TheHumbleDialogBox.pdf">The humble dialog box</a>: cómo separar la lógica de negocio de la interfaz gráfica, de Michael Feathers.</li>
    <li><a href="http://www.martinfowler.com/eaaDev/ModelViewPresenter.html">Patrón model-view-presenter</a>: artículo de Martin Fowler que me llevó a éste de <a href="http://www.martinfowler.com/eaaDev/uiArchs.html">Arquitecturas GUI</a>.</li>
    <li><a href="http://apagayvuelveaencender.blogspot.com.es/2012/11/metodologias-agiles-me-las-creo-o-no-me.html">Metodologías ágiles: ¿me las creo o no me las creo?</a>: excelente post de <a href="http://twitter.com/andres_viedma">Andrés Viedma</a> que me viene ni al pelo como enlace relacionado con el libro y donde se explican los cuatro principios del desarrollo de software ágil</li>
    <li>Hace ya un tiempo, leí sobre <a href="http://rchavarria.github.io/blog/2010/03/04/principios-y-patrones-de-diseno/">principios y patrones de diseño</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qu&eacute; es un arquitecto de software?]]></title>
    <link href="http://rchavarria.github.io/blog/2010/02/12/que-es-un-arquitecto-de-software/"/>
    <updated>2010-02-12T02:12:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2010/02/12/que-es-un-arquitecto-de-software</id>
    <content type="html"><![CDATA[<p>Hace días descubrí un artículo en InfoQ titulado “<a href="http://www.infoq.com/articles/brown-are-you-a-software-architect">Eres un arquitecto de software?</a>” de <a href="http://www.infoq.com/author/Simon-Brown">Simon Brown</a>, y hoy he leído una pequeña reseña en <a href="http://www.javahispano.org/contenidos/es/que_es_un_arquitecto_de_sw/">javaHispano</a>, lo cuál me ha recordado que tenía pendiente escribir algo sobre él. En él, Simon nos expone su idea de lo que un arquitecto de software debería ser, o cómo un desarrollador puede llegar a ser arquitecto.</p>

<p>La idea más importante del artículo creo que es que ser arquitecto <strong>es un rol, no un rango</strong>, por lo que el arquitecto se debe comportar como tal y ganarse el respeto del resto del equipo, no porque un papel diga que es el arquitecto los demás deban reverenciarle.</p>

<p>Según Simon, la arquitectura de un proyecto puede dividirse en dos fases: definición y entrega (<em>delivery</em>):</p>

<p>En cuanto a la fase de definición me gustaría destacar las siguientes ideas:</p>

<ul>
    <li>Definir una arquitectura es crear   una estructura, líneas de trabajo, principios y liderazgo técnico.</li>
    <li>La selección de una tecnología    es sobretodo gestionar riesgos.</li>
    <li>Testear la arquitectura para    probar que realmente funciona.</li>
</ul>


<p>Y en cuanto a la fase de entrega:</p>

<ul>
    <li>Es el arquitecto quien tiene la     visión global del proyecto y quien tiene que defenderlo tanto  frente al cliente como a los desarrolladores.</li>
    <li>Es el arquitecto quien debe asumir  el liderazgo técnico.</li>
    <li>Es el arquitecto quien debe     promover e incentivar el continuo aprendizaje del sistema a los     desarrolladores.</li>
    <li>Es el arquitecto quien debe     asegurar la calidad del código.</li>
    <li>Es el arquitecto debe escribir  código.</li>
</ul>


<p>En definitiva, el arquitecto debe asumir un papel activo, y comprender que es el líder técnico del equipo y como tal debe ser un referente dentro del equipo.</p>

<p>Yo estoy trabajando duramente para ser este tipo de arquitecto. Y tú, eres arquitecto de software?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[El comunicador t&iacute;mido]]></title>
    <link href="http://rchavarria.github.io/blog/2009/12/16/el-comunicador-timido/"/>
    <updated>2009-12-16T12:16:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2009/12/16/el-comunicador-timido</id>
    <content type="html"><![CDATA[<p>He encontrado por ahí una presentación muy interesante que habla acerca de por qué una persona tímida puede ser una referencia para mucha gente (<a href="http://www.slideshare.net/sachac/the-shy-connector">Sacha Chua - The shy connector</a>):</p>

<p>Eres tímido? No te preocupes, Sacha Chua te da unos consejos, no para superar tu timidez, eres así y no hay nada de malo en ello. Los consejos son para usar tu timidez para ayudar a la gente y convertirte en un gran comunicador.</p>

<!-- more -->




<iframe src='http://www.slideshare.net/slideshow/embed_code/1879213' width='479' height='393'></iframe>


<p>Los puntos que me han parecido más importantes para destacarlos son:</p>

<ol>
    <li>Se trata de ayudar a los demás, así como de aprender y compartir.</li>
    <li>Busca formas de ayudar a la gente con la que mantienes alguna relación, y haz un seguimiento de los temas que les preocupan para poder ayudarles.</li>
    <li>De la misma forma, deja que los demás te ayuden</li>
    <li>Cuanto más lo uses, mejor te sentirás.</li>
</ol>

]]></content>
  </entry>
  
</feed>
