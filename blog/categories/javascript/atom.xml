<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2015-12-15T21:29:36+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Aprendiendo Ionic 2]]></title>
    <link href="http://rchavarria.github.io/blog/2015/11/15/aprendiendo-ionic-2/"/>
    <updated>2015-11-15T22:49:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/11/15/aprendiendo-ionic-2</id>
    <content type="html"><![CDATA[<p>Recientemente se ha celebrado la conferencia <a href="http://angularconnect.com/">Angular Connect</a> en Londres,
donde se ha hablado mucho de <a href="https://angular.io/">Angular 2</a>, framework de desarrollo de
aplicaciones web en el que estoy muy interesado (de hecho estoy desarrollando
una pequeña aplicación para diversión de mi hijo, <a href="https://play.google.com/store/apps/details?id=es.rchavarria.englishbyeinar">English by Einar</a>). También
estoy enteresado en el framework <a href="http://ionicframework.com/">Ionic</a>, que aúna los proyectos de Angular y
<a href="http://cordova.apache.org/">Cordova</a> y que permite desarrollar aplicaciones para móviles con herramientas
de desarrollo web: HTML5, CSS3 y JavaScript.</p>

<p>En dicha conferencia se hizo público la versión alpha de <a href="http://ionicframework.com/docs/v2/">Ionic 2</a>, la versión
de Ionic que incluye la nueva versión de Angular. Ionic es un framework para
desarrollo de aplicaciones cliente móviles híbridas con tecnologías web y en su
versión 2 siguen con la filosofía de estar muy preocupados por el rendimiento.
En este post veremos lo realmente fácil que es comenzar a desarrollar con estas
herrmientas.</p>

<p><img class="center" src="/images/2015/ionic-framework.jpg" width="350" height="185" title="Ionic Framework" ></p>

<!-- more -->


<h2>Requisitos</h2>

<p>Ionic se apoya en Cordova y en las plataformas de desarrollo nativas
dependiendo de la plataforma móvil en la que estemos enfocados, normalmente
Android o iOS. Antes de comenzar a desarrollar con él deberemos actualizar a
las versiones más modernas posibles, ya que la versión alpha de Ionic 2
requiere de los últimos avances.</p>

<p>En mi caso particular, he necesitado actualizar mi SDK de Android para Linux:</p>

<p><code>
rchavarria@home$ ./AndroidSDK/tools/android sdk
</code></p>

<p>para abrir la interfaz gráfica y poder actualizar algunos paquetes del SDK.</p>

<p>Y también he necesitado actualizar las versiones de NodeJS (a través de <code>nvm</code>,
Node Version Manager), la herramienta <code>npm</code> y Cordova:</p>

<p><code>
rchavarria@home$ nvm install v5.0.0
rchavarria@home$ npm install -g npm
rchavarria@home$ npm install -g cordova@5.3.3
</code></p>

<p>Por último, instalar la versión alpha de Ionic 2. No temas, no hay peligro de
romper proyectos desarrollados con la versión 1 de Ionic.</p>

<p><code>
rchavarria@home$ npm install -g ionic@alpha
</code></p>

<h2>Creación del primer proyecto</h2>

<p>Para mi primer proyecto he usado una plantilla desarrollada por la gente de
Ionic, <a href="https://github.com/driftyco/ionic2-starter-tutorial">tutorial</a>. Estas plantillas permiten tener una aplicación muy básica
funcionando en unos minutos. Esta plantilla contiene un menú deslizante
lateral, pero hay otras muchas plantillas. Crear el proyecto es un simple
comando:</p>

<p><code>
rchavarria@home$ ionic start MyFirstIonic2Project tutorial --v2
</code></p>

<p>Este comando descarga la plantilla indicada, <code>tutorial</code>, instala dependencias
de NodeJS y nos deja el proyecto listo para ser ejecutado. De hecho, para poder
probarlo en un navegador, basta con escribir los comandos:</p>

<p><code>
rchavarria@home$ cd MyFirstIonic2Project
rchavarria@home$ ionic serve
</code></p>

<h2>Estructura del proyecto</h2>

<p>Prácticamente todos los ficheros de la aplicación están localizados en el
directorio <code>www</code>, como en todo proyecto de Cordova.</p>

<p>El punto de entrada principal es <code>www/index.html</code>. Como página principal, carga
los ficheros CSS, incluye los JavaScript y arranca la aplicación. Ionic busca
una etiqueta <code>ion-app</code> dentro de esta primera página HTML.</p>

<p>Todo el código JavaScript que se encuentra en el directorio <code>www/app</code> se
transpila a la versión correcta de JavaScript que soporte el navegador para el
que está dirigida la aplicación. En este directorio podremos encontrar código
tanto TypeScript como ECMAScript 2015.</p>

<p>En el archivo <code>www/app/app.js</code> podemos encontrar la entrada a nuestra
aplicación. Crea un component con el decorador <code>@App</code>, componente necesario
para toda aplicación Ionic.</p>

<p><code>
@App({
  templateUrl: 'app/app.html'
})
class MyApp {
//...
}
</code></p>

<p>El código de <code>@App</code> configura el archivo <code>www/app/app.html</code> como plantilla para
la aplicacion. Veámoslo:</p>

<p>```
<ion-menu [content]="content"></p>

<p>  <ion-content></p>

<pre><code>&lt;ion-list&gt;
  &lt;button ion-item *ng-for="#p of pages" (click)="openPage(p)"&gt;
  &lt;/button&gt;
&lt;/ion-list&gt;
</code></pre>

<p>  </ion-content></p>

<p></ion-menu></p>

<p><ion-nav id="nav" [root]="rootPage" #content swipe-back-enabled="false"></ion-nav>
```</p>

<p>Esta plantilla define un menu bajo la etiqueta <code>ion-menu</code>, y un componente de
navegación, <code>ion-nav</code>, ambos proporcionados por Ionic. <code>ion-menu</code> toma una
propiedad para mostrar un contenido, <code>content</code>, la cual se la podemos
proporcionar a través de la variable <code>#content</code> desde nuestro <code>ion-nav</code>.</p>

<p><code>ion-nav</code> define un <em>data binding</em> a la propiedad <code>root</code> del componente, igual
que <code>ion-menu</code> define un <em>data binding</em> a la propiedad <code>content</code> (en Angular 2,
los <em>data binding</em> son unidireccionales por defecto y se declaran mediante
corchetes en atributos de las etiquetas HTML). Cuando se cargue el controlador
de la navegación, el componente referenciado por la variable <code>rootPage</code> será
mostrada como la página principal de nuestra aplicación.</p>

<p>En <code>www/app/app.js</code>, el componente raiz de la aplicación, <code>MyApp</code>, especifica
dos propiedades: <code>pages</code> y <code>rootPage</code></p>

<p>```
import {App, IonicApp, IonicPlatform} from 'ionic/ionic';
import {HelloIonicPage} from './hello-ionic/hello-ionic';
import {ListPage} from './list/list';
// ...
class MyApp {
  constructor(app: IonicApp, platform: IonicPlatform) {</p>

<pre><code>// set up our app
// ...

// set our app's pages
this.pages = [
  { title: 'Hello Ionic', component: HelloIonicPage },
  { title: 'My First List', component: ListPage }
];

// make HelloIonicPage the root page
this.rootPage = HelloIonicPage;
</code></pre>

<p>  }
  // ...
}
```</p>

<h2>Cómo se crea un página</h2>

<p>El componente <code>HelloIonicPage</code> se define en el fichero
<code>www/hello-ionic/hello-ionic.js</code>. Contiene un decorador <code>@Page</code>, proporcionado
por Ionic, y su nombre lo dice todo. Este componente crea una página Ionic, que
consta de un componente y una vista de Angular 2.</p>

<p>```
import {Page, NavController} from 'ionic/ionic';</p>

<p>@Page({
  templateUrl: 'app/hello-ionic/hello-ionic.html'
})
export class HelloIonicPage {
  constructor(nav: NavController) {</p>

<pre><code>this.nav = nav;
</code></pre>

<p>  }
}
```</p>

<p>Cada página se compone de un componente JavaScript y de una plantilla HTML.
Veamos ésta última:</p>

<p>```
<ion-navbar *navbar>
  <a menu-toggle><icon menu /></a>
  <ion-title>Hello Ionic</ion-title>
</ion-navbar></p>

<p><ion-content>
  <h3>Welcome to your first Ionic app!</h3>
  <p></p>

<pre><code>...
</code></pre>

<p>  </p>
</ion-content>
```</p>

<p>La etiqueta <code>&lt;ion-navbar *navbar&gt;</code> funciona como configuración para la barra de navegación. Es quien incluye los botones a mostrar en dicha barra, así como el título.</p>

<h2>Navegando entre páginas</h2>

<p>La otra página, <code>ListPage</code>, contiene una lista de elementos que el usuario
puede tocar (o hacer click) para acceder a ellas. Dicha página está definida en
el archivo <code>www/app/list/list.js</code>.</p>

<p>```
import {IonicApp, Page, NavController, NavParams} from 'ionic/ionic';</p>

<p>@Page({
  templateUrl: 'app/list/list.html'
})
export class ListPage {
  constructor(app: IonicApp, nav: NavController, navParams: NavParams) {</p>

<pre><code>this.nav = nav;
// ...
</code></pre>

<p>   }</p>

<p>   itemTapped(event, item) {</p>

<pre><code> // ...
</code></pre>

<p>   }
}
```</p>

<p>La plantilla de esta página, definida en <code>www/app/list/list.html</code>, es quien
mostrará una lista de elementos. <code>*ng-for</code> es la sintaxis de Angular 2 para
reproducir la misma funcionalidad que <code>ng-repeat</code> en AngularJS. El manejador
del evento click se establece con <code>(click)=itemTapped(...)</code> (en Angular 2, se
utilizan los paréntesis en atributos de las etiquetas HTML para establecer los
manejadores de eventos). De esta forma, cada vez que el usuario toque/haga
click en un elemento, el método <code>itemTapped</code> será llamado.</p>

<p><code>
&lt;ion-item *ng-for="#item of items" (click)="itemTapped($event, item)"&gt;
</code></p>

<p>Para navegar a una nueva página, se puede usar el componente <code>NavController</code>,
también proporcionado por Ionic. Anteriormente, se ha almacenado una referencia
a dicho componente en el atributo <code>nav</code> de <code>ListPage</code>.</p>

<p>```
import {ItemDetailsPage} from '../item-details/item-details';
// ...
itemTapped(event, item) {
  this.nav.push(ItemDetailsPage, {</p>

<pre><code>item: item
</code></pre>

<p>  });
}
```</p>

<p>La navegación en Ionic funciona como una <em>pila</em> (o <em>stack</em>), donde podemos poner (<code>push</code>)
o quitar (<code>pop</code>) páginas de la pila.</p>

<h2>¿Y ahora qué?</h2>

<p>Ya tenemos una estructura muy básica para el proyecto, y ya sabemos cómo crear
páginas y cómo funciona la navegación en Ionic 2. El siguiente paso se me
ocurre que podría ser incluir las herramientas y la estrutura necesaria para
poder incluir tests en nuestro proyecto. Lo siento si te parece una lata, pero
creo que los tests son una herramienta imprescindible en cualquier proyecto,
sea de la embergadura que sea. Considero que los tests son básicos para tener
un mínimo de calidad en cualquier proyecto software.</p>

<h2>Referencias</h2>

<ul>
<li>Documentación sobre <a href="http://ionicframework.com/docs/v2/components">componentes de Ionic 2</a></li>
<li>Documentación sobre <a href="http://ionicframework.com/docs/v2/platform">el API de dispositivos de Ionic 2</a></li>
<li><a href="http://ionicframework.com/docs/v2/resources/">Recursos</a>, en general, de Ionic 2</li>
<li><a href="https://angular.io/docs/ts/latest/testing/">Tests en Angular 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Análisis de consumo de memoria en tests de AngularJS]]></title>
    <link href="http://rchavarria.github.io/blog/2015/07/26/consumo-memoria-tests-angularjs/"/>
    <updated>2015-07-26T22:10:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/07/26/consumo-memoria-tests-angularjs</id>
    <content type="html"><![CDATA[<p>Hoy en día no concibo desarrollar una aplicación sin una batería de tests
automáticos (unitarios, de integración, end-to-end, del tipo que sean).
Da igual el tamaño del proyecto. Pero además, si se trata de una aplicación
JavaScript, tener tests es una obligación.</p>

<p><a href="http://angularjs.org">AngularJS</a> es un framework que pone las cosas fáciles para comenzar a escribir
tests. Incluso la propia aplicación de ejemplo ya viene preparada para
escribir tests con <a href="https://jasmine.github.io">Jasmine</a> y ejecutarlos con <a href="https://karma-runner.github.io">KarmaJS</a> en tu navegador.</p>

<p>Si el proyecto es muy grande, llegará un punto en el que haya cientos de tests
automáticos, quizá miles, por lo que ejecutar todos los tests en el navegador
se puede considerar como la ejecución de una gran aplicación. Por lo tanto
habrá que tener en cuenta aspectos de rendimiento, consumo de memoria (y
liberación de la misma), posibles <em>memory leaks</em>,...</p>

<!-- more -->


<p>Eso justo es lo que está pasando en mi equipo. Nuestro proyecto está en un
estado avanzado de desarrollo, y comenzamos a tener un número considerable de
tests automáticos en la parte cliente. Para ejecutar los tests en el servidor
de integración contínua utilizamos <a href="http://phantomjs.org">PhantomJS</a>. Pero parece ser que PhantomJS
tiene algunos problemillascon la gestión de memoria, y hemos sobrepasado su
límite. PhantomJS no puede ejecutar toda nuestra batería de tests de una sola
vez. Así que nos estamos planteando si quizá son nuestros tests quienes tienen
algún problema con la memoria, quizá podríamos hacer algo para no consumir
tantos recursos.</p>

<h2>Hipótesis</h2>

<p>Una idea para solucionarlo pasa por reducir la cantidad de código JavaScript a
cargar y ejecutar en cada test. ¿Qué tal si en lugar de cargar el módulo
principal de AngularJS completo (donde está contenida toda nuestra aplicación),
cargamos solamente aquel módulo que contenga la funcionalidad a probar en el
test?</p>

<p>Pero esto es sólo una hipótesis, no vamos a modularizar toda la aplición en
módulos minúsculos sin tener ningún dato sobre el que apoyarnos. Por lo tanto,
vamos a realizar la siguiente prueba: añadiremos un nuevo módulo, minúsculo. En
este módulo crearemos una factoría, con un método al que llamaremos tantas veces
sea necesario para hacer que los tests consuman una cantidad apreciable de
memoria y CPU. Ejecutaremos dos baterías de tests, con los mismos tests: una
cargando el módulo que contiene toda la aplicación, otra cargando solamente el
módulo pequeño.</p>

<h2>Aplicación completa</h2>

<p><img class="center" src="/images/2015/memory-benchmark-big.thumbnail.png"></p>

<p><a href="/images/2015/memory-benchmark-big.png">Ver la imagen en grande</a></p>

<p>Podemos apreciar como la ejecución de la batería de tests dura aproximadamente
unos 8 segundos (desde 4.5s hasta 12.25s). En cuanto a consumo de memoria, el
rango va de un mínimo de 10Mb a un máximo de 108Mb.</p>

<p>Se puede apreciar cómo el consumo de memoria va dibujando unos dientes de sierra.
Éste dibujo es muy típico en los análisis de memoria (hay momentos en los que
se reserva memoria y el consumo aumenta, pasado un pequeño espacio de tiempo,
objetos en memoria se dejan de usar y ésta es liberada, que es cuando la gráfica
baja de golpe). Pero la mala noticia es que el consumo va cada vez a más, no se
libera la misma cantidad que se reserva, lo que indica que hay muchas referencias
a objectos que no se eliminan correctamente. Incluso después de haber terminado
la ejecución de los tests, el navegador no considera que deba liberar memoria.</p>

<h2>Módulo pequeño</h2>

<p><img class="center" src="/images/2015/memory-benchmark-small.thumbnail.png"></p>

<p><a href="/images/2015/memory-benchmark-small.png">Ver la imagen en grande</a></p>

<p>El tiempo de ejecución de esta batería de tests es de 1s, de 3.25s a 4.25s,
(esta gráfica muestra intervalos de 500ms). El consumo de memoria sube
rápidamente, con un mínimo de 11Mb y un máximo de 42.5Mb.</p>

<p>Esta vez, casi no se aprecian los dientes de sierra, quizá porque la ejecución
es mucho más rápida y el navegador no considera que haya que liberar memoria de
forma agresiva durante el tiempo que dura la ejecución. Aquí se puede observar
claramente cómo después de que los tests hayan terminado, pasado un tiempo, el
navegador es capaz de liberar prácticamente toda la memoria consumida por los
tests. Esto es muy buena señal.</p>

<h2>Conclusiones</h2>

<p>Con este pequeño análisis queda bastante claro que tener módulos pequeños hace
que nuestros tests se ejecuten mucho más rápido (el tiempo de ejecución baja de
8s a 1s) y consuman mucha menos memoria (el máximo baja de 108Mb a 42.5Mb).
También se puede deducir que en módulos pequeños hay un riesgo más bajo de sufrir <em>memory leaks</em>.</p>

<p>En este caso, al usar un módulo muy pequeño y no observar <em>memory leaks</em>, se
deduce que los <em>leaks</em> que se observan en la aplicación en su conjunto deben de
estar en otro módulo. Esto nos ayuda a aislar partes de nuestra aplicación y
poder reducir la cantidad de código a analizar para encontrar el problema.</p>

<p>Estábamos en lo cierto con nuestra hipótesis, módulos pequeños hacen que los
tests sean más rápidos y más eficientes en el consumo de memoria. Por lo tanto,
parece buena idea <strong>modularizar una aplicación</strong> con un tamaño considerable, y al
ejecutar los tests <strong>cargar sólo los módulos necesarios</strong> para que se ejecute esa
suite de tests, no cargar módulos redundantes.</p>

<h2>Referencias</h2>

<p>En el artículo <a href="http://shyp.github.io/2015/07/13/speed-up-your-javascript-tests.html">Speed up JavaScript test time 1000x</a> podemos encontrar unos
cuantos consejos acerca de cómo hacer que nuestros tests JavaScript se ejecuten
mucho más rápido, ya sea una aplicación Angular o no.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript patterns]]></title>
    <link href="http://rchavarria.github.io/blog/2015/07/19/javascript-patterns/"/>
    <updated>2015-07-19T21:10:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/07/19/javascript-patterns</id>
    <content type="html"><![CDATA[<h5>de Stoyan Stefanov</h5>

<p><img class="left" src="http://akamaicovers.oreilly.com/images/9780596806767/lrg.jpg" width="250" height="328" title="JavaScript patterns" ></p>

<h2>Por qué lo he leído</h2>

<p>Cuando leí <a href="/blog/2015/05/29/learning-javascript-design-patterns/">Learning JavaScript design patterns</a>, de Addy Osmany, me quedé con
ganas de más, me equivoqué de libro. El que realmente quería leerme para
aprender sobre patrones en JavaScript era éste. Pero me dejé llevar por la
<em>fama</em> de Addy.</p>

<p>El objetivo de leer estos dos libros era el de profundizar en el uso de patrones
en JavaScript, poder trasladar conocimientos adquiridos en Java, a JavaScript.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>Esperaba que fuera un libro muy parecido al mítico <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8">Design patterns</a>, como si
fuera un catálogo de patrones disponibles, con sus descripciones, situaciones
donde es recomendable usarlos y también, por qué no, ejemplos de proyectos
reales.</p>

<h2>Qué encontré</h2>

<p>Por supuesto, encontré muchos patrones, pero eso no es lo más llamativo.</p>

<p>El autor comenta varios aspectos del lenguaje que son cuanto menos, curiosos. No
sé si llegan al nivel de <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript, the good parts</a>, pero deben de andar
cerca.</p>

<p>Además, alguno de los patrones difieren de la idea que yo tenía, son muy
distintos a patrones con el mismo nombre, pero en otros lenguajes de
programación.</p>

<h2>Conclusiones</h2>

<p>Junto con <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript, the good parts</a>, considero que éste es un libro imprescindible
para cualquier desarrollador que quiera dominar el lenguaje.</p>

<p>Explica en profundidad algunos de los patrones más usados en todo tipo de
proyectos. Quizá, con el nuevo estándard recién aprobado, algunos de ellos
(como la <em>herencia por prototipos</em>) queden algo obsoletos, creo que es
un libro imprescindible para entender el lenguaje.</p>

<h2>Qué he aprendido</h2>

<p>Puedes consultar mis <a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/javascript-patterns-by-stoyan-stefanov.markdown">notas sobre el libro</a> si quieres ver todo lo que me
ha llamado la atención de el mismo. Pero destacaría lo siguiente:</p>

<ul>
<li>Una regla que se repite en muchos patrones: <strong>los miembros a compartir deben
ir en el prototipo, nunca en el <code>this</code></strong></li>
<li>Los constructors implícitamente devuelven <code>this</code>, incluso si no hay un
<code>return</code>, pero tu puedes devolver lo que quieras, incluso puedes redefinir el
constructor. Esto se hace, por ejemplo, en el patrón Singleton</li>
<li>En la declaración de una función, su definición también sufre <em>hoisting</em>, no
solo la declaración</li>
<li>Métodos clásicos de herencia y herencia de prototipos, aunque esto vaya a
cambiar con nuevas versiones del lenguaje, con la aparición de clases</li>
<li>Unas cuantas sugerencias para desplegar grandes aplicaciones: combinar scripts,
minificarlos, utilizar compresión de archivos, uso de cabeceras HTML, uso de
CDNs, dónde situar las etiquetas <code>&lt;script&gt;</code>, enviar en trozos grandes ficheros
HTML.</li>
</ul>


<h2>Recursos relacionados</h2>

<ul>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/javascript-patterns-by-stoyan-stefanov.markdown">notas sobre el libro</a></li>
<li><a href="/blog/2015/05/29/learning-javascript-design-patterns/">Learning JavaScript design patterns</a>, libro de Addy Osmany</li>
<li><a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8">Design patterns</a>, libro de The Gang of Four</li>
<li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript, the good parts</a>, libro de Douglas Crockford</li>
</ul>

]]></content>
  </entry>
  
</feed>
