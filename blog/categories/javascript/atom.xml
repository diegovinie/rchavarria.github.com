<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2015-10-25T16:22:43+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Análisis de consumo de memoria en tests de AngularJS]]></title>
    <link href="http://rchavarria.github.io/blog/2015/07/26/consumo-memoria-tests-angularjs/"/>
    <updated>2015-07-26T22:10:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/07/26/consumo-memoria-tests-angularjs</id>
    <content type="html"><![CDATA[<p>Hoy en día no concibo desarrollar una aplicación sin una batería de tests
automáticos (unitarios, de integración, end-to-end, del tipo que sean).
Da igual el tamaño del proyecto. Pero además, si se trata de una aplicación
JavaScript, tener tests es una obligación.</p>

<p><a href="http://angularjs.org">AngularJS</a> es un framework que pone las cosas fáciles para comenzar a escribir
tests. Incluso la propia aplicación de ejemplo ya viene preparada para
escribir tests con <a href="https://jasmine.github.io">Jasmine</a> y ejecutarlos con <a href="https://karma-runner.github.io">KarmaJS</a> en tu navegador.</p>

<p>Si el proyecto es muy grande, llegará un punto en el que haya cientos de tests
automáticos, quizá miles, por lo que ejecutar todos los tests en el navegador
se puede considerar como la ejecución de una gran aplicación. Por lo tanto
habrá que tener en cuenta aspectos de rendimiento, consumo de memoria (y
liberación de la misma), posibles <em>memory leaks</em>,...</p>

<!-- more -->


<p>Eso justo es lo que está pasando en mi equipo. Nuestro proyecto está en un
estado avanzado de desarrollo, y comenzamos a tener un número considerable de
tests automáticos en la parte cliente. Para ejecutar los tests en el servidor
de integración contínua utilizamos <a href="http://phantomjs.org">PhantomJS</a>. Pero parece ser que PhantomJS
tiene algunos problemillascon la gestión de memoria, y hemos sobrepasado su
límite. PhantomJS no puede ejecutar toda nuestra batería de tests de una sola
vez. Así que nos estamos planteando si quizá son nuestros tests quienes tienen
algún problema con la memoria, quizá podríamos hacer algo para no consumir
tantos recursos.</p>

<h2>Hipótesis</h2>

<p>Una idea para solucionarlo pasa por reducir la cantidad de código JavaScript a
cargar y ejecutar en cada test. ¿Qué tal si en lugar de cargar el módulo
principal de AngularJS completo (donde está contenida toda nuestra aplicación),
cargamos solamente aquel módulo que contenga la funcionalidad a probar en el
test?</p>

<p>Pero esto es sólo una hipótesis, no vamos a modularizar toda la aplición en
módulos minúsculos sin tener ningún dato sobre el que apoyarnos. Por lo tanto,
vamos a realizar la siguiente prueba: añadiremos un nuevo módulo, minúsculo. En
este módulo crearemos una factoría, con un método al que llamaremos tantas veces
sea necesario para hacer que los tests consuman una cantidad apreciable de
memoria y CPU. Ejecutaremos dos baterías de tests, con los mismos tests: una
cargando el módulo que contiene toda la aplicación, otra cargando solamente el
módulo pequeño.</p>

<h2>Aplicación completa</h2>

<p><img class="center" src="/images/2015/memory-benchmark-big.thumbnail.png"></p>

<p><a href="/images/2015/memory-benchmark-big.png">Ver la imagen en grande</a></p>

<p>Podemos apreciar como la ejecución de la batería de tests dura aproximadamente
unos 8 segundos (desde 4.5s hasta 12.25s). En cuanto a consumo de memoria, el
rango va de un mínimo de 10Mb a un máximo de 108Mb.</p>

<p>Se puede apreciar cómo el consumo de memoria va dibujando unos dientes de sierra.
Éste dibujo es muy típico en los análisis de memoria (hay momentos en los que
se reserva memoria y el consumo aumenta, pasado un pequeño espacio de tiempo,
objetos en memoria se dejan de usar y ésta es liberada, que es cuando la gráfica
baja de golpe). Pero la mala noticia es que el consumo va cada vez a más, no se
libera la misma cantidad que se reserva, lo que indica que hay muchas referencias
a objectos que no se eliminan correctamente. Incluso después de haber terminado
la ejecución de los tests, el navegador no considera que deba liberar memoria.</p>

<h2>Módulo pequeño</h2>

<p><img class="center" src="/images/2015/memory-benchmark-small.thumbnail.png"></p>

<p><a href="/images/2015/memory-benchmark-small.png">Ver la imagen en grande</a></p>

<p>El tiempo de ejecución de esta batería de tests es de 1s, de 3.25s a 4.25s,
(esta gráfica muestra intervalos de 500ms). El consumo de memoria sube
rápidamente, con un mínimo de 11Mb y un máximo de 42.5Mb.</p>

<p>Esta vez, casi no se aprecian los dientes de sierra, quizá porque la ejecución
es mucho más rápida y el navegador no considera que haya que liberar memoria de
forma agresiva durante el tiempo que dura la ejecución. Aquí se puede observar
claramente cómo después de que los tests hayan terminado, pasado un tiempo, el
navegador es capaz de liberar prácticamente toda la memoria consumida por los
tests. Esto es muy buena señal.</p>

<h2>Conclusiones</h2>

<p>Con este pequeño análisis queda bastante claro que tener módulos pequeños hace
que nuestros tests se ejecuten mucho más rápido (el tiempo de ejecución baja de
8s a 1s) y consuman mucha menos memoria (el máximo baja de 108Mb a 42.5Mb).
También se puede deducir que en módulos pequeños hay un riesgo más bajo de sufrir <em>memory leaks</em>.</p>

<p>En este caso, al usar un módulo muy pequeño y no observar <em>memory leaks</em>, se
deduce que los <em>leaks</em> que se observan en la aplicación en su conjunto deben de
estar en otro módulo. Esto nos ayuda a aislar partes de nuestra aplicación y
poder reducir la cantidad de código a analizar para encontrar el problema.</p>

<p>Estábamos en lo cierto con nuestra hipótesis, módulos pequeños hacen que los
tests sean más rápidos y más eficientes en el consumo de memoria. Por lo tanto,
parece buena idea <strong>modularizar una aplicación</strong> con un tamaño considerable, y al
ejecutar los tests <strong>cargar sólo los módulos necesarios</strong> para que se ejecute esa
suite de tests, no cargar módulos redundantes.</p>

<h2>Referencias</h2>

<p>En el artículo <a href="http://shyp.github.io/2015/07/13/speed-up-your-javascript-tests.html">Speed up JavaScript test time 1000x</a> podemos encontrar unos
cuantos consejos acerca de cómo hacer que nuestros tests JavaScript se ejecuten
mucho más rápido, ya sea una aplicación Angular o no.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript patterns]]></title>
    <link href="http://rchavarria.github.io/blog/2015/07/19/javascript-patterns/"/>
    <updated>2015-07-19T21:10:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/07/19/javascript-patterns</id>
    <content type="html"><![CDATA[<h5>de Stoyan Stefanov</h5>

<p><img class="left" src="http://akamaicovers.oreilly.com/images/9780596806767/lrg.jpg" width="250" height="328" title="JavaScript patterns" ></p>

<h2>Por qué lo he leído</h2>

<p>Cuando leí <a href="/blog/2015/05/29/learning-javascript-design-patterns/">Learning JavaScript design patterns</a>, de Addy Osmany, me quedé con
ganas de más, me equivoqué de libro. El que realmente quería leerme para
aprender sobre patrones en JavaScript era éste. Pero me dejé llevar por la
<em>fama</em> de Addy.</p>

<p>El objetivo de leer estos dos libros era el de profundizar en el uso de patrones
en JavaScript, poder trasladar conocimientos adquiridos en Java, a JavaScript.</p>

<!-- more -->


<h2>Qué esperaba</h2>

<p>Esperaba que fuera un libro muy parecido al mítico <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8">Design patterns</a>, como si
fuera un catálogo de patrones disponibles, con sus descripciones, situaciones
donde es recomendable usarlos y también, por qué no, ejemplos de proyectos
reales.</p>

<h2>Qué encontré</h2>

<p>Por supuesto, encontré muchos patrones, pero eso no es lo más llamativo.</p>

<p>El autor comenta varios aspectos del lenguaje que son cuanto menos, curiosos. No
sé si llegan al nivel de <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript, the good parts</a>, pero deben de andar
cerca.</p>

<p>Además, alguno de los patrones difieren de la idea que yo tenía, son muy
distintos a patrones con el mismo nombre, pero en otros lenguajes de
programación.</p>

<h2>Conclusiones</h2>

<p>Junto con <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript, the good parts</a>, considero que éste es un libro imprescindible
para cualquier desarrollador que quiera dominar el lenguaje.</p>

<p>Explica en profundidad algunos de los patrones más usados en todo tipo de
proyectos. Quizá, con el nuevo estándard recién aprobado, algunos de ellos
(como la <em>herencia por prototipos</em>) queden algo obsoletos, creo que es
un libro imprescindible para entender el lenguaje.</p>

<h2>Qué he aprendido</h2>

<p>Puedes consultar mis <a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/javascript-patterns-by-stoyan-stefanov.markdown">notas sobre el libro</a> si quieres ver todo lo que me
ha llamado la atención de el mismo. Pero destacaría lo siguiente:</p>

<ul>
<li>Una regla que se repite en muchos patrones: <strong>los miembros a compartir deben
ir en el prototipo, nunca en el <code>this</code></strong></li>
<li>Los constructors implícitamente devuelven <code>this</code>, incluso si no hay un
<code>return</code>, pero tu puedes devolver lo que quieras, incluso puedes redefinir el
constructor. Esto se hace, por ejemplo, en el patrón Singleton</li>
<li>En la declaración de una función, su definición también sufre <em>hoisting</em>, no
solo la declaración</li>
<li>Métodos clásicos de herencia y herencia de prototipos, aunque esto vaya a
cambiar con nuevas versiones del lenguaje, con la aparición de clases</li>
<li>Unas cuantas sugerencias para desplegar grandes aplicaciones: combinar scripts,
minificarlos, utilizar compresión de archivos, uso de cabeceras HTML, uso de
CDNs, dónde situar las etiquetas <code>&lt;script&gt;</code>, enviar en trozos grandes ficheros
HTML.</li>
</ul>


<h2>Recursos relacionados</h2>

<ul>
<li><a href="https://github.com/rchavarria/blog-post-incubator/blob/master/published-book-notes/javascript-patterns-by-stoyan-stefanov.markdown">notas sobre el libro</a></li>
<li><a href="/blog/2015/05/29/learning-javascript-design-patterns/">Learning JavaScript design patterns</a>, libro de Addy Osmany</li>
<li><a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8">Design patterns</a>, libro de The Gang of Four</li>
<li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript, the good parts</a>, libro de Douglas Crockford</li>
</ul>

]]></content>
  </entry>
  
</feed>
