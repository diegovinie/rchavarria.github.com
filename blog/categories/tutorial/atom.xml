<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tutorial | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/tutorial/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2018-03-23T20:18:34+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cómo desplegar una aplicación Elixir/Phoenix en Heroku]]></title>
    <link href="http://rchavarria.github.io/blog/2017/03/19/desplegar-aplicacion-elixir-phoenix-heroku/"/>
    <updated>2017-03-19T13:44:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/03/19/desplegar-aplicacion-elixir-phoenix-heroku</id>
    <content type="html"><![CDATA[<p><a href="http://heroku.com/">Heroku</a> es una plataforma donde los desarrolladores pueden desplegar sus aplicaciones (sobre todo está pensado para aplicaciones web) y hacerlas públicas de forma gratuita o por un pequeño precio. Yo he utilizado a veces este servicio para hacer pruebas con servidores en JavaScript (NodeJS) o PHP, pero también admite muchos otros lenguages de programación: Ruby, Java, Python, Go,...</p>

<p><img class="center" src="/images/2017/elixir-phoenix-heroku.png"></p>

<p>No es ningún secreto que estoy <a href="/blog/2016/01/17/aprendiendo-elixir/">tonteando con Elixir</a>, y <a href="http://www.phoenixframework.org/">el framework Phoenix</a> es el framework por referencia para crear aplicaciones web en Elixir. Pero ese no es un lenguaje soportado por Heroku, así que parecía un poco complejo poder hacer unas pruebas desplegando una aplicación Elixir/Phoenix en Heroku.</p>

<p>Por suerte, <a href="http://wsmoak.net/about.html">Wendy Smoak</a> escribió un artículo hace un tiempo hablando de esto mismo: <a href="http://wsmoak.net/2015/07/05/phoenix-on-heroku.html">Deploying a Phoenix app to Heroku</a>. Dicho artículo tiene licencia <a href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons CC-BY-NC</a>. Este post no es una traducción en sí, pero como está basado en él me parece justo y obligatorio respetarla. Así que este post está basado en el artículo <a href="http://wsmoak.net/2015/07/05/phoenix-on-heroku.html">Deploying a Phoenix app to Heroku</a>, de <a href="http://wsmoak.net/about.html">Wendy Smoak</a>, y también está licenciado bajo la <a href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons CC-BY-NC</a>, digan lo que digan el resto de posts de este blog.</p>

<!-- more -->


<h2>Requisitos</h2>

<p>Para poder llevar a cabo el despliegue, necesitamos todas estas herramientas. Yo lo he probado con estas versiones:</p>

<ul>
<li>Elixir, versión 1.3.1. El cuál, necesita Erlang/OTP, por ejemplo la versión 19</li>
<li>Phoenix, versión 1.2.1</li>
<li>Phoenix necesita de NodeJS, yo tengo instalada la versión 5.12.0; y también necesita (normalmente) de una base de datos, comúnmente, PostgreSQL, yo he utilizado la versión 9.5, que viene mi distribución Ubuntu</li>
<li>Git, versión 2.7.4</li>
<li>Heroku toolbelt, versión 3.43.14; Heroku CLI, versión 5.6.31; este post también asume que nos hemos dado de alta en Heroku y hemos configurado estas herramientas.</li>
</ul>


<h2>Creando una aplicación Phoenix</h2>

<p>Crear el esqueleto de una aplicación Phoenix es ridículamente sencillo, simplemente un comando:</p>

<pre><code>$ mix phoenix.new rchavarria_deploys_phoenix_heroku
[ ... ]
Fetch and install dependencies? [Yn] Y
[ ... ]
</code></pre>

<p>Para poder llevar un control de lo que hacemos o dejamos de hacer, pondremos la aplicación bajo un control de versiones. Además, Heroku está pensado para funcionar con aplicaciones donde el control de versiones es Git, así que...</p>

<pre><code>$ cd rchavarria_deploys_phoenix_heroku
$ git init
$ git add .
$ git commit -m "Primera piedra de la aplicación Phoenix desplegada en Heroku"
</code></pre>

<p>Si queremos, podemos subir esta aplicación a GitHub u otro servicio que nos permita tener nuestras aplicación bajo Git.</p>

<h2>Creando una aplicación Heroku</h2>

<p>También es muy sencillo:</p>

<pre><code>$ heroku create
Creating app... done, ⬢ dry-anchorage-96713
https://dry-anchorage-96713.herokuapp.com/ | https://git.heroku.com/dry-anchorage-96713.git
Git remote heroku added
</code></pre>

<p>También se puede indicar el nombre de nuestra app en el comando <code>heroku create</code>. Heroku nos ha dado un nombre aleatorio, y podremos acceder a ella a través de la URL <a href="https://dry-anchorage-96713.herokuapp.com/">https://dry-anchorage-96713.herokuapp.com/</a>.</p>

<p>Heroku habrá añadido un nuevo <em>remote</em> a nuestro repositorio de <code>git</code>:</p>

<pre><code>$ git remote -v
heroku  https://git.heroku.com/dry-anchorage-96713.git (fetch)
heroku  https://git.heroku.com/dry-anchorage-96713.git (push)
</code></pre>

<h2>Añadiendo <em>buildpacks</em> a la applicación Heroku</h2>

<blockquote><p>Los <a href="https://devcenter.heroku.com/articles/buildpacks">buildpacks</a> son los encargados de transformar el código desplegado en un <em>slug</em>, el cual puede ser ejecutado en un <em>dyno</em>.</p></blockquote>

<p>Y después de toda esa jerga de Heroku, en cristiano quiere decir algo así: los <em>buildpacks</em> son un conjunto de herramientas que convierten y empaquetan tu código de forma que puedan ser ejecutados por la infraestructura de Heroku.</p>

<p>Heroku proporciona buildpacks por defecto: Java, Python, PHP, JavaScript,... Pero afortunadamente, también existen para Elixir y Phoenix, aunque no están mantenidos por Heroku.</p>

<p>Primero, debemos añadir el buildpack para Phoenix, conocido como <a href="https://github.com/gjaldon/heroku-buildpack-phoenix-static">Phoenix static buildpack</a>:</p>

<pre><code>$ heroku buildpacks:set https://github.com/gjaldon/phoenix-static-buildpack
Buildpack set. Next release on dry-anchorage-96713 will use https://github.com/gjaldon/phoenix-static-buildpack.
Run git push heroku master to create a new release using this buildpack.
</code></pre>

<p>Después, añadimos el <a href="https://github.com/HashNuke/heroku-buildpack-elixir">buildpack de Elixir</a>, configurándolo en primera posición:</p>

<pre><code>$ heroku buildpacks:add --index 1 https://github.com/HashNuke/heroku-buildpack-elixir
Buildpack added. Next release on dry-anchorage-96713 will use:
  1. https://github.com/HashNuke/heroku-buildpack-elixir
  2. https://github.com/gjaldon/phoenix-static-buildpack
Run git push heroku master to create a new release using these buildpacks.
</code></pre>

<h2>Ultimando los detalles del despliegue</h2>

<p>Si intentamos realizar ahora el despliegue, obtendremos un error:</p>

<pre><code>$ git push heroku master
[ ... ]
remote: -----&gt; Fetching app dependencies with mix
remote:     ** (Code.LoadError) could not load [...]/config/prod.secret.exs
[ ... ]
remote: ! Push rejected to dry-anchorage-96713.
[ ... ]
</code></pre>

<p>Para poder desplegar, necesitamos subir el fichero <code>prod.secret.exs</code>. Pero ese fichero está ignorado en <code>.gitignore</code>, por lo que no será subido mediante el comando <code>git push heroku master</code>. Y está ignorado por una buena razón. Ese fichero suele contener información sensible.</p>

<p>Pero tiene solución. Debemos sustituir la información sensible por valores tomados de variables de entorno. Editamos <code>prod.secret.exs</code>, de forma que quede parecido a:</p>

<pre><code>use Mix.Config

# In this file, we keep production configuration that
# you likely want to automate and keep it away from
# your version control system.
#
# You should document the content of this
# file or create a script for recreating it, since it's
# kept out of version control and might be hard to recover
# or recreate for your teammates (or you later on).
config :rchavarria_deploys_phoenix_heroku, RchavarriaDeploysPhoenixHeroku.Endpoint,
  secret_key_base: System.get_env("SECRET_KEY_BASE")

# Configure your database
config :rchavarria_deploys_phoenix_heroku, RchavarriaDeploysPhoenixHeroku.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: System.get_env("DATABASE_USERNAME"),
  password: System.get_env("DATABASE_PASSWORD"),
  database: "rchavarria_deploys_phoenix_heroku_prod",
  pool_size: 20
</code></pre>

<p>También debemos editar <code>.gitignore</code>, para dejar de ignorar <code>prod.secret.exs</code>.</p>

<p>No olvides hacer commit de estos cambios:</p>

<pre><code>$ git add .
$ git commit -m "Incluir prod.secret.exs, sustituyendo secretos por variables de entorno"
</code></pre>

<h2>Desplegando</h2>

<p>Ahora sí, ya podemos desplegar.</p>

<p>El despliegue no debería dar ningún problema, porque aunque no hemos creado ninguna variable de entorno, la aplicación básica de Phoenix no accede a la base de datos, por lo que la configuración de <code>prod.secret.exs</code> no debería tener ningún efecto todavía.</p>

<pre><code>$ git push heroku master
remote: -----&gt; Elixir app detected
remote: -----&gt; Installing Erlang 18.3 (changed)
remote: -----&gt; Installing Elixir v1.3.4 (changed)
remote: -----&gt; Compiling
remote: Generated rchavarria_deploys_phoenix_heroku app
remote:        Installing Node 6.9.2...
remote: -----&gt; Building dependencies
remote: -----&gt; Finalizing build
remote: -----&gt; Launching...
remote:        https://dry-anchorage-96713.herokuapp.com/ deployed to Heroku
remote: Verifying deploy... done.
To https://git.heroku.com/dry-anchorage-96713.git
</code></pre>

<p>Y se puede ver la aplicación accediendo a <a href="https://dry-anchorage-96713.herokuapp.com/">https://dry-anchorage-96713.herokuapp.com/</a> (si es que todavía existe como aplicación Heroku).</p>

<h2>Completando la configuración</h2>

<p>Tarde o temprano, vamos a necesitar que nuestra aplicación acceda a la base de datos. Por lo que tendremos que configurar nuestras variables de entorno. Para ello, son necesarios dos pasos:</p>

<ol>
<li>Configurarlas y exportarlas en Heroku (documentación sobre <a href="https://devcenter.heroku.com/articles/config-vars">variables de configuración de Heroku</a>)</li>
</ol>


<p><code>
$ heroku config:set SECRET_KEY_BASE=&lt;y aquí mi secreto&gt;
$ heroku config:set SOME_VAR=&lt;el valor para esta variable&gt;
</code></p>

<ol>
<li>Editar (o crear) <code>elixir_buildpack.config</code> en la raíz del proyecto. Aquí deberemos configurar qué variables queremos exportar. Cuidado, porque estos valores sobreescriben los exportados por los buildpacks, por lo que deberemos incluir aquellas que incluyan los buildpacks de Elixir y Phoenix. Un ejemplo de <code>elixir_buildpack.config</code> podría ser tan sencillo como:</li>
</ol>


<p><code>
configu_vars_to_export=(DATABASE_URL SECRET_KEY_BASE)
</code></p>

<h2>Agradecimientos</h2>

<p>Todo el mérito de esta información no es mío, es gracias a <a href="http://wsmoak.net/about.html">Wendy Smoak</a>, autora del post sobre el que se basa este; <a href="http://hashnuke.com/">HashNuke</a>, autor del buildpack para Elixir; <a href="http://gabrieljaldon.com/">gjaldon</a>, autor del buildpack para Phoenix; y otros que ayudaron a Wendy con sus dudas.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Plantilla para módulos NodeJS]]></title>
    <link href="http://rchavarria.github.io/blog/2014/09/24/plantilla-para-modulos-nodejs/"/>
    <updated>2014-09-24T00:45:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2014/09/24/plantilla-para-modulos-nodejs</id>
    <content type="html"><![CDATA[<p>Hace poco, viendo los <a href="http://www.carlosble.com/screencasts/es/">screencasts de Carlos Blé</a>
sobre programación, a un compañero de trabajo le picó la curiosidad e
intentó repetir el ejercicio que practicaba Carlos. Carlos desarrolla algunos
screencasts en JavaScript, y utiliza <a href="http://visionmedia.github.io/mocha/">Mocha</a> y <a href="http://chaijs.com">Chai</a> como frameworks para tests.
Yo recordé haber montado algo parecido algún día, y con este proyecto de github
quiero ayudar a los demás a que puedan montar un <a href="https://github.com/rchavarria/nodejs-module-template/tree/template-ready">proyecto NodeJS con Gulp, Mocha y Chai</a>.</p>

<!-- more -->


<h1>Plantilla para módulos NodeJS</h1>

<p>En este proyecto encontrarás una estructura para módulos <a href="http://nodejs.org">NodeJS</a> lista
para comenzar a trabajar. El proyecto está compuesto de las siguientes
librerías:</p>

<ul>
<li><a href="http://gulpjs.com">Gulp</a>: como herramienta para automatizar tareas</li>
<li><a href="http://visionmedia.github.io/mocha/">Mocha</a>: como herramienta para ejecutar tests</li>
<li><a href="http://chaijs.com">Chai</a>: como librería de checkeos (<em>asserts</em> a falta de una traducción mejor)
para tests</li>
<li><a href="http://cjohansen.no/sinon">Sinon</a>: como una librería de dobles de tests</li>
</ul>


<p>En este fichero están las instrucciones para instalar y poner en funcionamiento
todas estas librerías.</p>

<h1>¿Cómo instalar NodeJS?</h1>

<p>Lo primero de todo, instalar NodeJS.</p>

<p>Para instalarlo en Ubuntu, simplemente ejecutar el comando:</p>

<pre><code>sudo apt-get install nodejs
</code></pre>

<p>Para instalarlo en otros sistemas operativos, visitarla página
<a href="http://nodejs.org/download">NodeJS download page</a>.</p>

<p>Hay otra forma de instalarlo, y es a través de <code>nvm</code> (<a href="http://carlosazaustre.es/blog/como-instalar-node-js-en-ubuntu">Node Version Manager</a>).</p>

<p>El resto de librerías las instalaremos a través de la herramienta <code>npm</code>.</p>

<h1>Inicializar <code>npm</code></h1>

<p>Ejecutar el comando:</p>

<pre><code>npm init
</code></pre>

<p>El comando te guiará por unos pasos para introducir información básica del módulo
donde trabajarás. Entre esa información se encuentra el nombre del proyecto,
la descripción y la version.</p>

<p>Un fichero <code>package.json</code> tipo podría ser el siguiente:</p>

<pre><code>{
    "name": "nodejs-module-template",
    "version": "0.0.0",
    "description": "A template for NodeJS modules",
    "main": "index.js",
    "directories": {
        "test": "test"
    },
    "dependencies": {},
    "devDependencies": {},
    "scripts": {
        "test": "test"
    },
    "author": "Ruben Chavarria http://rchavarria.github.io",
    "license": "BSD-2-Clause"
}
</code></pre>

<h1>Instalar Gulp</h1>

<p>Es muy fácil, con <code>npm</code>:</p>

<pre><code>npm install --save-dev gulp
</code></pre>

<p>El flag <code>--save-dev</code> insertará una nueva línea en el fichero <code>package.json</code> para
indicar a <code>npm</code> que hay una nueva dependencia para tiempo de desarrollo.</p>

<p>Para comprobar que se ha instalado correctamente, ejecutar el comando
<code>gulp --version</code>.</p>

<h1>Configurar Gulp</h1>

<p>Crea un fichero <code>gulpfile.js</code> en el directorio raiz del proyecto. El contenido
del fichero podría ser el siguiente:</p>

<pre><code>var gulp = require('gulp');

gulp.task('default', function() {
    console.log('Hello gulp!');
});
</code></pre>

<p>Ejecuta el comando <code>gulp</code> para ver un mensaje por consola.</p>

<h1>Instalar librerías de tests</h1>

<p>Es tan fácil como instalar Gulp, simplemente escribir el comando:</p>

<pre><code>npm install --save-dev mocha chai sinon sinon-chai
</code></pre>

<p>Para probar que se ha instalado Mocha adecuadamente, escribir
<code>node node_modules/mocha/bin/mocha --version</code>.</p>

<h1>Antes de escribir el primer test</h1>

<p>Antes de escribir el primer test, crearemos un fichero de inicializacion para
Mocha, para inicializar las librerias y evitar tener que escribir el mismo
código una y otra vez en todos nuestros tests.</p>

<p>Crea un fichero llamado <code>test/bootstrap.js</code> y escribe en él este contenido:</p>

<pre><code>global.chai = require('chai');
global.sinon = require('sinon');
global.expect = chai.expect;

var sinonChai = require('sinon-chai');
chai.use(sinonChai);
</code></pre>

<p>Esto cargará las librerías Chai y Sinon, crea una variable global llamada
<code>expect</code> (la usaremos en todos los tests) y configura Chai para que use métodos
y funcionalidades proporcionados por Sinon.</p>

<p>Ahora, crearemos una tarea en Gulp para ejecutar los tests. Para ello necesitamos
un plugin de Gulp que sea capaz de lanzar Mocha. Tan fácil como lo anterior:</p>

<pre><code>npm install --save-dev gulp-mocha
</code></pre>

<p>Luego, edita el fichero <code>gulpfile.js</code> y déjalo como el siguiente:</p>

<pre><code>var gulp = require('gulp'),
    mocha = require('gulp-mocha');

gulp.task('test', function () {
    return gulp
        .src(['test/bootstrap.js', 'test/scripts/**/*.js'])
        .pipe(mocha({ reporter: 'spec' }));
});
</code></pre>

<h1>Ahora sí, el primer test</h1>

<p>Crea un fichero llamado <code>test/scripts/firstSpec.js</code> con el siguiente contenido:</p>

<pre><code>describe('Mocha', function() {
    it('expects using Chai', function() {
        expect(2 + 2).equals(4);
    });
});
</code></pre>

<p>Para ejecutar este sencillo test, escribe el comando <code>gulp test</code>.</p>

<h1>Cómo escuchar cambios en ficheros de tests y de producción</h1>

<p>Es posible configurar Gulp para ejecutar una tarea específica cada vez que un
fichero (o varios) cambia. Configuraremos que se ejecute la tarea <code>test</code> cada
vez que se cambie un fichero de test o de producción. Para ello, añade la
siguiente tarea al fichero <code>gulpfile.js</code>.</p>

<pre><code>gulp.task('test-watch', function () {
    return gulp.watch(['src/scripts/**/*.js', 'test/scripts/**/*.js'], ['test']);
});
</code></pre>

<p>Para probar que funciona, escribe el comando <code>gulp test-watch</code>, cambia <code>firstSpec.js</code>
y guarda los cambios. Verás cómo el test se vuelve a ejecutar automáticamente.</p>

<h1>Por fin, probar algún código de producción</h1>

<p>Escribe un sencillo módulo NodeJS que sume dos enteros, guárdalo como
<code>src/scripts/adder.js</code>:</p>

<pre><code>module.exports = function adder(a, b) {
    return a + b;
};
</code></pre>

<p>Reemplaza el contenido de <code>test/scripts/firstSpec.js</code> por este otro (o escribe
tú mismo un nuevo fichero con este test):</p>

<pre><code>describe('Adder module', function() {
    // imports the adder module
    var adder = require('../../src/scripts/adder.js');

    it('adds two integers', function() {
        var sum = adder(2, 2);
        expect(sum).equals(4);
    });
});
</code></pre>

<p>Lánzalos con <code>gulp test</code>.</p>

<h1>Seguir leyendo</h1>

<p>Puedes leer documentación de <a href="http://gulpjs.com">Gulp</a> para saber cómo crear más y mejores tareas,
<a href="http://visionmedia.github.io/mocha/">Mocha</a> y <a href="https://github.com/sindresorhus/gulp-mocha">Mocha's plugin for Gulp</a> para conocer más sobre las opciones de Mocha,
<a href="http://chaijs.com">Chai</a> para aprender a escribir tests con el API <code>expect</code>, <a href="http://cjohansen.no/sinon">Sinon</a> para aprender
sobre dobles de tests (mocks, spies, stubs) cuando escribas tests.</p>

<h1>Actualización (05-07-2015)</h1>

<p>He seguido ampliando este proyecto, y lo he adaptado para poder escribir código
ECMAScript 6: <a href="/blog/2015/07/05/escribir-tests-mocha-es6">Escribir y ejecutar tests de Mocha en ES6</a>.</p>
]]></content>
  </entry>
  
</feed>
