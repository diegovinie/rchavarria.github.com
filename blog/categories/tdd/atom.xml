<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2016-11-07T22:30:29+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Escribir y ejecutar tests de Mocha en ECMAScript 6]]></title>
    <link href="http://rchavarria.github.io/blog/2015/07/05/escribir-tests-mocha-es6/"/>
    <updated>2015-07-05T21:59:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2015/07/05/escribir-tests-mocha-es6</id>
    <content type="html"><![CDATA[<p>Me gusta resolver puzzles, pero no puzzles de miles de piezas, si no más bien el
tipo de puzzle en el que hay unas piezas de madera encajadas y hay que desencajarlas,
o en el que hay una cuerdecita con una bola y tienes que sacar la bola y volverla
a meter. Ese tipo de puzzles.</p>

<p>Creo que de ahí me viene también el gusto de resolver pequeños problemas de
programación. Me gusta programar. Me gusta aprender. Y qué mejor para aprender
que practicar. En el mundo de la programación existe un concepto llamado
<a href="https://en.wikipedia.org/wiki/Kata_%28programming%29">kata</a> (el concepto ha sido copiado de las artes marciales), el cual significa
la realización de pequeños ejercicios focalizados en la solución a un pequeño
problema muy concreto. Así que me gusta realizar katas de vez en cuando en algún
lenguaje de programación, para practicar.</p>

<!-- more -->


<p>Hace un tiempo publiqué un tutorial sobre <a href="/blog/2014/09/24/plantilla-para-modulos-nodejs">cómo crear un módulo NodeJS</a>, el cual
me servía de base para realizar algunas de estas katas. En este artículo me
gustaría llevarlo un poco más allá. A ese proyecto, a esa plantilla, voy a
añadirle lo siguiente:</p>

<ul>
<li><a href="http://babeljs.io">Babel</a>: voy a añadir un paso en la construcción del proyecto y ejecución de los
tests, voy a transpilar código JavaScript ECMAScript 6 a ECMAScript 5. Esto me
permite practicar con la nueva versión de JavaScript.</li>
<li><a href="http://eslint.org">ESLint</a>: estoy convencido de que este tipo de herramientas ayudan en el día a
día en el desarrollo con JavaScript. Me ayudan a detectar errores tontos a la
hora de escribir mi código.</li>
<li><a href="https://travis-ci.org">Travis CI</a>: todos los tests serán ejecutados en un servidor de integración
contínua, para eliminar para siempre la excusa de <em>En mi ordenador funciona</em></li>
</ul>


<p>Si quieres dejarte de tonterías y ver todo montado ya y empezar a usar todo ello,
puedes echar un vistazo a el repositorio <a href="https://github.com/rchavarria/solveet-exercises-js">solveet-exercises-js</a> y jugar con
él.</p>

<h2>Babel</h2>

<p><a href="http://babeljs.io">Babel</a> es una herramienta para transformar código escrito en ECMAScript 6 en
código ECMAScript 5, es decir, para transformar código JavaScript de una versión
que todavía no está soportada completamente por los navegadores a una versión
que sí lo está.</p>

<p>Instalarlo es sencillísimo mediante <code>npm</code>:</p>

<pre><code>npm install --save-dev babel gulp-babel
</code></pre>

<p>Con este comando instalaremos la herramienta en sí, y un plugin para <code>gulp</code> que
nos permitirá usar Babel desde nuestro script Gulp. Modificaremos este script
para que transforme nuestro código justo antes de ejecutar nuestros tests:</p>

<p>``` javascript
gulp.task('test', function () {</p>

<pre><code>return gulp
    .src([ 'test/bootstrap.js', 'test/scripts/**/*.js' ])
    .pipe(mocha({
        reporter: 'spec',
        compilers: 'js:babel/register'  // tell mocha to compile with babel
    }));
</code></pre>

<p>});
```</p>

<p>La parte diferente de otras configuraciones para lanzar los tests con mocha es
la parte donde configuramos mocha para que use Babel como compilador de código
JavaScript.</p>

<h2>ESLint</h2>

<p><a href="http://eslint.org">ESLint</a> es una herramienta que analiza nuestro código JavaScript y nos avisa de
violaciones de reglas que tengamos configuradas. Estas reglas nos permiten
definir patrones para detectar posibles fallos en nuestro código así como forzar
a que todos los integrantes de nuestro equipo sigan el mismo estilo de programación.</p>

<p>También utilizaremos <code>npm</code> para instalarlo, esta vez instalaremos solamente el
plugin de <code>gulp</code>, que como depende de ESLint directamente, éste se instalará
automáticamente:</p>

<pre><code>npm install --save-dev gulp-eslint
</code></pre>

<p>Y podemos crear una nueva tarea en gulp para analizar nuestro código:</p>

<p>``` javascript
gulp.task('eslint', function () {</p>

<pre><code>return gulp
    .src([ 'gulpfile.js', 'src/scripts/**/*.js', 'test/scripts/**/*.js' ])
    .pipe(eslint())
    .pipe(eslint.format())
    .pipe(eslint.failOnError());
</code></pre>

<p>});
```</p>

<p>Ahora, si queremos analizar todo nuestro código antes de lanzar nuestros tests,
podemos hacer que la tarea <code>test</code> dependa de la nueva tarea <code>eslint</code>:</p>

<pre><code>gulp.task('test', [ 'eslint' ], function () {
    // ...
}
</code></pre>

<p>El siguiente paso es configurar ESLint. Hay infinidad de reglas, incluso podemos
definir las nuestras propias. Para comenzar, puedes echar un vistazo a un
fichero <a href="https://raw.githubusercontent.com/rchavarria/solveet-exercises-js/master/.eslintrc"><code>.eslintrc</code> de ejemplo</a>.</p>

<h2>Travis CI</h2>

<p><a href="https://travis-ci.org">Travis CI</a> es una herramienta de integración contínua. La herramienta recupera
nuestro código del repositorio de GitHub que le digamos y ejecuta todos los
tests.</p>

<p>Para ello debemos darnos de alta en la página. Podemos hacerlo con nuestra
cuenta de GitHub. Luego, podemos ir a nuestro perfil e indicar a Travis CI
qué repositorios debe <em>vigilar</em> para ejecutar los tests cada vez que hagamos
un push al repositorio.</p>

<p>Debemos indicar a Travis CI qué lenguaje y plataforma queremos testear, en
nuestro caso se trata de NodeJS. Como configuración, añadimos simplemente un
fichero llamado <code>.travis.yml</code> en el directorio raiz del proyecto con este
contenido:</p>

<pre><code>language: node_js
node_js:
    - "0.12"
</code></pre>

<p>De esta forma, cuando hagamos un push a nuestro repositorio en GitHub, Travis CI
recuperará el código, instalará paquetes Node con <code>npm</code> y ejecutará el comando
<code>npm test</code>.</p>

<p>Para que Travis CI lanze nuestros tests, debemos configurar la respuesta al
comando <code>npm test</code>. Para ello, modificaremos el fichero <code>package.json</code>:</p>

<pre><code>//...
"scripts": {
    "test": "gulp test"
},
//...
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charla técnica: Is TDD dead? Of course not!]]></title>
    <link href="http://rchavarria.github.io/blog/2015/01/17/charla-tecnica-is-tdd-dead/"/>
    <updated>2015-01-17T17:35:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2015/01/17/charla-tecnica-is-tdd-dead</id>
    <content type="html"><![CDATA[<p>Hace poco, vi posteada una charla de <a href="http://twitter.com/emilybache">Emily Bache</a> titulada <a href="https://www.youtube.com/watch?v=PCEHRFHKZSk">Is TDD dead? Of course not!</a>
en el blog <a href="http://garajeando.blogspot.com/2015/01/interesting-talk-is-tdd-dead-of-course.html">Garajeando</a>, un blog que suelo leer. Poco después la vi posteada
en otro blog que suelo leer, <a href="http://alvarogarcia7.github.io/blog/2015/01/06/talk-is-tdd-dead-of-course-not-by-emily-bache">The long way through Software Craftsmanship</a>. ¿Algo debería tener
la charla no? Aquí hay un resumen de lo que la charla me a aportado a mí:</p>

<!-- more -->


<p>Básicamente, la charla habla de las tres críticas que <a href="http://twitter.com/dhh">David Heinemeier Hansson</a>
hizo a la práctica de TDD con su <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">TDD is dead, long live testing</a>.</p>

<ol>
<li>Fundamentalismo: para evitarlo, experimenta TDD, inténtalo por tí mismo, que no
te lo cuenten. Después, juzga por tí mismo. Para experimentarlo existen prácticas
como las <em>code katas</em> o <em>coding dojos</em> y herramientas como <a href="http://cyber-dojo.org">cyber-dojo.org</a>.</li>
<li>Daña el diseño: diseñar es difícil (con o sin TDD). TDD
te empuja a introducir nuevos niveles de indirección, hacia el Principio de
Inversión de Dependencias. Aún así, es <strong>tu responsabilidad</strong> como programador
saber cuándo tu aplicación tiene demasiados niveles de indirección y actuar en
consecuencia.</li>
<li>Foco en tests unitarios: puede que David tenga razón aquí, hay mucho foco
en los tests unitarios. Emily nos habla de unos <a href="http://coding-is-like-cooking.info/tag/approval-testing">tests de Aprobación</a> como
complemento a los unitarios.</li>
</ol>


<p>Un montón de consejos (la mayoría) sobre TDD son para principiantes de TDD.
Así que, cuando te den alguno, piensa si ya has superado esa barrera, y si lo
has hecho, ignora el consejo, porque tú ya estas por encima de él. Aprende a
discernir qué información es válida para tu nivel.</p>

<iframe width="560" height="315" src="http://rchavarria.github.io//www.youtube.com/embed/PCEHRFHKZSk" frameborder="0" allowfullscreen></iframe>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[solveet: cifrado cesar en python]]></title>
    <link href="http://rchavarria.github.io/blog/2012/12/19/solveet-cifrado-cesar-en-python/"/>
    <updated>2012-12-19T12:31:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2012/12/19/solveet-cifrado-cesar-en-python</id>
    <content type="html"><![CDATA[<p>Me gusta resolver problemas de programación regularmente para mejorar como programdor, y para ello uso
la página <a href="http://solveet.com">Solveet</a>. El problema que he solucionado esta semana es el del
<a href="http://www.solveet.com/exercises/Cifrado-Cesar/145">Cifrado César</a>, y está englobado en la iniciativa
<a href="http://12meses12katas.com/">12meses12katas</a> en la me gusta participar.</p>

<p>El <em>cifrado César</em> es muy simple: es un tipo de cifrado por sustitución en el que una letra en el texto
original es reemplazada por otra letra que se encuentra un número fijo de posiciones más adelante
en el alfabeto.</p>

<p>Decidí usar <strong>python</strong> para este problema porque quería profundizar un poco más en este lenguaje, que lo
tengo muy verde y he escuchado maravillas de él, pero gracias a la solución del problema he aprendido
un par de cosas del lenguaje: uso de la función <code>map</code>, y las funciones <code>str.maketrans</code> y <code>str.translate</code>.</p>

<!-- more -->


<h2>Primera aproximación</h2>

<p>Debido a mi poco conocimiento del lenguaje, mi
<a href="http://www.solveet.com/exercises/Cifrado-Cesar/145/solution-1076">primera aproximación</a>
al problema no es muy elegante, y tampoco usa muchas de las fortalezas de python. La verdad es que es
una solución más al estilo de un lenguaje que conozco bastante mejor, Java.</p>

<p>Así pues, una vez publiqué mi solución, decidí echarle un vistazo a soluciones de otros usuarios.
Encontré varias en python, y de ellas aprendí un par de cosas:</p>

<h2>Uso de la función <code>map</code></h2>

<p>Python proporciona la función <code>map(function, iterable, ...)</code>
(<a href="http://docs.python.org/3.3/library/functions.html#map">documentación</a>), la cual llama a la función
<code>function</code> para cada uno de los elementos de <code>iterable</code> (se pueden usar uno o varios iterables).</p>

<p>En un principio había pensado usar esta función. <code>function</code> sería el método que realiza el cifrado
carácter a carácter e <code>iterable</code> sería la cadena de texto a cifrar. Pero el método que cifra necesita
otro argumento, el desplazamiento, y no fuí capaz de averiguar por mí mismo cómo pasar este argumento
a mi método usando <code>map</code>.</p>

<p>Lo descubrí gracias a la solución de <a href="http://www.solveet.com/exercises/Cifrado-Cesar/145/solution-1052">climens</a>,
y aprovechando lo aprendido, mi solución ahora quedaría así:</p>

<p>``` python
from string import ascii_lowercase as alphabet</p>

<p>def shift(character, offset):</p>

<pre><code>index = alphabet.find(character)
if(index &lt; 0): return character
return alphabet[(index + offset) % len(alphabet)]
</code></pre>

<p>def cipher(message, offset):</p>

<pre><code>ciphered = map(shift, message, [offset] * len(message))
return "".join(ciphered)
</code></pre>

<p>def decipher(message, offset):</p>

<pre><code>return cipher(message, -1 * offset)
</code></pre>

<h1>simple tests</h1>

<p>assert "ibm" == cipher("hal", 1)
assert "hal" == decipher("ibm", 1)
```</p>

<p>El <em>truco</em> está en que a la función <code>map</code> le paso dos <code>iterables</code>: la cadena de texto, y un array de enteros
de la misma longitud y cuyos elementos son todos iguales, el desplazamiento. <strong>¡Qué sencillo ahora que lo
sé!</strong></p>

<h2>Funciones <code>str.maketrans</code> y <code>str.translate</code></h2>

<p>Desconocía completamente la existencia de estas dos funciones, pero parecen haber sido diseñadas exclusivamente
para el <em>cifrado César</em>. Las descubrí gracias a la solución de
<a href="http://www.solveet.com/exercises/Cifrado-Cesar/145/solution-1038">drabor</a></p>

<p><code>str.maketrans</code> (<a href="http://docs.python.org/3.3/library/stdtypes.html#str.maketrans">documentación</a>)
crea un mapa para ser usado en <code>str.translate</code>
(<a href="http://docs.python.org/3.3/library/stdtypes.html#str.translate">documentación</a>),
y ésta, al ser llamada sobre una cadena de caracteres, devuelve otra cadena donde cada carácter ha sido
<em>transladado</em> según el mapa creado con <code>maketrans</code>.</p>

<p>Ahora sólo hace falta crear el mapa. Uso dos iterables: el alfabeto original, y el alfabeto transladado tantas
posiciones como diga el desplazamiento del cifrado. De esta forma, con desplazamiento <code>1</code>, la letra <code>a</code>
corresponderá con la <code>b</code> y así sucesivamente. Pero todo ese trabajo lo hará <code>translate</code>, no nosotros.</p>

<p>Así queda la solución:</p>

<p>```
from string import ascii_lowercase as alphabet</p>

<p>def cipher(message, offset):</p>

<pre><code>dictionary_mapping = str.maketrans(alphabet, alphabet[offset:] + alphabet[:offset])
return message.translate(dictionary_mapping)
</code></pre>

<p>def decipher(message, offset):</p>

<pre><code>return cipher(message, -1 * offset)
</code></pre>

<h1>simple tests</h1>

<p>assert "ibm" == cipher("hal", 1)
assert "hal" == decipher("ibm", 1)
```</p>

<h2>Conclusión</h2>

<p>Cualquiera de las dos soluciones me parece mucho mejor que la mía inicial, y me parecía que debía compartir
lo aprendido al solucionar este problema.</p>

<p>Y tú, ¿Conoces python? ¿Te apetece participar en <a href="http://solveet.com">solveet</a>?
¿Tienes alguna sugerencia para mejorar estas soluciones? Deja algún comentario. Si es respetuoso,
será bienvenido.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[solveet: Torres de Hannoi]]></title>
    <link href="http://rchavarria.github.io/blog/2012/12/12/solveet-torres-de-hannoi/"/>
    <updated>2012-12-12T09:35:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2012/12/12/solveet-torres-de-hannoi</id>
    <content type="html"><![CDATA[<p>Simplemente para practicar y mejorar mis habilidades como programador, me gusta resolver problemas
de programación regularmente. Hace un tiempo conocí la página <a href="http://solveet.com">Solveet</a>, y desde
entonces intento aportar semanalmente alguna que otra solución a los problemas propuestos por otros
profesionales del desarrollo software.</p>

<p><img class="right" src="http://upload.wikimedia.org/wikipedia/commons/6/60/Tower_of_Hanoi_4.gif" width="320" height="125" title="By André Karwath aka Aka, Own work, CC-BY-SA-2.5, via Wikimedia Commons" ></p>

<p>El problema que he solucionado esta semana es el de las
<a href="http://www.solveet.com/exercises/Torres-de-Hannoi/72">Torres de Hannoi</a>, todo un clásico en el
desarrollo software, y en este post intento describir detalladamente cómo he llegado a mi solución.</p>

<!-- more -->


<h2>Introducción</h2>

<p>El punto de partida ha sido esta entrada en la wikipedia acerca de las
<a href="http://es.wikipedia.org/wiki/Torres_de_Han%C3%B3i">Torres de Hannoi</a> donde explica de una forma muy
básica la forma de solucionarlo. Ahora sólo hay que implementarlo.</p>

<p>Decidí solucionar el problema en javascript, para aprender más sobre este lenguaje, y decidí solucionar
el problema de forma iterativa, ya que me pareció más sencilla que la forma recursiva. Y ya que estoy
practicando, intenté llegar a la solución definitiva practicando TDD.</p>

<p>Puedes ver mi solución publicada en <a href="http://www.solveet.com/exercises/Torres-de-Hannoi/72/solution-1051">solveet</a>,
así como el código completo de la solución y los tests en este repositorio de
<a href="https://github.com/rchavarria/solveet-problems/tree/master/hannoi-js">github</a>.</p>

<h2>Manos a la obra</h2>

<p>La parte más fácil es mover el anillo más pequeño. Éste hay que moverlo siempre en los pasos impares,
y siguiendo siempre un de estas dos secuencias:</p>

<ul>
<li>Si el número de anillos es impar, hay que moverlo a las siguientes torres o varillas:
destino -> auxiliar -> origen, y así indefinidamente</li>
<li>Si el número de anillos es par, la secuencia será: auxiliar -> destino -> origen, ...</li>
</ul>


<h2>Movimientos en los pasos pares</h2>

<p>En los pasos pares hay que mover los anillos que no son el anillo más pequeño. El anillo a mover dependerá
del número de anillos de los que conste el problema.</p>

<p>Al utilizar TDD, he ido descubriendo poco a poco cómo escoger el anillo a mover y dónde moverlo:</p>

<ul>
<li>1 anillo: no hace falta mover otros anillos ya que con un movimiento está solucionado.</li>
<li>2 anillos: solo es posible mover el anillo más grande a la torre destino, ya que el anillo más pequeño lo
habremos movido en el primer movimiento a la torre auxiliar.</li>
<li>3 anillos: desarrollando manualmente todos los movimientos, el anillo a mover es aquel que no está en la
torre destino y que tampoco es el anillo más pequeño.</li>
<li>4 anillos: desarrollando otra vez manualmente todos los movimientos, el anillo a mover es el menor anillo
(sin ser el más pequeño) y se deberá mover a la única torre posible. Esta torre la sabremos porque es aquella
torre que no contiene ni el anillo más pequeño ni el anillo a mover.</li>
</ul>


<p>A partir de los 4 anillos, la solución ya funciona con cualquier número de anillos.</p>

<h4>Reconocimientos</h4>

<ul>
<li>Imagen By André Karwath aka Aka (Own work) <a href="http://creativecommons.org/licenses/by-sa/2.5">CC-BY-SA-2.5</a>, via <a href="http://commons.wikimedia.org/wiki/File%3ATower_of_Hanoi_4.gif">Wikimedia Commons</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
