<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: elixir | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/elixir/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2016-03-20T17:27:06+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir: primer asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/02/09/elixir-primer-asalto/"/>
    <updated>2016-02-09T21:57:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2016/02/09/elixir-primer-asalto</id>
    <content type="html"><![CDATA[<p>Éste es el primer asalto de mi aprendizaje de <a href="http://elixir-lang.org/">Elixir</a>. En él, no espero
resolver problemas súper complicados, es un primer contacto con el lenguaje. Me
conformaré con ser capaz de escribir un programa algo más complicado que un
simple hola mundo. En este primer asalto, lucho con tipos de datos, funciones
(anónimas y con nombre), pattern matching, claúsulas de guarda y módulos.</p>

<p>En estos asaltos, intentaré seguir los siguientes pasos:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2016/touch-gloves-derived-small.png"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/awy1vc">Touch Gloves</a> de <a href="https://www.flickr.com/photos/kaiban/">Jack Zallum</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/legalcode">CC BY-NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Instalación</strong></p>

<p>Instalar la máquina virtual de Erlang y el entorno de Elixir es extremadamente
sencillo. Aquí están los comandos para hacerlo en una máquina con Ubuntu como
sistema operativo. En la <a href="http://elixir-lang.org/install.html">documentación de Elixir</a> hay instrucciones para otros
sistemas operativos.</p>

<p><code>
$ wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb
$ sudo dpkg -i erlang-solutions_1.0_all.deb
$ sudo apt-get update
$ sudo apt-get install esl-erlang
$ sudo apt-get install elixir
</code></p>

<p><strong>Editores</strong></p>

<p>La comunidad de Elixir ha creado plugins para los editores de código más
famosos, entre ellos <a href="http://www.vim.org/">Vim</a>, que utilizo para mis <a href="http://rchavarria.github.io/pet-projects/">proyectos personales</a>.</p>

<p>Instalar el plugin <a href="https://github.com/elixir-lang/vim-elixir">vim-elixir</a> en Vim es facilísimo si instalas plugins con
pathogen:</p>

<p><code>
$ git clone https://github.com/elixir-lang/vim-elixir.git ~/.vim/bundle/vim-elixir
</code></p>

<p><strong>Herramientas</strong></p>

<p><code>iex</code> es una herramienta de tipo REPL (read, evaluate, print, loop), que nos
permite ejecutar código Elixir de forma rápida. El comando <code>iex &lt;fichero.exs&gt;</code>
compila un script de Elixir y lo carga en la herramienta. Si ya estamos dentro
de ella, el comando para compilar el código Elixir de un fichero sería <code>c
"&lt;fichero exs&gt;"</code>.</p>

<p><strong>Pattern matching</strong></p>

<p>El operador <code>=</code> es muy diferente a lo que esperamos de él los que estamos
acostumbrados a la programación orientada a objetos. Tiene una apariencia
similar, pero no se comporta de la misma forma. Con este operador, Elixir trata
de hacer coincidir los valores de la izquierda con los valores de la derecha.</p>

<p><code>
a = 2
[a, b, a] = [1, 2, 1]
[^a, b] = [2, 3]
[a, b, c] = [1, 2, [3, 4, 5]]   # c vale [3, 4, 5]
</code></p>

<p><strong>Inmutabilidad</strong></p>

<p>¿Es eficiente devolver una copia de los datos? En los lenguajes funcionales, no
se modifican los datos, se devuelve una copia de ellos transformados. Parece
ineficiente, pero es todo lo contrario. Al no modificarse los originales, éstos
pueden compartirse por muchas variables, y pueden estar tranquilos, ya que no
se va a modificar. En los lenguajes no funcionales, se devuelve una copia (no
eficiente), en los funcionales, en realidad no se devuelve una copia, se
comparte todo lo que se puede. Por lo que es más eficiente.</p>

<p>¿Qué pasa con el recolector de basura? ¿Consume muchos recursos para deshacerse
de todos esos datos transformados que ya no se utilizan? No consume mucho, en
Elixir (en Erlang en realidad), hay muchos procesos, cada uno con un <em>heap</em>
distinto, por lo que el heap es más pequeño que en otros lenguajes, y el
recolector de basura se ejecuta bastante más rápido.</p>

<p><strong>Tipos de datos</strong></p>

<p>Y por fin algo de código:</p>

<p>```</p>

<h1>enteros</h1>

<p>this_is_an_int = 1234
this_is_an_int = 0xcafe    # admite hexadecimal
this_is_an_int = 0o765     # octal
this_is_an_int = 0b01010   # binario
this_is_an_int = 1_000_000</p>

<h1>en coma flotante</h1>

<p>this_is_a_float = 1.0
this_is_a_float = 0.245
this_is_a_float = .342        # error
this_is_a_float = 314159.0e-5</p>

<h1>rangos</h1>

<p>this_is_a_range = 1..100</p>

<h1>expresiones regulares</h1>

<p>this_is_a_regexp = ~r{regexp}options</p>

<h1>tuplas</h1>

<p>this_is_a_tuple = { :ok, 42, "next" }</p>

<h1>listas: se parecen a los arrays de otros lenguajes, pero no</h1>

<h1>lo son. Son estructuras enlazadas. Una lista o está vacía, o</h1>

<h1>contiene un head y un tail, donde tail es otra lista</h1>

<p>this_is_a_list = [ 1, 2, 3 ]</p>

<h1>mapas: lista de parejas clave/valor</h1>

<p>this_is_a_map = %{ key => value, key => value }</p>

<h1>si las claves son Atoms, se puede escribir</h1>

<p>this_is_a_map = %{ red: 0xFF0000, green: 0x00FF00, blue: 0x0000FF }</p>

<h1>binarios: para acceder a datos como una secuencia de bits y bytes (para muy bajo nivel)</h1>

<p>```</p>

<p>Hay otros tipos de datos, como los PIDs (referencias a procesos locales o
remotos) o los puertos (referencias a recursos sobre los cuales leeremos o
escribiremos).</p>

<p>Un tipo de datos muy interesante (y que yo personalmente no conocía) son los
<em>Atoms</em>: constantes representando el nombre de algo. Su nombre es su valor. Dos
Atoms son igules si tienen el mismo nombre, vengan de donde vengan (incluso de
máquinas diferentes)</p>

<p>```</p>

<h1>atoms</h1>

<p>this_is_an_atom = :fred
this_is_an_atom = :is_binary?
this_is_an_atom = :var@32
this_is_an_atom = :&lt;>
this_is_an_atom = :"lo john silver"
```</p>

<p>Hay dos estructuras muy similares, la lista de palabras clave: <code>[red: 0xFF000,
green: 0x00FF00]</code>, que se transforma en <code>[{:red, 0xFF0000}, {:green,
0x00FF00}]</code> y un mapa <code>%{red: 0xFF000, green: 0x00FF00}</code>. Se recomienda usar la
lista de palabras clave para pasar parámetros y usar los mapas cuando se
necesite un array asociativo.</p>

<p>No hemos dicho nada de las cadenas. Pertenecen al tipo <em>Binario</em>. Existe
interpolación de cadenas, con <code>#{...}</code> se evalúa el código de dentro y se
formatea la cadena con el valor obtenido.</p>

<p><strong>Funciones anónimas</strong></p>

<p><code>
sum = fn (a, b) -&gt; a + b end
sum.(2, 3)   # devuelve 5
</code></p>

<p>Las funciones pueden devolver otras funciones. Las funciones recuerdan su
entorno original. Forman lo que se conoce como <em>closures</em>. Me recuerda mucho a
las funciones de JavaScript en este aspecto.</p>

<p>Existe una forma de crear funciones anónimas de una forma muy concisa, con el
operador <code>&amp;...</code></p>

<p>```
sum = fn (a, b) -> a + b end
sum2 = &amp;(&amp;1 + &amp;2)   # idéntica a la función anterior</p>

<h1>devuelve lista con dos elementos: doble del primer parámetro, y cuadrado del mismo</h1>

<p>returns_a_list = &amp;[2 * &amp;1, &amp;1 * &amp;1]</p>

<h1>esta notación viene muy bien para pasar funciones por parámetro</h1>

<p>Enum.map [1, 2, 3] &amp;(&amp;1 * &amp;1)   # devuelve [1, 4, 9]
```</p>

<p>Es normal ver la definición de una función como <code>&amp;map/2</code>, donde <code>map</code> es el
nombre de la función y <code>2</code> es el <em>arity</em>, el número de parámetros de la misma.</p>

<p><strong>Módulos, funciones con nombre y funciones privadas</strong></p>

<p>```
defmodule Times do
  ## define una función en una única línea
  def double(n), do: n * 2</p>

<p>  ## define una función en varias líneas
  def triple(n) do</p>

<pre><code>n * 3
</code></pre>

<p>  end</p>

<p>  ## define una función privada
  defp quadruple(n) do: n * 4
end
```</p>

<p>Las funciones con nombre pueden tener varios cuerpos. Eso ayuda a utilizar
<em>pattern matching</em> a la hora de implementar una solución.</p>

<p>```
defmodule Factorial do
  # el factorial de 0, siempre es 1, esta definición es quien para la recursividad
  def of(0), do: 1</p>

<p>  # el factorial de cualquier otro número, es recursivo
  def of(n), do: n * factorial(n - 1)
end</p>

<p>Factor.of(5)
  # => 120
```</p>

<p>También, las definiciones pueden tener claúsulas de guarda, mediante <code>when
&lt;condition&gt;</code>, lo que ayuda a tener un pattern matching más específico.</p>

<p>```
defmodule Guard do
  def what_is(x) when is_number(x) do</p>

<pre><code>IO.puts "#{x} is a number"
</code></pre>

<p>  end
  def what_is(x) when is_list(x) do</p>

<pre><code>IO.puts "#{x} is a list"
</code></pre>

<p>  end
  def what_is(x) when is_atom(x) do</p>

<pre><code>IO.puts "#{x} is an atom"
</code></pre>

<p>  end
end
```</p>

<p><strong>El operador tubería (pipe)</strong></p>

<p>El operador <code>|&gt;</code> toma el resultado de una función y lo pasa como primer
parámetro de la segunda función. <code>String.reverse "foobar" |&gt; String.capitalize</code></p>

<p>```
filing = DB.find_customers</p>

<pre><code>       |&gt; Orders.for_customers
       |&gt; sales_tax(2016)
       |&gt; prepare_filing
</code></pre>

<p>list
  |> sales_taxes(2016)
  |> prepare_filing</p>

<h1>es lo mismo que llamar</h1>

<p>prepare_filing( sales_taxes(list, 2016) )
```</p>

<p><strong>Parámetros por defecto</strong></p>

<p>```
defmodule DefaultParams do
  def func(p1, p2 \ 2) do</p>

<pre><code>IO.inspect [p1, p2]
</code></pre>

<p>  end
end</p>

<p>Example.func("a", "b")
  # => ["a", "b"]</p>

<p>Example.func("a")
  # => ["a", 2]
```</p>

<p><strong>Librerías</strong></p>

<p>Se pueden buscar módulos y librerías ya implementados para realizar ciertas
tareas que necesitemos, para ello, está la documentación de <a href="http://elixir-lang.org/docs.html">librerías de Elixir</a>.
Si no encontramos ahí lo que buscamos, lo podemos buscar en <a href="http://erlang.org/doc/">librerías de Erlang</a>.</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p><strong>¿Qué hace <code>^</code> en el pattern matching?</strong></p>

<p>El operador <code>^</code> obliga a que el valor actual de una variable coincida con el
valor en la expresión de <em>pattern matching</em>. En caso de no coincidir, se
producirá un error.</p>

<p><code>
a = 2
[^a, b] = [2, 3]  ## no hay error, `a` valía `2` y aquí coinciden
[^a, b] = [1, 3]  ## error
</code></p>

<p><strong>Tuplas, <em>keyword list</em> y mapas</strong></p>

<p>Las <em>keyword list</em> son una lista usadas muy a menudo, tienen la forma:</p>

<p><code>
keyword_list = [ red: 0xFF0000, green: 0x00FF00, blue: 0x0000FF ]
</code></p>

<p>Pero no es más que una forma simplificada de escribir una lista de tuplas,
donde el primer valor de cada una de ellas es un Atom:</p>

<p><code>
tuple_list = [ {:red, 0xFF000}, {:green, 0x00FF00}, {:blue, 0x0000FF} ]
</code></p>

<p>Una estructura muy parecida a estas son los mapas, que no son más que un
conjunto de parejas clave-valor:</p>

<p><code>
a_map = %{ :red =&gt; 0xFF000, :green =&gt; 0x00FF00, :blue =&gt; 0x0000FF }
</code></p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-01/round-01-exercise-01.exs">round-01-exercise-01.exs</a>: utilizar varios cuerpos de una función y
recursividad para implementar una función que calcule la suma de <code>1</code> hasta
<code>n</code></li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-01/round-01-exercise-02.exs">round-01-exercise-02.exs</a>: implementar la función <code>gcd(x, y)</code> que calcule el
máximo común divisor. Matemáticamente: <code>gcd(x, y)</code> es <code>x</code> si <code>y</code> es cero y es
<code>gcd(y, rem(x, y))</code> en caso contrario</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-01/round-01-exercise-03.exs">round-01-exercise-03.exs</a>: crear el juego <em>Estoy pensando en un número entre
el 1 y el 100</em>: rangos, div(a, b), claúsulas de guarda, pattern matching en
rangos: <code>a..b = 4..8</code>, funciones privadas</li>
</ul>


<h2>Enseñar lo aprendido</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aprendiendo Elixir]]></title>
    <link href="http://rchavarria.github.io/blog/2016/01/17/aprendiendo-elixir/"/>
    <updated>2016-01-17T16:39:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2016/01/17/aprendiendo-elixir</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2016/elixir.png" width="200" height="266"></p>

<p>No es una propósito de año nuevo ni nada, pero me apetece aprender un lenguaje
puramente funcional por el simple hecho de aprender. He estado dudando entre
Clojure y Elixir. Al final me he decidido por Elixir porque lo <em>venden</em> como
divertido y porque sigo a varias personas en Twitter que están haciendo lo
mismo (durante la redacción de este post me he enterado que hay un meetup nuevo
del lenguaje en Madrid, <a href="http://www.meetup.com/Madrid-Elixir/">Madrid |> Elixir</a>), por lo que podré compartir lo
aprendido. Dicen de Elixir que se parece mucho a Ruby, y que es un lenguaje
moderno que se ejecuta la máquina virtual de Erlang. Con esos <em>hermanos
mayores</em> promete mucho, la verdad.</p>

<!-- more -->


<p>Para ir aprendiendo el lenguaje, voy a poner en práctica el proceso de
aprendizaje que descubrí leyendo el libro <a href="http://rchavarria.github.io/blog/2015/11/08/soft-skills/">Soft Skills</a>, de John Sonmetz:</p>

<ol>
<li>Entender la habilidad que se quiere aprender</li>
<li>Delimitar el ámbito</li>
<li>Definir qué se va a considerar como éxito</li>
<li>Encontrar recursos</li>
<li>Crear un plan de aprendizaje</li>
<li>Filtrar los recursos</li>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido, y repetir desde el paso 7</li>
</ol>


<p>Antes de llegar a los puntos 7-10, que son como un bucle, ahí van los primeros.</p>

<h2>¿Qué habilidad quiero aprender?</h2>

<p><strong>Quiero aprender a programar en Elixir</strong>. La frase es sencilla, pero ¿qué
significa? ¿Significa que solamente quiero aprender la sintaxis? No, eso no es
aprender un lenguaje de programación. ¿Significa que debo aprender todas las
herramientas, frameworks, librerías, sistemas,...? Tampoco. Eso es imposible.
He programado durante años en Java o JavaScript y lo que desconozco de ellos es
mucho más de lo que conozco.</p>

<p>Así pues, delimitaré el aprendizaje a conocer lo suficientemente el lenguaje y
su ecosistema para ser capaz de escribir la parte servidora de una aplicación
web.</p>

<h2>¿Qué voy a considerar como éxito?</h2>

<p>Tengo que poner algún límite. Creo que algo realmente interesante sería
considerar un éxito poder <strong>desarrollar la parte servidora de una aplicación web</strong>,
una API REST o algo así, que gestionara algún tipo de recurso (usuarios,
tareas,... todavía no lo se). Si además soy capaz de desplegar la aplicación en
alguna plataforma como Heroku o similar, el éxito sería rotundo.</p>

<p>No me planteo nada de conectarlo a una base de datos, porque por ahora no he
leído nada acerca de ello. Supongo que habrá alguna posibilidad, pero por ahora
lo voy a dejar fuera.</p>

<h2>Recursos</h2>

<p>Esta es una lista inicial de recursos que voy a ir consumiendo:</p>

<ul>
<li>Web <a href="http://elixir-lang.org/">elixir-lang.org</a>. Web oficial. Creo que me puede servir para tener
documentación rápida de forma online.</li>
<li>Libro <a href="https://pragprog.com/book/elixir/programming-elixir">Programming Elixir, de Dave Thomas</a>. Parece ser el libro de
referencia, así que es un recurso indispensable.
<a href="https://forums.pragprog.com/forums/322">Foros de discusión del libro</a>.</li>
<li>Libro <a href="https://pragprog.com/book/phoenix/programming-phoenix">Programming Phoenix</a>, también de la editorial The Pragmatic
Programmer. Phoenix es un framework para desarrollar aplicaciones web con
Elixir (<a href="https://twitter.com/_rubenfa/status/689356164082049024">recomendado por Rubén Fernández</a>, gracias).</li>
<li><a href="https://github.com/elixir-lang/elixir">Código elixir en GitHub</a>. Código, código, código.</li>
<li>Screencasts <a href="http://elixirsips.com/">elixir sips</a>. Videos sobre Elixir, muchos de ellos bajo
suscripción.</li>
<li><a href="https://www.learnelixir.tv/episodes">LearnElixitTV</a>. Más videos sobre Elixir, en este caso son de pago pero no de
suscripción.</li>
<li><a href="http://elixirdose.com/">Elixir Dose</a>. Un blog sobre este lenguaje de programación.</li>
<li>Blog de <a href="http://benjamintan.io/blog/">Benjamin Tan</a>. Un blog sobre Ruby y Elixir del autor de un libro
sobre Elixir. Parece venir del mundo Ruby. Tiene una charla en una
conferencia de Ruby que hay que ver.</li>
<li>Track de Elixir de <a href="http://exercism.io/languages/elixir">exercism.io</a>, una plataforma social donde resolver
problemas y comentar las soluciones del resto de usuarios.</li>
<li><a href="https://github.com/niftyn8/elixir_style_guide">Guía de estilo</a> para programar en Elixir. De obligado conocimiento para que
tu código sea más legible por la comunidad.</li>
<li><a href="https://www.youtube.com/watch?v=fklep3sUSWo">The climb experiencing the rise of Elixir from the inside</a>: una charla
impresionante de Dave Thomas y Bruce Tate sobre Elixir, comparando el
desarrollo de un lenguaje con subir al Everest. Todos somos Sherpas y debemos
compartir la carga (de José Valim y su equipo) para hacer de Elixr, Phoenix y
Elm un gran lenguaje y una gran plataforma. También hablan de QWAN (quality
without a name) en Elixir. <em>QWAN is two way</em>, nos sentimos inspirados por la
calidad</li>
</ul>


<p>Comparativa entre subir al Everest y desarrollar un lenguaje, Sherpas, todos somos Sherpas, y debemos compartir la carga (de José Valim y su equipo) para hacer de Elixir, Phoenix y Elm un gran lenguaje.</p>

<p>También espero que poco a poco, según vaya necesitando saber más sobre cómo
hacer cosas con el lenguaje, vaya descubriendo blogs y autores acerca del
lenguaje.</p>

<h2>Plan de aprendizaje</h2>

<p>Por ahora no tengo ningún plan. El más básico que tengo es empezar a leer el
libro Programming Elixir y cuando sea capaz de escribir algún programa más
complejo que un <em>Hola mundo</em> empezar a resolver problemas en exercism.io.</p>

<p>A partir de ahí, el tiempo dirá.</p>

<h2>Recursos filtrados</h2>

<p>Creo que no tengo tantos recursos como para filtrarlos. Empezando con el libro,
con exercism.io y de vez en cuando la web oficial del lenguaje puede ser
suficiente para ir cogiendo ritmo.</p>

<h2>Asaltos</h2>

<ol>
<li><a href="http://localhost:4000/blog/2016/02/09/elixir-primer-asalto/">Primer asalto</a>: tipos, funciones, pattern matching y módulos</li>
</ol>

]]></content>
  </entry>
  
</feed>
