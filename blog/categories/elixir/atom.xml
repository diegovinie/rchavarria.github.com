<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: elixir | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/elixir/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2018-03-06T22:23:39+01:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir: duodécimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2018/02/18/elixir-duodecimo-asalto/"/>
    <updated>2018-02-18T22:08:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2018/02/18/elixir-duodecimo-asalto</id>
    <content type="html"><![CDATA[<p>Este será el último asalto relativo a <a href="http://elixir-lang.org/">Elixir</a> por ahora, y en él aprenderemos
qué son las <a href="https://hexdocs.pm/elixir/Task.html">Tasks</a> y los <a href="https://hexdocs.pm/elixir/Agent.html">Agents</a>, que se podrían traducir como <em>tareas</em> y
<em>agentes</em>.</p>

<p>Éstas serán las dos últimas abstracciones de Elixir que vamos a estudiar. No
son de tan bajo nivel como las primitivas <code>spawn</code>, <code>send</code> y <code>receive</code> que vimos
en el <a href="/blog/2016/09/18/elixir-septimo-asalto/">séptimo asalto</a> y tampoco son tan pesados como el <a href="http://erlang.org/doc/">framework OTP</a>.</p>

<p>Son un punto intermedio. Utilizan funcionalidades de OTP, pero nos aíslan de
muchos detalles, lo que hace que trabajar con procesos y procesos distribuidos
sea muchísimo más fácil.</p>

<p><img class="center" src="/images/2018/down-the-board.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/majY5a">Down the board</a> de <a href="https://www.flickr.com/photos/erinthomaswilson/">Erin</a>, <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">CC BY-NC-ND 2.0</a>
  </span>
</div>




<!-- more -->


<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Tareas</h4>

<p>Una tarea o <code>Task</code> es una función que se ejecuta en segundo plano. Existen dos
funciones principales: <code>async</code> y <code>await</code> y su forma de usarla sería la
siguiente:</p>

<p>```</p>

<h1>...</h1>

<h1>Realizar una computación que tarde mucho tiempo</h1>

<p>worker = Task.async(fn -> Fibonacci.of(200000) end)</p>

<h1>...</h1>

<h1>Obtener el valor devuelto por la función</h1>

<p>result = Task.await(worker)</p>

<h1>...</h1>

<p>```</p>

<p><code>async</code> crea un proceso separado que ejecuta la función. Devuelve un descriptor
del proceso o <em>worker</em>. <code>await</code> espera a que el proceso termine para recuperar
el valor devuelto por la función. En lugar de pasar una función, también
podemos pasar el nombre de un módulo, función y parámetros:
<code>Task.async(Fibonacci, :of, [ 200000 ])</code>.</p>

<p>Las <code>Task</code>s están implementadas como servidores OTP, por lo que podemos
incluirlas en nuestro árbol de supervisión de aplicaciones. Existen dos formas:</p>

<ol>
<li>Pasando la función a ejecutar a <code>Task.start_link</code> en lugar de llamar a
<code>Task.async</code> desde un proceso que ya esté supervisado</li>
<li>Creando un worker desde un supervisor:</li>
</ol>


<p><code>
import Supervisor.Spec
children = [
  worker(Task, [ fn -&gt; do_something_extraordinary() end ])
]
supervise children, strategy: :one_for_one
</code></p>

<h4>Agentes</h4>

<p>Un agente o <code>Agent</code> es un proceso también en segundo plano que mantiene un
estado. El estado puede ser accedido desde un proceso, nodo o múltiples nodos.</p>

<p>El estado inicial se toma desde una función que se le pasa a la hora de
arrancar el <code>Agent</code>.</p>

<p>Se utiliza <code>Agent.get</code> para obtener el estado. Hay que pasarle una función,
cuyo parámetro será el estado actual del <code>Agent</code>. El valor devuelto por
<code>Agent.get</code> es el valor devuelto por la función.</p>

<p>Se utiliza <code>Agent.update</code> para modificar el estado. También hay que pasar una
función. El valor devuelto por la función será el nuevo estado.</p>

<p>Veamos un ejemplo:</p>

<p>```</p>

<h1>count es el descriptor del Agent</h1>

<p>iex> { :ok, count } = Agent.start(fn -> 0 end)
{:ok, #PID&lt;0.69.0>}
iex> Agent.get(count, &amp;(&amp;1))
0            </p>

<h1>incrementa el en uno el estado</h1>

<p>iex> Agent.update(count, &amp;(&amp;1+1))
:ok          
iex> Agent.update(count, &amp;(&amp;1+1))
:ok          </p>

<h1>obtiene el estado actual</h1>

<p>iex> Agent.get(count, &amp;(&amp;1))
2
```</p>

<p>Los agentes son una abstracción especialmente pensada para almacenar el estado
de nuestros procesos. Por lo tanto, se recomienda no guardar el estado en
nuestros procesos, si no que los procesos que creemos nosotros usen un <code>Agent</code>
para almacenar. De esta forma, en caso de fallo en nuestro proceso, el estado
estará todavía disponible en el <code>Agent</code>, ya que es un proceso diferente al
nuestro.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: undécimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/10/30/elixir-undecimo-asalto/"/>
    <updated>2017-10-30T21:06:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/10/30/elixir-undecimo-asalto</id>
    <content type="html"><![CDATA[<p>Nos acercamos al final y en este asalto aprenderemos qué son las <a href="https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html">Aplicaciones
OTP</a>, aunque en realidad ya hemos estado usando algunas. Aprenderemos cómo
<code>mix</code> facilita mucho la tarea y cómo esta herramienta nos permite empaquetar
nuestra aplicación para ser distribuida. Aprenderemos a definir el punto de
entrada de ejecución y cómo pasar parámetros iniciales. Las aplicaciones, junto
con los servidores y supervisores OTP hacen de este framework una herramienta
potentísima para desarrollar aplicaciones.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/fingers.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/9cXZUG">Asaltos</a> de <a href="https://www.flickr.com/photos/antoniobugarin/">Antonio Bugarin</a>, <a href="https://creativecommons.org/licenses/by/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Aplicaciones OTP</h4>

<p>Una <em>aplicación</em> en el mundo Elixir no es lo que normalmente conocemos como
tal. El término viene del mundo Erlang, y con <em>aplicación</em> se refieren más a lo
que comúnmente conocemos como componente, o servicio (¿microservicio podría
valer aquí?, probablemente). Una aplicación OTP en Elixir es como un servicio
del que puede depender de otros servicios, y que puede arrancar servidores y
supervisores.</p>

<p>Por lo general, las aplicaciones son dependencias de los programas que estamos
desarrollando. Pero otras aplicaciones residen en la parte más alta del árbol
de procesos, y éstas están diseñadas para ejecutarse directamente.</p>

<p><strong>El fichero de configuración de la aplicación</strong></p>

<p>La herramienta <code>mix</code> crea un fichero llamado <code>&lt;tu-aplicacion&gt;.app</code>. Este
fichero es la especificación de la aplicación, y contiene información que se
suele escribir en <code>mix.exs</code> e información de la compilación de nuestro código.
Cuando se lanza la aplicación, este fichero es consultado para saber cómo
cargarla y arrancarla.</p>

<p><strong>Creando una aplicación OTP</strong></p>

<p>En realidad ya hemos creado varias. Por ejemplo, el programa <em>Sequence</em>, de la
ronda anterior, lo ejecutábamos como si fuera una aplicación OTP. Cuando
creamos un nuevo proyecto con <code>mix</code>, éste añade un supervisor por defecto e
información en <code>mix.exs</code> para poder ejecutar el proyecto como una aplicación.
Más concretamente, <code>mix</code> crea la función <code>application</code>:</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] }
</code></pre>

<p>  ]
end
```</p>

<p>El código anterior indica que el módulo principal se llama <code>Sequence</code>. OTP
asume que dicho módulo implementa una función llamada <code>start</code> (porque Elixir
define un <em>behaviour</em> <code>Application</code> que deben implementar las aplicaciones OTP
para ser consideradas como tal), a la cual le va a pasar el parámetro indicado
en la tupla (en este caso un array vacío). Si la tupla hubiera sido <code>{
Sequence, 1234 }</code> el parámetro pasado a la función <code>start</code> hubiera sido <code>1234</code>.</p>

<p>Esto es lo relativo a la opción <code>mod:</code>. Pero a la hora de configurar una
aplicación existe otra opción: <code>registered:</code>. Esta opción lista los nombres que
nuestra aplicación va a registrar. Podemos usar esto si queremos que dichos
nombres sean únicos entre todas las aplicaciones cargadas en el nodo o cluster:</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] },
registered: [
  Sequence.Server,
  "Any other name"
]
</code></pre>

<p>  ]
end
```</p>

<p>Ahora podemos ejecutar el comando <code>mix compile</code> para generar el fichero <code>.app</code>.
Este fichero se almacena en la ruta nada intuitiva de
<code>_build/dev/lib/sequence/ebin</code>. Este fichero define una tupla Erlang que define
la aplicación. <code>mix</code> ha añadido automáticamente los módulos de los que consta
la aplicación y las aplicaciones de las que depende, por ejemplo <code>kernel</code>,
<code>stdlib</code> o <code>elixir</code>.</p>

<p>A la hora de pasar parámetros de inicialización a las aplicaciones existe otra
posibilidad. La opción <code>env</code>, que acepta una lista de palabras clave (<em>keyword
list</em>)</p>

<p>```
def application do
  [</p>

<pre><code>mod: { Sequence, [] },
env: [ initial_number: 12334 ],
registered: [...]
</code></pre>

<p>  ]
end
```</p>

<p>Para después recuperar ese valor con <code>Application.get_env</code>:</p>

<p>```
defmodule Sequence do
  use Application
  def start(<em>type, </em>args) do</p>

<pre><code>initial_number = Application.get_env(:sequence, :initial_number)
#...
</code></pre>

<p>```</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-11/stack">Ejercicio 1</a>: convierte tu servidor <code>Stack</code> en una aplicación OTP</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/sequence">Ejercicio 2</a>: hasta ahora no hemos testeado para nada ninguna aplicación.
Mira a ver qué puedes hacer. Testear un server no parece algo muy sencillo,
no parece que se pueda ejecutar a la primera, porque el server debería estar
ejecutándose para poder <em>funcionar</em>. Pero Elixir está muy enfocado a los tests
automáticos, así que algo debe de existir.</p></li>
</ul>


<p><strong>Resultados</strong></p>

<p>Y tanto que existe. Encontré el artículo <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html#testing-a-genserver">cómo se testea un <code>GenServer</code></a>, en la
documentación oficial: básicamente, en el <em>set up</em> de los tests, se levanta el
server. Luego, se puede llamar a la API del servidor tranquilamente. Al
parecer, si el proyecto está configurado como una aplicación, <code>mix</code> arranca la
aplicación, por lo que no hace falta levantar el server en el <em>set up</em>. Lo
malo, que no se puede inicializar con ningún valor de test.</p>

<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: décimo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/06/07/elixir-decimo-asalto/"/>
    <updated>2017-06-07T21:29:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2017/06/07/elixir-decimo-asalto</id>
    <content type="html"><![CDATA[<p>En este asalto aprenderemos qué son los <a href="https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html">Supervisores OTP</a> y cómo se puede
crear una estructura jerárquica de ellos de forma que monitoricen nuestros
procesos y sean capaz de arrancar nuevos procesos en caso de que alguno de
ellos falle. También veremos cómo unos procesos sirven de ayuda para guardar el
estado de aquellos procesos que necesitan ser tolerantes a fallos.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/darth-grader.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/pxJ3o5">Darth Grader</a> de <a href="https://www.flickr.com/photos/jdhancock/">JD Hancock</a>, <a href="https://creativecommons.org/licenses/by/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Supervisores OTP</h4>

<p>La forma de hacer las cosas en Elixir es no preocuparse mucho por el código que
falla, si no asegurarse de que la aplicación en general sigue corriendo. Suena
contradictorio, pero no lo es. En Elixir los procesos son muy pequeñitos, por
lo que si uno de ellos falla, casi todo el sistema sigue funcionando. Al
contrario que en otros lenguajes, donde el lanzamiento de una excepción puede
hacer que todo el servidor sufra. <strong>En el mundo OTP, los supervisores son
quienes monitorizan y recuperan esos procesos fallidos</strong>.</p>

<p>Un supervisor en Elixir tiene un único propósito: manejar uno o más <em>workers</em>
(otro tipo de procesos). La forma de funcionar es darle una lista de procesos e
indicarle qué hacer con cada uno de ellos en caso de que falle. La forma más
fácil de crear un supervisor es crear un nuevo proyecto con <code>mix</code> y usar el
flag <code>--sup</code>.</p>

<p>```
defmodule Sequence do
  use Application
  def start(<em>type, </em>args) do</p>

<pre><code>import Supervisor.Spec, warn: false
children = [
  worker(Sequence.Worker, [arg1, arg2, arg3])
]
opts = [strategy: :one_for_one, name: Sequence.Supervisor]

# create the supervisor with a list of workers and some options
Supervisor.start_link(children, opts)
</code></pre>

<p>  end
end
```</p>

<h4>Gestionando el estado del servidor entre reinicios</h4>

<p>Como se puede comprobar al jugar con el supervisor y el servidor creados en el
[Ejercio 01], el servidor es reiniciado, pero no mantiene el estado anterior al
fallo, si no que siempre se reinicia con el estado inicial, indicado a la hora
de crear el supervisor. Esto se puede mejorar.</p>

<p>La forma de mantener el estado es almacenándolo fuera del proceso servidor.
Esto se hace mediante un nuevo <em>worker</em>, un nuevo servidor, al que se le llama
<em>stash</em>. Nuestro servidor almacenará su estado actual en ese <em>stash worker</em>. El
<em>stash worker</em> debe ser monitorizado por un supervisor diferente, por lo que
tenemos que crear un arbol de supervisores. En este árbol, nuestro <em>worker</em>
principal debe conocer el PID del <em>stash</em>, con lo que la forma de crear el
árbol cambia ligeramente de la forma que hemos visto anteriormente.</p>

<p><img class="center" src="/images/2017/supervisor-tree.png"></p>

<p>La aplicación funcionaría de la siguiente forma:</p>

<ol>
<li>Primero, arrancamos el supervisor raíz del árbol, pasándole el valor inicial
que será el estado inicial del sistema</li>
<li>Este supervisor arranca el <em>stash worker</em>, pasando el valor inicial (porque
este worker almacenará el estado del sistema) y arranca un sub-supervisor,
pasándole el PID del stash</li>
<li>El sub-supervisor arranca el worker principal, el que contiene la lógica,
quien incrementa el valor inicial con el que arrancamos el sistema</li>
<li>El worker principal, nada más arrancar, consulta al stash worker el estado
actual, y es con ese estado con el que va a trabajar</li>
<li>Si el worker principal falla por cualquier causa, debe enviar su estado al
stash worker, para que lo almacene</li>
<li>El sub-supervisor detectará que el proceso a muerto y reiniciará de nuevo el
worker principal, que leerá el estado del worker que murió del stash worker</li>
</ol>


<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/stack">Ejercicio 1</a>: añade un supervisor a la aplicación anterior que implementaba
una pila de enteros</li>
</ul>


<p><strong>Resultado</strong></p>

<p>Increíble, increíble que sea tan fácil. Lo primero, el supervisor arranca él
solito y levanta el servidor él solito también. Super cómodo. Luego, captura
los errores y levanta de nuevo el servidor sin que nosotros tengamos que hacer
nada más. Para hacer fallar a la pila, se podía hacer con un
<code>Stack.Server.push -1</code>. El supervisor captura el fallo, y rearranca el
servidor.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-10/sequence">Ejercicio 2</a>: vuelve a crear una aplicación similar a la anterior, pero
creando un árbol de supervisores, y un stash worker, de forma que cuando el
worker principal falle, el estado sea guardado. Comprueba que el sistema
mantiene el estado cuando el worker principal falla</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cómo desplegar una aplicación Elixir/Phoenix en Heroku]]></title>
    <link href="http://rchavarria.github.io/blog/2017/03/19/desplegar-aplicacion-elixir-phoenix-heroku/"/>
    <updated>2017-03-19T13:44:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/03/19/desplegar-aplicacion-elixir-phoenix-heroku</id>
    <content type="html"><![CDATA[<p><a href="http://heroku.com/">Heroku</a> es una plataforma donde los desarrolladores pueden desplegar sus aplicaciones (sobre todo está pensado para aplicaciones web) y hacerlas públicas de forma gratuita o por un pequeño precio. Yo he utilizado a veces este servicio para hacer pruebas con servidores en JavaScript (NodeJS) o PHP, pero también admite muchos otros lenguages de programación: Ruby, Java, Python, Go,...</p>

<p><img class="center" src="/images/2017/elixir-phoenix-heroku.png"></p>

<p>No es ningún secreto que estoy <a href="/blog/2016/01/17/aprendiendo-elixir/">tonteando con Elixir</a>, y <a href="http://www.phoenixframework.org/">el framework Phoenix</a> es el framework por referencia para crear aplicaciones web en Elixir. Pero ese no es un lenguaje soportado por Heroku, así que parecía un poco complejo poder hacer unas pruebas desplegando una aplicación Elixir/Phoenix en Heroku.</p>

<p>Por suerte, <a href="http://wsmoak.net/about.html">Wendy Smoak</a> escribió un artículo hace un tiempo hablando de esto mismo: <a href="http://wsmoak.net/2015/07/05/phoenix-on-heroku.html">Deploying a Phoenix app to Heroku</a>. Dicho artículo tiene licencia <a href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons CC-BY-NC</a>. Este post no es una traducción en sí, pero como está basado en él me parece justo y obligatorio respetarla. Así que este post está basado en el artículo <a href="http://wsmoak.net/2015/07/05/phoenix-on-heroku.html">Deploying a Phoenix app to Heroku</a>, de <a href="http://wsmoak.net/about.html">Wendy Smoak</a>, y también está licenciado bajo la <a href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons CC-BY-NC</a>, digan lo que digan el resto de posts de este blog.</p>

<!-- more -->


<h2>Requisitos</h2>

<p>Para poder llevar a cabo el despliegue, necesitamos todas estas herramientas. Yo lo he probado con estas versiones:</p>

<ul>
<li>Elixir, versión 1.3.1. El cuál, necesita Erlang/OTP, por ejemplo la versión 19</li>
<li>Phoenix, versión 1.2.1</li>
<li>Phoenix necesita de NodeJS, yo tengo instalada la versión 5.12.0; y también necesita (normalmente) de una base de datos, comúnmente, PostgreSQL, yo he utilizado la versión 9.5, que viene mi distribución Ubuntu</li>
<li>Git, versión 2.7.4</li>
<li>Heroku toolbelt, versión 3.43.14; Heroku CLI, versión 5.6.31; este post también asume que nos hemos dado de alta en Heroku y hemos configurado estas herramientas.</li>
</ul>


<h2>Creando una aplicación Phoenix</h2>

<p>Crear el esqueleto de una aplicación Phoenix es ridículamente sencillo, simplemente un comando:</p>

<pre><code>$ mix phoenix.new rchavarria_deploys_phoenix_heroku
[ ... ]
Fetch and install dependencies? [Yn] Y
[ ... ]
</code></pre>

<p>Para poder llevar un control de lo que hacemos o dejamos de hacer, pondremos la aplicación bajo un control de versiones. Además, Heroku está pensado para funcionar con aplicaciones donde el control de versiones es Git, así que...</p>

<pre><code>$ cd rchavarria_deploys_phoenix_heroku
$ git init
$ git add .
$ git commit -m "Primera piedra de la aplicación Phoenix desplegada en Heroku"
</code></pre>

<p>Si queremos, podemos subir esta aplicación a GitHub u otro servicio que nos permita tener nuestras aplicación bajo Git.</p>

<h2>Creando una aplicación Heroku</h2>

<p>También es muy sencillo:</p>

<pre><code>$ heroku create
Creating app... done, ⬢ dry-anchorage-96713
https://dry-anchorage-96713.herokuapp.com/ | https://git.heroku.com/dry-anchorage-96713.git
Git remote heroku added
</code></pre>

<p>También se puede indicar el nombre de nuestra app en el comando <code>heroku create</code>. Heroku nos ha dado un nombre aleatorio, y podremos acceder a ella a través de la URL <a href="https://dry-anchorage-96713.herokuapp.com/">https://dry-anchorage-96713.herokuapp.com/</a>.</p>

<p>Heroku habrá añadido un nuevo <em>remote</em> a nuestro repositorio de <code>git</code>:</p>

<pre><code>$ git remote -v
heroku  https://git.heroku.com/dry-anchorage-96713.git (fetch)
heroku  https://git.heroku.com/dry-anchorage-96713.git (push)
</code></pre>

<h2>Añadiendo <em>buildpacks</em> a la applicación Heroku</h2>

<blockquote><p>Los <a href="https://devcenter.heroku.com/articles/buildpacks">buildpacks</a> son los encargados de transformar el código desplegado en un <em>slug</em>, el cual puede ser ejecutado en un <em>dyno</em>.</p></blockquote>

<p>Y después de toda esa jerga de Heroku, en cristiano quiere decir algo así: los <em>buildpacks</em> son un conjunto de herramientas que convierten y empaquetan tu código de forma que puedan ser ejecutados por la infraestructura de Heroku.</p>

<p>Heroku proporciona buildpacks por defecto: Java, Python, PHP, JavaScript,... Pero afortunadamente, también existen para Elixir y Phoenix, aunque no están mantenidos por Heroku.</p>

<p>Primero, debemos añadir el buildpack para Phoenix, conocido como <a href="https://github.com/gjaldon/heroku-buildpack-phoenix-static">Phoenix static buildpack</a>:</p>

<pre><code>$ heroku buildpacks:set https://github.com/gjaldon/phoenix-static-buildpack
Buildpack set. Next release on dry-anchorage-96713 will use https://github.com/gjaldon/phoenix-static-buildpack.
Run git push heroku master to create a new release using this buildpack.
</code></pre>

<p>Después, añadimos el <a href="https://github.com/HashNuke/heroku-buildpack-elixir">buildpack de Elixir</a>, configurándolo en primera posición:</p>

<pre><code>$ heroku buildpacks:add --index 1 https://github.com/HashNuke/heroku-buildpack-elixir
Buildpack added. Next release on dry-anchorage-96713 will use:
  1. https://github.com/HashNuke/heroku-buildpack-elixir
  2. https://github.com/gjaldon/phoenix-static-buildpack
Run git push heroku master to create a new release using these buildpacks.
</code></pre>

<h2>Ultimando los detalles del despliegue</h2>

<p>Si intentamos realizar ahora el despliegue, obtendremos un error:</p>

<pre><code>$ git push heroku master
[ ... ]
remote: -----&gt; Fetching app dependencies with mix
remote:     ** (Code.LoadError) could not load [...]/config/prod.secret.exs
[ ... ]
remote: ! Push rejected to dry-anchorage-96713.
[ ... ]
</code></pre>

<p>Para poder desplegar, necesitamos subir el fichero <code>prod.secret.exs</code>. Pero ese fichero está ignorado en <code>.gitignore</code>, por lo que no será subido mediante el comando <code>git push heroku master</code>. Y está ignorado por una buena razón. Ese fichero suele contener información sensible.</p>

<p>Pero tiene solución. Debemos sustituir la información sensible por valores tomados de variables de entorno. Editamos <code>prod.secret.exs</code>, de forma que quede parecido a:</p>

<pre><code>use Mix.Config

# In this file, we keep production configuration that
# you likely want to automate and keep it away from
# your version control system.
#
# You should document the content of this
# file or create a script for recreating it, since it's
# kept out of version control and might be hard to recover
# or recreate for your teammates (or you later on).
config :rchavarria_deploys_phoenix_heroku, RchavarriaDeploysPhoenixHeroku.Endpoint,
  secret_key_base: System.get_env("SECRET_KEY_BASE")

# Configure your database
config :rchavarria_deploys_phoenix_heroku, RchavarriaDeploysPhoenixHeroku.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: System.get_env("DATABASE_USERNAME"),
  password: System.get_env("DATABASE_PASSWORD"),
  database: "rchavarria_deploys_phoenix_heroku_prod",
  pool_size: 20
</code></pre>

<p>También debemos editar <code>.gitignore</code>, para dejar de ignorar <code>prod.secret.exs</code>.</p>

<p>No olvides hacer commit de estos cambios:</p>

<pre><code>$ git add .
$ git commit -m "Incluir prod.secret.exs, sustituyendo secretos por variables de entorno"
</code></pre>

<h2>Desplegando</h2>

<p>Ahora sí, ya podemos desplegar.</p>

<p>El despliegue no debería dar ningún problema, porque aunque no hemos creado ninguna variable de entorno, la aplicación básica de Phoenix no accede a la base de datos, por lo que la configuración de <code>prod.secret.exs</code> no debería tener ningún efecto todavía.</p>

<pre><code>$ git push heroku master
remote: -----&gt; Elixir app detected
remote: -----&gt; Installing Erlang 18.3 (changed)
remote: -----&gt; Installing Elixir v1.3.4 (changed)
remote: -----&gt; Compiling
remote: Generated rchavarria_deploys_phoenix_heroku app
remote:        Installing Node 6.9.2...
remote: -----&gt; Building dependencies
remote: -----&gt; Finalizing build
remote: -----&gt; Launching...
remote:        https://dry-anchorage-96713.herokuapp.com/ deployed to Heroku
remote: Verifying deploy... done.
To https://git.heroku.com/dry-anchorage-96713.git
</code></pre>

<p>Y se puede ver la aplicación accediendo a <a href="https://dry-anchorage-96713.herokuapp.com/">https://dry-anchorage-96713.herokuapp.com/</a> (si es que todavía existe como aplicación Heroku).</p>

<h2>Completando la configuración</h2>

<p>Tarde o temprano, vamos a necesitar que nuestra aplicación acceda a la base de datos. Por lo que tendremos que configurar nuestras variables de entorno. Para ello, son necesarios dos pasos:</p>

<ol>
<li>Configurarlas y exportarlas en Heroku (documentación sobre <a href="https://devcenter.heroku.com/articles/config-vars">variables de configuración de Heroku</a>)</li>
</ol>


<p><code>
$ heroku config:set SECRET_KEY_BASE=&lt;y aquí mi secreto&gt;
$ heroku config:set SOME_VAR=&lt;el valor para esta variable&gt;
</code></p>

<ol>
<li>Editar (o crear) <code>elixir_buildpack.config</code> en la raíz del proyecto. Aquí deberemos configurar qué variables queremos exportar. Cuidado, porque estos valores sobreescriben los exportados por los buildpacks, por lo que deberemos incluir aquellas que incluyan los buildpacks de Elixir y Phoenix. Un ejemplo de <code>elixir_buildpack.config</code> podría ser tan sencillo como:</li>
</ol>


<p><code>
configu_vars_to_export=(DATABASE_URL SECRET_KEY_BASE)
</code></p>

<h2>Agradecimientos</h2>

<p>Todo el mérito de esta información no es mío, es gracias a <a href="http://wsmoak.net/about.html">Wendy Smoak</a>, autora del post sobre el que se basa este; <a href="http://hashnuke.com/">HashNuke</a>, autor del buildpack para Elixir; <a href="http://gabrieljaldon.com/">gjaldon</a>, autor del buildpack para Phoenix; y otros que ayudaron a Wendy con sus dudas.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: noveno asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2017/01/29/elixir-noveno-asalto/"/>
    <updated>2017-01-29T17:19:00+01:00</updated>
    <id>http://rchavarria.github.io/blog/2017/01/29/elixir-noveno-asalto</id>
    <content type="html"><![CDATA[<p>En el <a href="/blog/2016/12/31/elixir-octavo-asalto/">asalto anterior</a> aprendimos un par de conceptos básicos sobre los nodos.
En este asalto aprenderemos sobre servidores OTP: qué son, para qué sirven, por
qué son útiles y cómo implementarlos fácilmente.</p>

<p>Todo esto, siguiendo el <a href="/blog/2016/01/17/aprendiendo-elixir/">método de aprendizaje</a> con el que comenzé la serie:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2017/us-air-force.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/R7mJ4M">160324-F-XK483-042</a> de <a href="https://www.flickr.com/photos/usairforce/">US Air Force</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/">CC BY NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<h4>Servidores OTP</h4>

<p>OTP (<strong>O</strong>pen <strong>T</strong>elecom <strong>P</strong>latform) se presenta como la solución a todos
tus problemas de escalabilidad y concurrencia. No es así, pero ayuda mucho.
Ayuda en temas como descubrimiento de aplicaciones, gestión y detección de
fallos, actualización de código en caliente y estructura del servidor.</p>

<p>OTP define un sistema como una jerarquía de <strong>aplicaciones</strong>. Una aplicación
consiste en uno o varios <strong>procesos</strong>. Cada uno de estos procesos implementa
un <strong>comportamiento</strong>. Existen <a href="http://rubenfa.github.io/2016-11-30-behaviours-en-elixir">comportamientos</a> para servidores, gestores de
eventos, máquinas de estado finitas, ...</p>

<p>Lo implementado en ejercicios anteriores sigue un patrón con el que se podría
implementar casi todos los servidores. Por eso, OTP proporciona un mecanismo
para liberarnos de escribir el código más tedioso. La librería ofrece unas
funciones a modo de <em>callbacks</em> que irá llamando dependiendo de la situación.</p>

<h4>Implementar un servidor OTP</h4>

<p>```
defmodule Sequence.Server do
  use GenServer</p>

<p>  def handle_call(:next_number, _from, current_number) do</p>

<pre><code>{ :reply, current_number, current_number + 1 }
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>use GenServer</code> indica a Elixir que vamos a usar este comportamiento. Así, este
módulo representa un servidor OTP.</p>

<p>Uno de los callbacks proporcionados por <code>GenServer</code> es <code>handle_call</code>. Tiene 3
parametros: acción, PID del origen de la petición y el estado actual del
servidor. Tiene que responder con una tupla con tres parámetros también: la
respuesta, el valor retornado y el estado del servidor a usar en la siguiente
llamada.</p>

<p>Para llamar a este servidor, entramos en <code>iex</code>. Arrancamos el servidor,
indicando el módulo y el estado inicial (similar a <code>spawn_link</code>).</p>

<p><code>
promtp$ iex -S mix
iex&gt; { :ok, pid } = GenServer.start_link(Sequence.Server, 100)
iex&gt; GenServer.call(pid, :next_number)
100
iex&gt; GenServer.call(pid, :next_number)
101
iex&gt; GenServer.call(pid, :next_number)
102
</code></p>

<h4>Servidores que no tienen que devolver un resultado</h4>

<p>En ocasiones no necesitamos que el servidor retorne un resultado. En estos
casos, para llamar al servidor emplearemos <code>GenServer.cast</code>, y para manejar
esas peticiones, nuestro servidor debe implementar el callback <code>handle_cast</code>.</p>

<h4>Callbacks de GenServer</h4>

<p>GenServer es un protocolo de OTP. OTP asume que este protocolo define 6
callbacks. Elixir proporciona una implementación por defecto para cada uno de
ellos en GenServer, por eso no tenemos que implementarlos nosotros. Los 6
callbacks son: <code>init(start_arguments)</code>, <code>handle_call(request, from, state)</code>,
<code>handle_cast(request, state)</code>, <code>handle_info(info, state)</code>,
<code>terminate(reason, state)</code>, <code>code_change(from_version, state, extra)</code> y
<code>format_status(reason, [ pdict, state ])</code>.</p>

<h4>Nombrado de procesos</h4>

<p>En lugar de usar el PID para referenciar a procesos de nuestro servidor,
podemos hacerlo a través de nombres. Para ello, se debe utilizar la opción
<code>name:</code> a la hora de crear el servidor:</p>

<p><code>
iex&gt; { :ok, pid } = GenServer.start_link(Sequence.Server, 100, name: :seq)
iex&gt; GenServer.call(:seq, :next_number)
100
iex&gt; GenServer.call(:seq, :next_number)
101
iex&gt; GenServer.call(:seq, :next_number)
102
iex&gt; :sys.get_status :seq
</code></p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack">Ejercicio 01</a>: crear un server que implemente una pila. Se
inicializará con unos cuantos valores en la pila. Cada petición <em>pop</em>
devolverá un elemento de la pila. Cuando la pila esté vacía, fallará.
Implementado en el proyecto <code>mix</code>: <code>code/round-09/stack</code>.</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack2">Ejercicio 02</a>: ampliar el servidor anterior, de forma que se puedan
añadir elementos a la pila con la operación <code>:push</code> a través de peticiones
<em>cast</em>. Implementado en el proyecto <code>mix</code>: <code>code/round-09/stack2</code>.</p></li>
<li><p><a href="https://github.com/rchavarria/learning-elixir/tree/master/code/round-09/stack3">Ejercicio 03</a>: dar un nombre al servidor anterior, de forma que se le
pueda llamar sin necesidad de saber el PID. También, crear un API en la pila
de forma que los clientes no tengan que llamar a <code>GenServer</code> para usarla.
Simplemente serán unas funciones que envolverán las llamadas a <code>GenServer</code>.
Implementado en otro proyecto <code>mix</code>, en <code>code/round-09/stack3</code>.</p></li>
<li><p>Ejercicio 04: implementar el callback <code>GenServer.terminate/2</code> para
comprobar distintas formas de terminar el servidor: un callback lanza una
excepción, una llamada a <code>Kernel.exit/1</code>, se detecta que un proceso ha tenido
un error,...</p></li>
</ul>


<p><strong>Resultado</strong></p>

<p>No he obtenido nada en claro. Tendría que profundizar en la documentación de
<a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html#c:terminate/2"><code>GenServer.terminate/2</code></a>,
que parece bastante espesa por cierto. Pero no está garantizado que se llame a
<code>terminate</code>, con lo que no sé si estoy provocando correctamente los errores.</p>

<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>

<h2>Referencias</h2>

<ul>
<li>Proceso de <a href="/blog/2016/01/17/aprendiendo-elixir/">aprendizaje de Elixir</a></li>
<li>Artículo sobre <a href="http://rubenfa.github.io/2016-11-30-behaviours-en-elixir">comportamientos</a> (<em>behaviours</em>) en Elixir</li>
<li>Artículo sobre <a href="http://rubenfa.github.io/2017-01-25-protocols-en-elixir">protocolos</a> en Elixir</li>
</ul>

]]></content>
  </entry>
  
</feed>
