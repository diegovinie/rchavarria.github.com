<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: elixir | R. Chavarria's Blog]]></title>
  <link href="http://rchavarria.github.io/blog/categories/elixir/atom.xml" rel="self"/>
  <link href="http://rchavarria.github.io/"/>
  <updated>2016-09-14T21:59:27+02:00</updated>
  <id>http://rchavarria.github.io/</id>
  <author>
    <name><![CDATA[Rub&eacute;n Chavarr&iacute;a]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elixir: sexto asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/09/14/elixir-sexto-asalto/"/>
    <updated>2016-09-14T21:32:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/09/14/elixir-sexto-asalto</id>
    <content type="html"><![CDATA[<p>Sexto asalto. En esta ocasión no veremos nada del lenguaje, si no del
ecosistema de <a href="http://elixir-lang.org/">Elixir</a>. Elixir viene acompañado de unas magníficas herramientas
que complementan en lenguaje de programación en sí: <code>mix</code>, la herramienta de
construcción de aplicaciones y herramientas de testing como <code>ExUnit</code> y
<code>DocTests</code>. Además de estas herramientas, exploraremos también los sitios web
donde los desarrolladores alojan la mayoría de las librerías y proyectos Elixir
disponibles.</p>

<p>Sigo con la metodología de aprendizaje explicada en el <a href="/blog/2016/01/17/aprendiendo-elixir/">primer post sobre Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/more-gladiators.png"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/6xvcMz">More gladiators</a> de <a href="https://www.flickr.com/photos/archeon/">Hans Splinter</a>, <a href="https://creativecommons.org/licenses/by-nd/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p>Elixir viene con la herramienta <code>mix</code>, la herramienta oficial de construcción
de proyectos (creación, testeo, construcción, gestión de dependencias,...). En
este asalto crearemos una aplicación que nos permitirá listar los últimos <code>n</code>
<em>issues</em> de cualquier proyecto de <a href="https://github.com">GitHub</a>.</p>

<p><code>mix help</code> lista los comandos disponibles. Los más interesantes podrían ser:
<code>mix run</code> para ejecutar el proyecto, <code>mix test</code> para ejecutar los tests o <code>mix
new</code> para crear uno nuevo.</p>

<p>Crearemos un nuevo proyecto, llamado <code>rct_issues</code>:</p>

<p><code>
$ mix new rct_issues
</code></p>

<p>Listando los ficheros y directorios que ha creado el comando, encontramos los
siguientes:</p>

<ul>
<li><code>/README.md</code>: aquí podemos poner la descripción del proyecto.</li>
<li><code>/config/</code>: donde vivirá la configuración del proyecto</li>
<li><code>/lib/</code>: aquí irá el código fuente de nuestro proyecto</li>
<li><code>/test/</code>: aquí irá el código de tests</li>
<li><code>mix.exs</code>: opciones de configuración del proyecto en sí</li>
</ul>


<p><strong>Transformación: parsear la línea de comandos</strong></p>

<p>La aplicación de ejemplo tomará los parámetros de la línea de comandos. Las
aplicaciones Elixir consisten en una serie de transformaciones, y la primera de
ellas será la de parsear la línea de comandos.</p>

<p>En Elixir existen una serie de convenciones:</p>

<ul>
<li>El código que gestiona la línea de comandos va en un módulo llamado
<code>&lt;proyecto&gt;.CLI</code>, así que nuestro código iría en un módulo llamado
<code>RctIssues.CLI</code></li>
<li>Cada módulo va en un fichero distinto</li>
<li>Cada módulo va dentro del espacio de nombres del proyecto, por lo que todos
los módulos colgarán de <code>RctIssues</code></li>
<li>Los <em>espacios de nombres</em> corresponden con directorios en el árbol del
proyecto. Así, el módulo <code>RctIssues.CLI</code> se escribiría en el directorio
<code>/lib/rct_issues/cli.ex</code>. Ver fichero de código fuente <a href="https://github.com/rchavarria/learning-elixir/blob/master/projects/rct_issues/lib/rct_issues/cli.ex">cli.ex</a></li>
</ul>


<p><strong>Los primeros tests</strong></p>

<p>Elixir viene con un pequeño framework de testing llamado <code>ExUnit</code>.</p>

<p>En el fichero <code>/test/cli_test.exs</code> escribiremos los tests para el módulo que
acabamos de escribir (echar un vistazo al fichero <a href="https://github.com/rchavarria/learning-elixir/blob/master/projects/rct_issues/test/cli_test.exs">cli_test.exs</a>)</p>

<p><strong>Transformación: obtener datos de GitHub</strong></p>

<p>La siguiente transformación sería obtener datos de GitHub. Para ello
necesitaremos alguna librería externa. Hay varios lugares donde buscar:</p>

<ol>
<li>Librerías propias de Eixir, en <a href="http://elixir-lang.org/docs">http://elixir-lang.org/docs</a></li>
<li>Librerías propias de Erlang (también distribuidas con Elixir), en
<a href="http://erlang.org/docs">http://erlang.org/docs</a></li>
<li>Si todo esto falla, podemos buscar en el repositorio de <a href="http://hex.pm">Hex</a>,
el gestor de dependencias de Elixir</li>
<li>Si aún así, todo falla, siempre nos quedará Google y GitHub</li>
</ol>


<p>El autor recomienda usar <code>HTTPoison</code> como librería. Esta librería se encuentra
en <code>Hex</code>, con lo que es muy fácil incluirla en nuestro proyecto. Simplemente
hay que modificar el método <code>deps</code> dentro del fichero <code>/mix.exs</code>, indicando el
nombre y la versión de la librería que queremos usar:</p>

<p>```
defp deps do
  [</p>

<pre><code>{ :httpoison, "~&gt; 0.4" }
</code></pre>

<p>  }
end
```</p>

<p>Con el comando <code>mix deps</code> podremos saber el estado de las dependencias del
proyecto. Con <code>mix deps.get</code> podremos descargar las dependencias que no estén
instaladas localmente. En caso de estar instaladas, lo estarán en el directorio
<code>/deps</code>, como proyectos Elixir, con lo que podremos navegar a través de ellas.</p>

<p>Ahora ya podemos usarla. Lo haremos en un nuevo módulo, escrito en
<a href="https://github.com/rchavarria/learning-elixir/blob/master/projects/rct_issues/lib/rct_issues/github_issues.ex"><code>/lib/rct_issues/github_issues.ex</code></a>. También modificaremos el método
<code>applications</code> de <code>mix.exs</code> para indicar que la dependencia <code>HTTPoison</code> va a
ser ejecutada como una <em>subaplicación</em> dentro de nuestro proyecto (hablará más
adelante sobre ello en el libro).</p>

<p><strong>Transformación: parsear la respuesta JSON</strong></p>

<p>Para la siguiente transformación incluiremos una dependencia que proviene del
mundo Erlang. <code>mix</code> es capaz de incluir dependencias de muy diversas fuentes,
Erlan entre ellas. Se añade la librería <code>jsx</code>, como dependencia del proyecto.
Añadir la línea <code>{ :jsx, "~&gt; 2.0" }</code> al fichero <code>mix.exs</code> y ejecutar el comando
<code>mix deps.get</code> para instalarla localmente.</p>

<p>Modificaremos nuestro módulo que debe parsear la respuesta,
<code>lib/rct_issues/github_issues.ex</code>:</p>

<p>```
def handle_response(%{status_code: 200, body: body}) do
  { :ok, :jsx.decode(body) }
end</p>

<p>def handle_response(%{status_code:   _, body: body}) do
  { :error, :jsx.decode(body) }
end        <br/>
```</p>

<p><strong>Configuración de la aplicación</strong></p>

<p>Cuando creamos el proyecto con <code>mix</code>, éste crea un directorio de configuración,
<code>config/</code>, con el fichero <code>config.exs</code>, donde podremos escribir ciertas
configuraciones de nuestro proyecto.
Cada línea de configuración suele ser un registro de clave valor, por ejemplo, para nuestro proyecto añadiríamos:</p>

<p><code>
use Mix.Config
config :rct_issues, github_url: "https://api.github.com"
</code></p>

<p>Más adelante, podremos usar este valor configurado gracias al módulo
<code>Application</code>, así</p>

<p>```</p>

<h1>crea una variable de clase llamada github_url</h1>

<p>@github_url Application.get_env(:rct_issues, :github_url)
```</p>

<p><strong>Construir un ejecutable</strong></p>

<p>Para ello es necesario modificar el fichero <code>mix.exs</code>, para configurar la
herramienta <code>escript</code> y poder indicarle el módulo principal de la aplicación
que se va a construir, el cual debe de tener un método llamado <code>main</code>.</p>

<p>Para construir, simplemente ejecutar el comando:</p>

<p><code>
mix escript.build
</code></p>

<p>Y tendremos un ejecutable que podremos ejecutar como cualquier otra aplicación
de consola de Unix/Linux</p>

<p><strong>Ejecutando los comentarios</strong></p>

<p>¿Cómo? ¿Ejecutar los comentarios? No te preocupes, Elixir puede ejecutar
ciertos comentarios como si fueran tests. En realidad, ejecuta comentarios
escritos en cierta forma como si fueran sesiones de la herramienta <code>iex</code>. Esto
sí que es documentación ejecutable. Simplemente, espectacular.</p>

<p>Un comentario del tipo:</p>

<p><code>``
@doc """   
Given a list of rows, where each row contains a keyed list
of columns, return a list containing lists of the data in
each column. The</code>headers` parameter contains the
list of columns to extract</p>

<h2>Example</h2>

<pre><code>iex&gt; list = [Enum.into([{"a", "1"},{"b", "2"},{"c", "3"}], HashDict.new),
...&gt;         Enum.into([{"a", "4"},{"b", "5"},{"c", "6"}], HashDict.new)]

iex&gt; Issues.TableFormatter.split_into_columns(list, [ "a", "b", "c" ])
[ ["1", "4"], ["2", "5"], ["3", "6"] ]
</code></pre>

<p>"""      <br/>
def split_into_columns(rows, headers) do</p>

<h1>...</h1>

<p>```</p>

<p>Creamos un nuevo fichero de tests en <code>test/doc_test.exs</code>:</p>

<p><code>
defmodule DocTest do
  use ExUnit.Case
  doctest Issues.TableFormatter
end  
</code></p>

<p>Donde <code>Issues.TableFormatter</code> es el módulo donde hemos incluido el comentario
<em>ejecutable</em>. Podemos lanzar los comentarios testeables con los comandos <code>mix
test test/doc_test.exs</code> o simplemente <code>mix test</code>.</p>

<p>Para crear la documentación del proyecto, está la herramienta ExDoc, similar a
JavaDoc. Para ello hay que añadirlo como dependencia del proyecto en el fichero
<code>mix.exs</code>:</p>

<p>```
defp deps do
[</p>

<h1>...</h1>

<p>  { :ex_doc, github: "elixir-lang/ex_doc" },</p>

<h1>...</h1>

<p>]
end
```</p>

<p>Para generarlos, instalar la dependencia con <code>mix deps.get</code>, y generar la
documentación con <code>mix docs</code>.</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<ul>
<li>Necesitarás consular documentación sobre <code>OptionParser</code> para ser capaz de
hacer el primer ejercicio... No solamente eso, si no que he escrito unos
tests para aprender cómo funciona <a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-05/exercise-01-round-06.exs">tests de exercise-01-round-06</a></li>
<li>¿Como se hace para formatear una cadena siempre con la misma anchura?
(¿<code>String.pad</code> o algo así?). Parece que <a href="http://elixir-lang.org/docs/stable/elixir/String.html#ljust/3"><code>String.ljust/3</code></a> hace el trabajo.</li>
</ul>


<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-06/exercise-01-round-06.exs">exercise-01-round-06</a>: repetir (honestamente) el proceso de crear un nuevo
proyecto y crear un módulo que parsee opciones de la línea de comandos y un
test para ello</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-06/exercise-02-round-06.exs">exercise-02-round-06</a>: seguir implementando el ejemplo del libro lo más
honestamente que se pueda. Se implementarán las siguientes transformaciones:
obtener los datos de GitHub con HTTPoison, parsear el JSON resultante con JSX,
extraer sólo la información que nos interesa, ordenarla y recuperar sólo la
cantidad que quiere el usuario.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-06/exercise-03-round-06.exs">exercise-03-round-06</a>: implementar el resto de la funcionalidad de la
aplicación</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-06/exercise-04-round-06.exs">exercise-04-round-06</a>: escribir una aplicación que pida datos a un organismo
de EEUU sobre el tiempo, parsee los datos XML y los muestre de forma
agradable</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: quinto asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/09/11/elixir-quinto-asalto/"/>
    <updated>2016-09-11T11:43:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/09/11/elixir-quinto-asalto</id>
    <content type="html"><![CDATA[<p>Y ya vamos por el quinto asalto, el quinto de la serie sobre el aprendizaje del
lenguaje <a href="http://elixir-lang.org/">Elixir</a>. En este asalto aprenderemos estructuras de control de flujo,
esenciales en cualquier lenguaje de programación. No sé en otros lenguajes
funcionales, pero en Elixir, estas estructuras no son muy bien acogidas. De
todas formas, son parte del lenguaje, son sencillas y nos servirán para
establecer conexiones con lenguajes que ya conozcamos.</p>

<p>Para seguir con el aprendizaje, sigo con el método seguido en otros asaltos
partiendo del post <a href="/blog/2016/01/17/aprendiendo-elixir/">aprendiendo Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/fight-II-harc-II.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/6bQhPq">Fight II / Harc II</a> de <a href="https://www.flickr.com/photos/silangel/">silangel</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p>En Elixir no se usan mucho, se suelen escribir métodos pequeños, que junto con
claúsulas de guarda y <em>pattern matching</em> nos alejan bastante de lo que aquí
estudiaremos. Normalmente, se suelen favorecer esos mecanismos frente a
estructuras de control. Al principio cuesta acostumbrarse, pero luego uno se va
dando cuenta de que los cuerpos de los métodos quedan más pequeños y más
enfocados a hacer una sola cosa, aunque despista un poco que una misma función
tenga varios cuerpos.</p>

<p><strong><code>if</code> y <code>unless</code></strong></p>

<p>```</p>

<h1>Ambos toman dos parámetros, una condición y una <em>keyword list</em>, cuyas claves posibles son <code>do:</code> y <code>else:</code>.</h1>

<p>if 1 == 2, do: "truthy", else: "falsy"
unless 2 == 1, do: "do not execute", else: "execute this"</p>

<h1>igual que las funciones, se puede acortar un poco</h1>

<p>if 1 == 2 do
  "truthy"
else
  "falsy"
end
```</p>

<p><strong><code>cond</code></strong></p>

<p>En realidad es una macro, como muchas otras construciones del lenguaje, y
acepta una serie de condiciones. Se ejecutará el código de la primera condición
que se evalúe a <code>true</code>.</p>

<p>```</p>

<h1>Resolver la kata FizzBuzz</h1>

<p>cond do
  rem(current, 3) == 0 and rem(current, 5) == 0 -> "FizzBuzz"
  rem(current, 5) == 0 -> "Buzz"
  rem(current, 3) == 0 -> "Fizz"
  true -> current
end
```</p>

<p>En muchos casos, una mejor alternativa puede ser utilizar múltiples funciones,
pattern matching y claúsulas de guarda en lugar del bloque <code>cond</code>.</p>

<p><strong><code>case</code></strong></p>

<p><code>case</code> permite evaluar una serie de patrones, y ejecuta el código asociado a
dicho patrón. También se pueden usar claúsulas de guarda.</p>

<p>```</p>

<h1>para controlar errores al abrir un fichero</h1>

<p>case File.open("some file.txt") do
  { :ok, file } -> IO.puts "First line: #{IO.read(file, :line)}"
  { :error, reason } -> IO.puts "Failed to open file: #{reason}"
end</p>

<h1>con claúsulas de guarda</h1>

<p>dave = %{name: "Dave", age: 27}
case dave do
  person = %{age: age} when is_number(age) and age >= 21 -> IO.puts "You are allowed #{person.name}"
  _ -> IO.puts "You are not allowed"
end
```</p>

<p><strong>Excepciones</strong></p>

<p>Las excepciones en Elixir se usan para casos excepcionales. Por ejemplo, si hay
un fallo al leer un fichero de configuración, con un nombre fijo. Pero no si
hay un error al leer un fichero que el usuario ha introducido el nombre,
podemos controlar eso, y no sería un error excepcional.</p>

<p>```</p>

<h1>lanzando una RuntimeError</h1>

<p>raise "Giving up"</p>

<h1>o con algunos argumentos</h1>

<p>raise RuntimeError, message: "Stack overflow"</p>

<h1>por convención, se suele escribir <code>!</code> al final de una llamada que puede</h1>

<h1>devolver una excepción bien conocida, por ejemplo</h1>

<p>{ ok: file } = File.open!("foo.bar")
```</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li>[exercise-01-round-05.exs]: reescribe la kata FizzBuzz con <code>case</code></li>
<li>[exercise-02-round-05.exs]: muchas funciones tienen una segunda
implementación, que termina con <code>!</code>, la cual, si el resultado no coincide con
<code>{ :ok, data }</code> lanza una excepción. Implementa una función <code>ok!</code> que haga
exactamente esto</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: cuarto asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/08/10/elixir-cuarto-asalto/"/>
    <updated>2016-08-10T17:20:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/08/10/elixir-cuarto-asalto</id>
    <content type="html"><![CDATA[<p>Éste es el cuarto asalto en mi aventura aprendiendo <a href="http://elixir-lang.org/">Elixir</a>. En esta ocasión
trato con tipos de datos binarios, cadenas y <strong>sigils</strong>. No es mucho, pero las cadenas son
una parte esencial de cualquier lenguaje de programación. Y dominarlas
significa dominar una gran parte del lenguaje.</p>

<p>Por supuesto, sigo aprendiendo con el método descrito en el post sobre <a href="/blog/2016/01/17/aprendiendo-elixir/">aprender Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/fourth-fight.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/5yHK4Y">Muñeco de Gohan y Bu peleando</a> de <a href="https://www.flickr.com/photos/alotor/">Alonso Javier Torres</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p>Para definir una cadena se pueden usar comillas simples o comillas dobles.
También se puede usar comillas triples, para escribir lo que llaman <code>heredocs</code>,
y se suelen usar para escribir comentarios para documentar métodos y módulos.</p>

<p>En Elixir, existe lo que llaman <em>sigils</em> (que se podría traducir como código,
señal o símbolo mágico). Comienzan con <code>~</code>, seguido de una letra que determina
el tipo de símbolo:</p>

<ul>
<li><code>c</code> para una lista de carácteres</li>
<li><code>r</code> para expresión regular</li>
<li><code>w</code> para una lista de palabras separado por espacios</li>
<li>y hay más</li>
</ul>


<p>y cuyo valor se puede enmarcar en distintos delimitadores: <code>&lt;..&gt;</code>, <code>{...}</code>,
<code>[...]</code>,...</p>

<p>Un uso muy típico es para escribir expresiones regulares:</p>

<p><code>
~r{[0-9]+[A-Z]*}
</code></p>

<p>Los <em>sigils</em> pueden incluso personalizarse, y crear los tuyos propios.</p>

<p>Las cadenas definidas mediante comillas dobles, son lo que se conoce en otros
lenguajes como <em>strings</em>. Las cadenas con comillas simples, se llaman
<em>character lists</em> (o <em>char list</em>), listas de carácteres, y son listas, arrays.</p>

<p><strong>Cadenas con comillas simples</strong></p>

<p>Son una lista de códigos que representan los carácteres. Y como son una lista,
podemos usar métodos de <code>List</code>: <code>++</code>, <code>--</code>, <code>List.zip</code>, <code>[ head | tail ]</code>,...</p>

<p>Para saber el número entero que representa un carácter, se puede usar la
notación <code>?&lt;chr&gt;</code>, por ejemplo, <code>?a</code> o <code>?4</code>, para saber los valores numéricos
de los carácteres <code>a</code> y <code>4</code> respectivamente.</p>

<p><strong>Binarios</strong></p>

<p>Qué mejor que un poco de código para ver cómo se usa este tipo de datos</p>

<p>```</p>

<h1>el tipo <em>binario</em> representa una secuencia de bits</h1>

<p>iex> b = &lt;&lt; 1, 2, 3 >>
&lt;&lt;1, 2, 3>>
iex> byte_size b
3
iex> bit_size b
24</p>

<h1>se puede especificar también la cantidad de bits que queremos que ocupen</h1>

<p>iex> b = &lt;&lt; 1::size(2), 1::size(3) >>
&lt;&lt;9::size(5)>>
iex> byte_size b
1
iex> bit_size b
5</p>

<h1>también se pueden almacenar enteros, floats y otros binarios</h1>

<p>iex> an_int = &lt;&lt; 1 >>
&lt;<1>>
iex> a_float = &lt;&lt; 2.5 :: float >>
&lt;&lt;64, 4, 0, 0, 0, 0, 0, 0>>
iex> mix = &lt;&lt; an_int :: binary, a_float :: binary >>
&lt;&lt;1, 64, 4, 0,......>></p>

<h1>extraer valores (echa un vistazo a cómo se codifican los floats según</h1>

<h1>el estándar IEEE 754)</h1>

<p>iex> &lt;&lt; sign::size(1), exp::size(11), mantissa::size(52) >> = &lt;&lt; 3.14159::float >>
iex> (1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exp-1023)
3.14159</p>

<h1>las cadenas con comillas dobles "" (dqs: double quoted string) son de</h1>

<h1>tipo binario, y están codificadas en UTF-8 lo que significa que la</h1>

<h1>longitud de la cadena no tiene por qué coincidir con el tamaño en bytes</h1>

<p>iex> dqs = "∂x/∂y"
"∂x/∂y"
iex> String.length dqs
5
iex> byte_size dqs
9
```</p>

<p><strong>Procesando cadenas</strong></p>

<p>Igual que podemos dividir una lista en <code>head</code> y <code>tail</code>, podemos extraer el
primer carácter (se refiere a él como <em>grapheme</em>, grafema/grafo/...) de una
cadena binaria o <em>dqs</em> especificando que <code>head</code> es de tipo <code>utf8</code> y que <code>tail</code>
sigue siendo de tipo binario:</p>

<p><code>
defp each(&lt;&lt; head::utf8, tail::binary &gt;&gt;), do [ head | each(tail) ]
defp each(&lt;&lt;&gt;&gt;), do []
</code></p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p>Está claro que hay que ver la documentación del módulo <a href="http://elixir-lang.org/docs/stable/elixir/String.html"><code>String</code></a>, que contiene
métodos para manipular cadenas encerradas en comillas dobles (recuerda, son de
tipo binario).</p>

<p>Las expresiones regulares son bastante comunes, y en Elixir se suelen usar
mediante <a href="http://elixir-lang.org/getting-started/sigils.html"><em>sigils</em></a>. Son un aspecto bastante curioso del lenguaje y pueden ser
personalizados.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-01-round-04.exs">exercise-01-round-04.exs</a>: escribe una función que devuelva <code>true</code> si el
parámetro (una lista de carácteres) contiene sólo carácteres imprimibles (del
espacio a la tilde)</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-02-round-04.exs">exercise-02-round-04.exs</a>: escribe una función que devuelva <code>true</code> en el
caso de que dos palabras sean anagramas. <code>anagram?(word1, word2)</code></li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-03-round-04.exs">exercise-03-round-04.exs</a>: escribe una funcion que calcule suma, resta,...
de una cadena pasada como parámetro: <code>calculate('123 + 27') # =&gt; 150</code>. Este
es especialmente difícil (al menos para mi nivel): devolver tuplas, parsear
números (utilizando recursión de una forma muy imaginativa), utilizando pattern
matching para construir funciones dependiendo del operador,...</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-04-round-04.exs">exercise-04-round-04.exs</a>: escribe una función que pasándole una lista de
dqs (double quoted strings) las imprima centradas en un ancho de la palabra
más larga, cada una en una línea distinta.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-05-round-04.exs">exercise-05-round-04.exs</a>: escribe una función que pase a mayúsculas la
primera letra de cada frase en una cadena</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-04/exercise-06-round-04.exs">exercise-06-round-04.exs</a>: escribe una función que parsee un fichero CSV
(que tendrá los campos id, estado y cantidad neta), y que se lo pase a la
función desarrollada en el tercer asalto, al ejercicio
<code>exercise-02-round-03.exs</code>.</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: tercer asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/05/01/elixir-tercer-round/"/>
    <updated>2016-05-01T17:46:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/05/01/elixir-tercer-round</id>
    <content type="html"><![CDATA[<p>Éste es el tercer asalto para aprender <a href="http://elixir-lang.org/">Elixir</a>, y las cosas se van poniendo
interesantes, aunque todavía siento que estoy muy verde y me falta todavía
mucho para ser capaz de hacer las cosas más sencillas.</p>

<p>En este asalto, aprendo nuevas cosas proporcionadas por los módulos <code>Enum</code>,
<code>Stream</code> y otras coleciones, así como las <em>comprehensions</em>, que me recuerdan
mucho a los clásicos bucles <code>for</code>.</p>

<p>Sigo aprendiendo siguiendo el método descrito en el post sobre <a href="/blog/2016/01/17/aprendiendo-elixir/">aprender Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/third-fight.png"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/c9bWJA">3rd fight</a> de <a href="https://www.flickr.com/photos/takfoto/">Tomasz Krawczak</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/legalcode">CC BY-NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Procesando colleciones con <code>Enum</code></strong></p>

<p>Elixir tiene muchos tipos de datos que actúan como colleciones: listas, mapas,
diccionarios, rangos, ficheros e incluso funciones. Las colecciones se pueden
iterar (sobretodo con funciones del módulo <code>Enum</code>), y algunas permiten añadir
elementos.</p>

<p>```</p>

<h1>convierte cualquier colección a List</h1>

<p>list = Enum.to_list 1..5
  #=> [1, 2, 3, 4, 5]</p>

<h1>concatena</h1>

<p>Enum.concat([1, 2, 3], [4, 5, 6])
  #=> [1, 2, 3, 4, 5]</p>

<h1>crea nuevas colleciones</h1>

<p>Enum.map(list, &amp;(&amp;1 * 10))
  #=> [10, 20, 30, 40, 50]</p>

<h1>selecciona elementos por posición</h1>

<p>Enum.at(10..20, 3) #=> 13
Enum.at(10..20, 20) #=> nil
Enum.filter(list, &amp;(&amp;1 > 2)) #=> [3, 4, 5]
Enum.reject(list, &amp;Integer.is_even/1) #=> [1, 3, 5]</p>

<h1>ordena y compara elementos</h1>

<p>Enum.sort([ "there", "was", "a", "crooked", "man" ],
  &amp;(String.length(&amp;1) &lt;= String.length(&amp;2))
Enum.max([ "there", "was", "a", "crooked", "man" ]) #=> "was"</p>

<h1>divide una colleción</h1>

<p>Enum.take(list, 3)    #=> [1, 2, 3]
Enum.take_every(list, 2)  #=> [1, 3, 5]
Enum.take_while(list, &amp;(&amp;1 &lt; 4))
Enum.split(list, 3)
  #=> { [1, 2, 3], [4, 5] }
Enum.split_while(list, &amp;(&amp;1 &lt; 4))
  #=> { [1, 2, 3], [4, 5] }</p>

<h1>une los elementos de una colección</h1>

<p>Enum.join(list)
Enum.join(list, ", ")   #=> "1, 2, 3, 4, 5"</p>

<h1>hace preguntas sobre operaciones</h1>

<p>Enum.all?(list, &amp;(&amp;1 &lt; 4))
Enum.any?(list, &amp;(&amp;1 &lt; 4))
Enum.member?(list, 4)
Enum.empty?(list)</p>

<h1>mezcla colecciones</h1>

<p>Enum.zip(list, [:a, :b, :c])
  #=> [ {1, :a}, {2, :b}, {3, :c} ]</p>

<h1>otros</h1>

<p>Enum.reduce(<collection>, <function>)
```</p>

<p><strong><code>Stream</code>s, enumerables diferidos o perezosos</strong></p>

<p>El módulo <code>Stream</code> permite enumerar collecciones de forma diferida (<em>lazy</em> es
la palabra utilizada, que traduzco libremente como <em>diferida</em>).</p>

<p>Las funciones del módulo <code>Enum</code> procesan todos los elementos de la colección de
una vez, consumiendo memoria. Las del módulo <code>Stream</code> consumen los elementos de
uno en uno, según se van necesitando. Los <em>streams</em> se pueden componer, es
decir, los streams son collecciones, por lo que se pueden usar las funciones de
<code>Stream</code> con los propios streams (sería como crear streams de streams).</p>

<p>Finalmente, para obtener los resultados, se puede convertir un <code>Stream</code> a una
lista:</p>

<p><code>
[1, 2, 3, 4, 5]
  |&gt; Stream.map(&amp;(&amp;1 * &amp;1)
  |&gt; Stream.map(&amp;(&amp;1 + 1)
  |&gt; Stream.filter(fn x -&gt; rem(x, 2) == 1 end)
  |&gt; Enum.to_list
</code></p>

<p>Con <code>Enum</code> debemos esperar a tener todos los elementos de la colección para
empezar a procesarlos. Con <code>Stream</code> podemos comenzar a procesarlos
inmediatamente. Imagina que leemos de un servidor remoto, o de un sensor, ambos
mandan datos infinitamente, por lo que <code>Enum</code> no sería una opción válida en
este caso.</p>

<p>Normalmente, serán las librerías y los frameworks quienes nos proporcionen los
streams con los que vamos a trabajar, pero también podemos crearlos nosotros
con métodos proporcionados por Elixir: <code>cycle</code>, <code>repeatedly</code>, <code>iterate</code>,
<code>unfold</code> y <code>resource</code>.</p>

<p>```</p>

<h1>cycle toma una coleción y va devolviendo de uno en uno indefinidamente</h1>

<h1>cuando la colección se acaba, vuelve a empezar desde el principio</h1>

<p>Stream.cycle([1, 2, 3])
  |> Enum.take(10)</p>

<h1>=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]</h1>

<h1>repeatedly toma una función y la ejecuta cada vez que se le pide un elemento</h1>

<p>Stream.repeatedly(fn -> true end) |> Enum.take(3)
  #=> [ true, true, true ]
Stream.repeatedly(&amp;:random.uniform/0) |> Enum.take(3)
  #=> [ 0.723, 0.941, 0.1234 ]</p>

<h1>iterate toma un valor inicial y una función. el primer elemento es el valor inicial,</h1>

<h1>el siguiente es el valor devuelto por la función pasándole el valor inicial, el siguiente</h1>

<h1>es el valor devuelto por la función pasándole el valor anterior, así indefinidamente</h1>

<p>Stream.iterate(0, &amp;(&amp;1 + 1)) |> Enum.take(5)
  #=> [0, 1, 2, 3, 4]</p>

<h1>unfold es similar a iterate, pero con tuplas. el primer valor de la tupla</h1>

<h1>significa el valor de la iteración actual, el segundo valor significa el valor</h1>

<h1>a procesar en la siguiente iteración</h1>

<p>Stream.unfold( {0, 1}, fn {f1, f2} -> {f1, {f2, f1+f2}} end ) |> Enum.take(15)
  #=> [0, 1, 1, 2, 3, 5, 8, 13, ... fibonacci]</p>

<h1>resource es similar a unfold. toma tres funciones como argumentos. la primera</h1>

<h1>crea el recurso, la segunda va dando valores de las iteraciones (como unfold)</h1>

<h1>y la tercera cierra el recurso (fichero, bbdd, ...)</h1>

<p>```</p>

<p><strong>El protocolo <code>Collectable</code></strong></p>

<p>No son lo mismo, y todavía no soy capaz de describir exactamente lo que es un
<em>protocolo</em>, pero el concepto que tengo de ellos hoy mismo es que son
<em>equivalentes</em> a las interfaces en los lenguajes orientados a objetos.</p>

<p><code>Enumerable</code> es un protocolo que permite iterar una colección. <code>Collectable</code>
permite añadir elementos a una colección. Se puede utilizar <code>Enum.into</code> para
hacerlo y convertir un tipo de colección en otro.</p>

<p><code>
Enum.into 1..5, [1000, 10001]
  #=&gt; [1000, 1001, 1, 2, 3, 4, 5]
</code></p>

<p><strong>Comprehensions</strong></p>

<p>Se le pueden pasar una o más colecciones, entonces extrae todas las
combinaciones posibles de los elementos de dichas colecciones, opcionalmente
puede filtrar valores, y genera una nueva colección con los valores que pasan
el filtro. La sintaxis es <code>result = for &lt;generator&gt; or &lt;filter&gt;, do:
&lt;expression&gt;</code>. Donde <code>&lt;generator&gt;</code> tiene la forma <code>pattern &lt;- collection</code> y el
filtro es simplemente una condición, por ejemplo <code>x &lt; 4</code>.</p>

<p>Las variables declaradas en una comprehension tienen la misma como ámbito, no
escapan de él.</p>

<p>```
for x <- [1, 2, 3, 4, 5], x < 4, do: x * x
  # => [1, 4, 9]</p>

<p>for x <- [1, 2], y <- [5, 6], do: x * y
  # => las posibles combinaciones serían [1, 5], [1, 6], [2, 5], [2, 6]
  # => y esas combinaciones serían las iteraciones de la comprehension</p>

<h1>se pueden usar variables de generadores en siguientes generadores</h1>

<p>min_maxes = [ {1, 4}, {2, 3}, {10, 15} ]
for { min, max } <- min_maxes, n <- min..max, do: n
  # => [ 1, 2, 3, 4, 2, 3, 10, 11, 12, 13, 14, 15 ]</p>

<h1>por defecto, las comprehensions devuelven una lista. Se puede cambiar</h1>

<h1>con el parámetro <code>into:</code></h1>

<p>for x <- ~w{ cat dog }, into: Map.new, do: { x, String.upcase(x) }
  # => %{ "cat" => "CAT", "dog" => "DOG" }
```</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p>Podría investigar sobre qué son los protocolos, pero creo que están descritos
en el libro del cual está surgiendo esta serie de posts, por lo que esperaré a
llegar ahí.</p>

<p>Tener siempre muy presente las funciones del módulo <code>Enum</code>, ya que casi seguro
que se van a utilizar siempre que haya colecciones de por medio.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/exercise-01-round-03.exs">exercise-01-round-03.exs</a>: con ayuda de la función <code>span</code> escrita anteriormente, escribir una función que devuelva la lista de números primos de <code>2</code> hasta <code>n</code></li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/exercise-02-round-03.exs">exercise-02-round-03.exs</a>: a partir de dos listas, una de tasas de impuestos, y otra de compras, calcular el importe total de cada una de las compras</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/lists-and-recursion-5.exs">lists-and-recursion-5.exs</a>: implementar funciones presentes en <code>Enum</code>: <code>all?</code>, <code>each</code>, <code>filter</code>, <code>take</code> y <code>split</code>.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-03/lists-and-recursion-6.exs">lists-and-recursion-6.exs</a>: implementar <code>flatten</code></li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir: segundo asalto]]></title>
    <link href="http://rchavarria.github.io/blog/2016/03/27/elixir-segundo-asalto/"/>
    <updated>2016-03-27T17:42:00+02:00</updated>
    <id>http://rchavarria.github.io/blog/2016/03/27/elixir-segundo-asalto</id>
    <content type="html"><![CDATA[<p>Sigo aprendiendo <a href="http://elixir-lang.org/">Elixir</a>, despacio, pero sigo con ello. Éste es el segundo
asalto del aprendizaje. En este asalto, lucho con estructuras de datos un poco
más complejas, como listas, diccionarios, <em>structs</em> o <em>sets</em>. Estas estructuras
ya existen en otros lenguajes de programación, pero en Elixir son tratadas de
una forma un poco diferente.</p>

<p>Por supuesto, en este asalto también sigo el método de aprendizaje descrito
desde el post sobre <a href="/blog/2016/01/17/aprendiendo-elixir/">aprender Elixir</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="center" src="/images/2016/rms-won.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/2PDNng">RMS won</a> de <a href="https://www.flickr.com/photos/kmerenkov/">Konstantin Merenkov</a>, <a href="https://creativecommons.org/licenses/by-nc/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc/2.0/legalcode">CC BY-NC 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Listas</strong></p>

<p>Una lista es recursiva. Está formada por una cabecera (<em>head</em>) y una cola
(<em>tail</em>). La cabecera es unicamente el primer elemento. La cola, es una lista
con el resto de elementos. De esta forma, la lista <code>[1, 2, 3]</code>, en realidad es
<code>[1 | [2 | [3 | [] ] ] ]</code> (al final se concatena una lista vacía).</p>

<p>Como las listas son recursivas, muchas funciones que manipulan listas lo son.
Elixir hace super sencilla la recursividad. Mezclando recursividad y pattern
matching, se pueden hacer virgerías. Super fácil implementar el cifrado César
(ver <a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-04-round-02.exs">exercise-04-round-02.exs</a>).</p>

<p><strong>Diccionarios</strong></p>

<p>Existen varios tipos de diccionarios: <code>Maps</code>, <code>HashDicts</code>, <code>Keywords</code>, <code>Sets</code> y
<code>Structs</code>.</p>

<p>Para acceder a una clave del diccionario: <code>dict[:key]</code>, las claves son Atoms.</p>

<p><code>Enum.into</code> convierte entre tipos enumerados, por ejemplo, entre tipos de
diccionarios.</p>

<p>```</p>

<h1>Distintas operaciones que podemos hacer sobre diccionarios</h1>

<p>dict = %{ key1: "Clave 1", key2: "Clave 2" }%
ticd = %{ key9: "Clave 9", key8: "Clave 8" }%</p>

<h1>eliminar claves de un diccionario</h1>

<p>Dict.drop(dict, [:key2])</p>

<h1>añadir claves</h1>

<p>Dict.put(dict, :key3, "Clave 3")</p>

<h1>unir diccionarios</h1>

<p>Dict.merge(dict, tcid)</p>

<h1>obtener valores, similar a dict[:key1]</h1>

<p>Dict.get(dict, :key1)</p>

<h1>obtener todos los valores</h1>

<p>Dict.values(dict)</p>

<h1>el pattern matching en diccionarios es muy útil</h1>

<p>person = %{ name: "Dave", height: 1.88 }</p>

<h1>establecer a_name = "Dave"</h1>

<p>%{ name: a_name } = person</p>

<h1>pattern matching que no falla</h1>

<p>%{ name: _, height: _ } = person</p>

<h1>pattern matching que no falla</h1>

<p>%{ name: "Dave" } = person</p>

<h1>falla</h1>

<p>%{ name: _, weight: _ } = person
** (Match error) no ...</p>

<h1>pattern matching no puede enlazar claves de diccionarios</h1>

<p>%{ 2 => state } = %{ 1 => ok:, 2 => error: }
=> state = :error</p>

<p>%{ state => ok: } = %{...}
=> Error ...</p>

<h1>para actualizar un mapa, se usa la siguiente estructura, muy parecida a <code>List</code></h1>

<h1>Puede actualizar pero no añadir</h1>

<p>new_map = %{ old_map | key => value, ... }
```</p>

<p><strong>Mapas tipados (typed maps)</strong></p>

<p>Son como un mapa que tiene un conjunto de campos fijos y valores por defecto
para ellos. Se puede utilizar <em>pattern matching</em> por tipo y por contenido.</p>

<p>Estos mapas son los llamados <code>Struct</code>. Los <code>Struct</code>s son mapas limitados: las
claves deben ser <em>Atoms</em>. Se crean con <code>defstruct</code>, y el nombre del módulo pasa
a ser el nombre del struct:</p>

<p>```
defmodule Subscribrer do
  defstruct name: "", paid: false, over_18: true
end</p>

<p>s1 = %Subscribrer{}
=> %Subscribrer{ name: "", paid: false, over_18: true }</p>

<p>s2 = %Subscribrer{ name: "Dave" }</p>

<h1>a las claves se accede mediante un punto <struct>.<key></h1>

<p>s2.name
=> "Dave"</p>

<p>%Subscribrer{ name: name } = s2
name
=> "Dave"</p>

<h1>así se actualizan los datos</h1>

<p>s3 = %Subscribrer{ s2 | name: "Marie" }</p>

<h1>la idea de que el nombre del módulo sea el nombre del Struct</h1>

<h1>es que se puedan añadir métodos al módulo que modifiquen la</h1>

<h1>estructura del Struct (esto me suena mucho a las clases de la</h1>

<h1>Programación Orientada a Objetos).</h1>

<p>defmodule Attendee do
  defstruct name: "", paid: false, over_18: true</p>

<p>  def may_attend_after_party(attendee = %Attendee{}) do</p>

<pre><code>attendee.paid &amp;&amp; attendee.over_18
</code></pre>

<p>  end</p>

<p>  ...
end
```</p>

<p>El autor reconoce que los <code>Struct</code>s se parecen mucho a los objectos de la
Programación Orientada a Objetos. Y también nos advierte que tengamos cuidado,
que no caigamos en la tentación, que nos mantengamos puros, que no mezclemos
paradigmas.</p>

<p><strong>Estructuras de diccionario anidadas</strong></p>

<p>Las <code>Structs</code> se pueden anidar. Se consigue haciendo que el valor de una de las
claves sea otro <code>Struct</code>.</p>

<p>Imagina que tenemos dos <code>Struct</code>s anidadas así:</p>

<p>```
report = %BugReport{
  owner: %Customer{</p>

<pre><code>name: "Dave",
company: "Pragmatic"
</code></pre>

<p>  },
  details: "broken"
}</p>

<h1>se puede acceder a company</h1>

<p>company = report.owner.company</p>

<h1>podemos modificarla con la macro put_in</h1>

<p>put_in(report.owner.company, "PragProg")
```</p>

<p>Con <code>update_in</code> podemos modificar el valor actual (accesible a través de un
parámetro de la macro). También existen las macros <code>get_in</code> y
<code>get_and_update_in</code></p>

<p>Esas macros también funcionan con mapas y keyword lists. Si en lugar de una
clave o lista de claves, se pasa una función, las macros se convierten en
funciones dinámicas y llamarán a esta función con tres parámetros.</p>

<p><strong>Sets</strong></p>

<p>Actualmente solo hay una implementación de ellos, <code>HashSet</code>.</p>

<p>```
one_to_five = Enum.into 1..5, HashSet.new</p>

<h1>comprueba si un valor existe o no</h1>

<p>Set.member(one_to_five, 5)
=> true</p>

<h1>concatena varios Set's</h1>

<p>three_to_eight = Enum.into 3..8, HashSet.new
Set.union(one_to_five, three_to_eight)
=> #Hashset[ 1, 2, 3, 4, 5, 6, 7, 8]</p>

<h1>qué elementos estań en el primero que no están en el segundo</h1>

<p>Set.difference(one_to_five, three_to_eight)
=> #Hashset[ 1, 2 ]
Set.difference(three_to_eight, one_to_five)
=> #Hashset[ 6, 7, 8 ]</p>

<h1>qué valores están en ambos</h1>

<p>Set.intersection(one_to_five, three_to_eight)
=> #Hashset[ 3, 4, 5 ]
```</p>

<h2>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</h2>

<p>Algunos métodos intersantes del módulo <code>List</code>: operadores para concatenar <code>++</code>,
diferencia <code>--</code>, pertenencia <code>in</code> y métodos tales como <code>flatten</code>, <code>foldl</code>,
<code>foldr</code>, <code>zip</code>, <code>unzip</code>, <code>keyfind</code>, <code>keydelete</code>, <code>keyreplace</code>,...</p>

<p>Además de los métodos que hemos visto de <code>Dict</code>, podemos encontrar: <code>values</code>,
<code>drop</code>, <code>put</code>, <code>merge</code>, <code>get</code>, <code>HashDict.new</code>,...</p>

<p>El módulo <code>Keyword</code> tiene métodos para manipular listas de tuplas, o keyword
lists: <code>delete</code>, <code>drop</code>, <code>equal?</code>, <code>get_and_update</code>, <code>merge</code>, <code>pop</code>, <code>put</code>,...</p>

<p>Existen unas macros, que sirven para manipular los valores almacenados en
diccionarios: <code>get_in</code>, <code>update_in</code>, <code>get_and_update_in</code>,... Si a estas macros
se les pasa una función en lugar de unas claves, se usará esa función para
obtener los valores del diccionario. Debería ser sencillo saber usarlas, pero
todavía no llego a entender exactamente cómo funciona y para qué se podría
utilizar.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-01-round-02.exs">exercise-01-round-02.exs</a>: antes se ha implementado (en el libro) la
funcción <code>sum</code>, que suma los elementos de una lista. Se ha utilizado un
acumulador. Implementar lo mismo sin el acumulador</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-02-round-02.exs">exercise-02-round-02.exs</a>: escribir una función <code>mapsum</code> que acepte una
lista y una función, de forma que aplique la función a cada elemento y sume
los resultados</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-03-round-02.exs">exercise-03-round-02.exs</a>: escribir una función <code>max(list)</code> que devuelva el
máximo valor de la lista</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-04-round-02.exs">exercise-04-round-02.exs</a>: implementar el cifrado César, <code>caesar(list, n)</code>,
donde <code>list</code> es una lista de carácteres (es decir, una cadena con comillas
simples <code>'cadena'</code>) y que sea circular, cuando sobrepase <code>z</code>, que vuelva a la
<code>a</code>.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-02/exercise-05-round-02.exs">exercise-05-round-02.exs</a>: escribir una función <code>span(from, to)</code> que
devuelva una lista de números desde <code>from</code> hasta <code>to</code>.</li>
</ul>


<h2>Enseñar lo aprendido</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta el siguiente asalto.</p>
]]></content>
  </entry>
  
</feed>
