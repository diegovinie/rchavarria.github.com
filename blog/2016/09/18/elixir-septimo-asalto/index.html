
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Elixir: séptimo asalto - R. Chavarria's Blog</title>
  <meta name="author" content="Rub&eacute;n Chavarr&iacute;a">

  
  <meta name="description" content="El aprendizaje va avanzando, ya vamos por el séptimo asalto. Éste trata sobre
cómo Elixir maneja múltiples procesos, por lo que trataremos algún tema &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="R. Chavarria's Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-36829645-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">R. Chavarria's Blog</a></h1>
  
    <h2>Proud of developing software, proud of being an Engineer</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:rchavarria.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archivos</a></li>
  <li><a href="/readings">Lista de lectura</a></li>
  <li><a href="/pet-projects">Proyectos</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Elixir: séptimo asalto</h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-09-18T16:20:00+02:00" pubdate data-updated="true">Sep 18<span>th</span>, 2016</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>El aprendizaje va avanzando, ya vamos por el séptimo asalto. Éste trata sobre
cómo <a href="http://elixir-lang.org/">Elixir</a> maneja múltiples procesos, por lo que trataremos algún tema de
concurrencia. También veremos algunas cosas básicas sobre cómo monitorizar los
procesos de los que consta nuestra aplicación.</p>

<p>Sin olvidar del método de aprendizaje con el que <a href="/blog/2016/01/17/aprendiendo-elixir/">comenzé</a>:</p>

<ul>
<li>Aprender lo suficiente para comenzar</li>
<li>Experimentar, jugar, buscar puntos desconocidos, hacerse preguntas</li>
<li>Aprender lo suficiente para hacer algo de utilidad</li>
<li>Enseñar lo aprendido</li>
</ul>


<p><img class="right" src="/images/2016/you-gotta-fight-for-your-right-to-eat.jpg"></p>

<div style="text-align: center">
  <span style="font-size: 60%">
Imagen basada en <a href="https://flic.kr/p/4rvPED">You gotta fight for your right to&#8230; eat</a> de <a href="https://www.flickr.com/photos/r2wk/">ldjpg</a>, <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">algunos derechos reservados</a>, licencia: <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">CC BY NC ND 2.0</a>
  </span>
</div>




<!-- more -->


<h2>Aprender lo suficiente para comenzar</h2>

<p><strong>Trabajando con múltiples procesos</strong></p>

<p>Elixir usa el <a href="https://en.wikipedia.org/wiki/Actor_model">modelo de actores</a> para gestionar la concurrencia.</p>

<p>Elixir se apoya en Erlang para gestionar los procesos, que no son los procesos
del sistema operativo.</p>

<p>Para crear un proceso, se hace con la llamada <code>spawn</code>. <code>spawn</code> puede crear un
proceso y ejecutar en él código que tengas en un módulo cualquiera. El proceso
puede empezar en cualquier momento (asíncrono total) y se utilizan mensajes
entre procesos para sincronizarlos.</p>

<p>Los mensajes no tienen por qué ser <code>Strings</code>, pueden ser de cualquier tipo
(generalmente tuplas o atoms). Los mensajes se mandan con <code>send</code>, y debes usar
un <code>PID</code> (devuelto por <code>spawn</code>).</p>

<p>El receptor, espera mensajes con <code>receive</code>. <code>receive</code> funciona como <code>case</code>: se
pueden poner varios casos, y el primero que coincida, se ejecuta.</p>

<p><code>receive</code> maneja sólo un mensaje. Si queremos recibir varios, debemos volver a
llamar al método que contiene el <code>receive</code>, de forma recursiva (y Elixir es muy
bueno con la recursividad). <code>receive</code> también acepta un parámetro, <code>after</code>,
para definir un timeout.</p>

<p>El autor dice que los procesos en Elixir son como los objetos en lenguajes
orientados a objectos, pero con mejor sentido del humor. El hecho es que son
muy livianos, y pueden mantener estado, así que podemos pensar en ellos como en
objetos de la programación orientada a objetos.</p>

<p><strong>Enlazar procesos</strong></p>

<p>Normalmente, un proceso no sabe cuando muere un proceso hijo. Debemos hacer
algo manualmente para que se notifique. Podemos crear procesos <em>enlazados</em>
(linked) con <code>spawn_link</code>. Por defecto, si un proceso hijo muere, mata al
proceso padre. Para controlar esto y poder escuchar el mensaje que lanza el
proceso hijo al morir, debemos <em>atrapar la salida</em> mediante
<code>Process.flag(:trap_exit, true)</code> justo antes de hacer <code>spawn_link</code>.</p>

<p>Dos procesos enlazados pueden comunicarse bidireccionalmente.</p>

<p>Elixir usa el framework OTP para construir árboles de procesos. OTP lleva mucho
tiempo en funcionamiento, y debemos confiar en que lo hace mucho mejor que
nosotros, por lo que lo usaremos prácticamente siempre. OTP incluye el concepto
de <em>Supervisor de procesos</em>. Más adelante estudiaremos temas relacionados con
OTP.</p>

<p><strong>Monitorizando procesos</strong></p>

<p>Si <code>spawn_link</code> permite comunicación bidireccional, <code>spawn_monitor</code> solo la
permite unidireccional. El proceso hijo puede notificar al padre, pero no al
revés.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># monitor devuelve el pid del proceso hijo y una referencia de la monitorización
</span><span class='line'>res = spawn_monitor(&lt;module&gt;, &lt;function&gt;, &lt;params&gt;)
</span><span class='line'>IO.inspect res
</span><span class='line'># =&gt; { #PID{3.3.3.3}, #Reference{1.2.3.4} }</span></code></pre></td></tr></table></div></figure>


<p>También se puede monitorizar un proceso existente con <code>Process.monitor</code>.</p>

<p>¿Cuándo utilizar cada uno? Depende de la utilidad. Si la muerte de un hijo
debería matar al padre, usa procesos enlazados. Si la muerte/fallo de un hijo
solamente debería notificar al padre, usa monitorización.</p>

<h2>Aprender lo suficiente para hacer algo de utilidad</h2>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-01-round-07.exs">exercise-01-round-07.exs</a>: ejecutar el programa que pasa mensajes en cadena
de un proceso a otro hasta llegar al millón de procesos.</li>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-02-round-07.exs">exercise-02-round-07.exs</a>: escribir un código que cree dos procesos, y que a
cada uno le mande un token (p.e.: &#8220;pepito&#8221; y &#8220;fulanito&#8221;), y que los procesos
lo devuelvan. En teoría, ¿es determinista el orden en el que se reciben las
respuestas? ¿Y en la práctica? En caso de que no, ¿cómo podría hacerse que
fuera determinista?.</li>
</ul>


<p><strong>Resultados</strong></p>

<p>Parece que sí es determinista (al menos con dos procesos). Depende del orden en
el que se creen los procesos, incluso si invertimos el orden en el que se
envían los tokens, el primer proceso creado es el primero en responder.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-03-round-07.exs">exercise-03-round-07.exs</a>: usa <code>spawn_link</code> para crear un proceso, el cual
envía un mensaje al padre y finaliza inmediatamente. Mientras, en el padre,
después de crear el proceso, espera 500ms y luego comienza a recibir todos los
mensajes que están esperando. Tracea todo lo que recibas. ¿Importa que no
estuvieras recibiendo notificaciones cuando el hijo terminó?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No recibe ningún mensaje, el hijo termina, terminando al padre durante la
espera.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-04-round-07.exs">exercise-04-round-07.exs</a>: repite el ejercicio anterior, pero en lugar de
terminar con <code>exit</code>, que el hijo lance una excepción. ¿qué diferencia notas?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No hay mucha difrencia. El padre sigue terminando, sin escuchar ningún mensaje.
Al menos, la excepción aparece por consola, mostrándose un error diciendo que
el proceso hijo (con su PID) ha lanzado una excepción. En el ejercicio
anterior, solamente aparecía que el proceso padre terminaba, nada más.</p>

<p>Usando <code>Process.flag(:trap_exit, true)</code>, el proceso padre recibe mensajes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ elixir -r exercise-03-round-07.exs -e "Exercise3.run"
</span><span class='line'>Parent's PID #PID&lt;0.48.0&gt;
</span><span class='line'>PID's child #PID&lt;0.53.0&gt;
</span><span class='line'>Received: "Hello!"
</span><span class='line'>Received: {:EXIT, #PID&lt;0.53.0&gt;, :boom}
</span><span class='line'>
</span><span class='line'>$ elixir -r exercise-04-round-07.exs -e "Exercise4.run"
</span><span class='line'>Parent's PID #PID&lt;0.48.0&gt;
</span><span class='line'>Child's PID #PID&lt;0.53.0&gt;
</span><span class='line'>
</span><span class='line'>22:46:14.313 [error] Process #PID&lt;0.53.0&gt; raised an exception
</span><span class='line'>** (RuntimeError) Child finished
</span><span class='line'>    exercise-04-round-07.exs:19: Exercise4.child/1
</span><span class='line'>Received: "Hello!"
</span><span class='line'>Received: {:EXIT, #PID&lt;0.53.0&gt;, %{RuntimeError{message: "Child finished"},
</span><span class='line'>[{Exercise4, :child, 1, [file: 'exercise-04-round-07.exs', line: 19]}]}}</span></code></pre></td></tr></table></div></figure>


<p>Las diferencias están en lo recibido en el mensaje de terminación del hijo. En
caso de <code>exit</code> se recibe <code>:EXIT</code>, un PID, y la causa de la salida. En el caso
de la excepción: <code>:EXIT</code>, un PID y la excepción, parece, porque tiene pinta de
pila de llamadas, con su módulo, función, parámetros,&#8230;</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-05-round-07.exs">exercise-05-round-07.exs</a>: repetir el ejercicio pero con <code>spawn_monitor</code>.</li>
</ul>


<p><strong>Resultados</strong></p>

<p>No creo que lo esté haciendo bien. Se supone que monitorizando la comunicación
no es bidireccional, pero el padre recibe el mensaje que envía el hijo, así
como el mensaje que se envía al terminar o lanzar la excepción. La única
diferencia visible es que en lugar de recibir solamente un PID, se recibe un
PID y la referencia de monitorización.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-06-round-07.exs">exercise-06-round-07.exs</a>: escribir una función implementando <em>pararell
map</em>, que es como una función <code>map</code> pero cada elemento es procesado por un
proceso distinto. Preguntas: ¿por qué es necesario guardar en la variable <code>me</code>
el PID del proceso padre? Se debe utilizar <code>^pid</code> para recibir los resultados
en orden, pero&#8230; ¿qué pasa si se utiliza <code>_pid</code>? ¿cómo hacer para que falle:
esperas, aumentar número elementos, que la función que procesa cada elemento
sea más complicada,&#8230;?</li>
</ul>


<p><strong>Resultados</strong></p>

<p>Aumentando el número de elementos afecta al orden en el que se reciben los
mensajes. También he conseguido recibir mensajes en orden distinto con el
siguiente código:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Parallel.pmap 1..10, fn (i) -&gt;
</span><span class='line'>  # la espera es más corta según el elemento `i` se va a haciendo mayor
</span><span class='line'>  wait_up_to = round(10 / i)
</span><span class='line'>  :timer.sleep(wait_up_to)
</span><span class='line'>  i
</span><span class='line'>end
</span><span class='line'>  #=&gt; [ 7, 8, 9, 10, 5, 6, 3, 4, 2, 1 ]</span></code></pre></td></tr></table></div></figure>


<p>Volviendo a poner <code>^pid</code> el orden vuelve a ser correcto.</p>

<ul>
<li><a href="https://github.com/rchavarria/learning-elixir/blob/master/code/round-07/exercise-07-round-07.exs">exercise-07-round-07.exs</a>: toma como referencia un planificador (servidor de
Fibonacci) de un ejercicio del libro y crea otro similar. Esta vez, se deben
contar las apariciones de la palabra <code>cat</code> en cada fichero que se encuentre en
un directorio dado. Cada fichero será procesado por un proceso distinto.
¿Podrías escribir el planificador de una forma más genérica?</li>
</ul>


<h2>Enseñar lo aprendido, y repetir desde el paso 7</h2>

<p>Aquí está, este post, mis notas, mis pensamientos, mis dudas y mi código. Hasta
el siguiente asalto.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Ruben Chavarria</span></span>

      








  


<time datetime="2016-09-18T16:20:00+02:00" pubdate data-updated="true">Sep 18<span>th</span>, 2016</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/elixir/'>elixir</a>, <a class='category' href='/blog/categories/learning/'>learning</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto/" data-via="rchavarriat" data-counturl="http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/09/14/elixir-sexto-asalto/" title="Previous Post: Elixir: sexto asalto">&laquo; Elixir: sexto asalto</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/09/18/zen-arte-mantenimiento-motocicletas/" title="Next Post: Zen y el arte en el mantenimiento de motocicletas">Zen y el arte en el mantenimiento de motocicletas &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/12/04/the-4-hour-body/">The 4 hour body</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/28/mi-codemotion-2016/">Mi Codemotion 2016</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/27/global-day-of-code-retreat-2016/">Global Day of Code Retreat 2016</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/18/zen-arte-mantenimiento-motocicletas/">Zen y el arte en el mantenimiento de motocicletas</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/18/elixir-septimo-asalto/">Elixir: séptimo asalto</a>
      </li>
    
  </ul>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating...</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("rchavarriat", 4, true);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <p>Follow <a href="http://twitter.com/rchavarriat">@rchavarriat</a></p>
  
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/rchavarriat?count=5&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/rchavarriat">My Delicious Bookmarks &raquo;</a></p>
</section>




  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Rub&eacute;n Chavarr&iacute;a -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'rchavarria-github-com';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto/';
        var disqus_url = 'http://rchavarria.github.io/blog/2016/09/18/elixir-septimo-asalto/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
